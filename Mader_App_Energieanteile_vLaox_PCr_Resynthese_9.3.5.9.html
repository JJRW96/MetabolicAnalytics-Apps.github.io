<!-- 
Hinzufügen:
1. Ruhe-Glykogen-Einstellung zu Tab 2
2. In Tab 2 Cadence-Dependency fixen und die Möglichkeit haben, die Kurven permanent ein- oder auszublenden durch Klicken
3. Automatische Muskelmassen-Berechnung durch Klick
4. RQ anahand Substrat, dann P/O2-Berechnung anhand des Substratverbrauchs + Substratverbrauch in Tab 2 einblenden
5. Mit RQ kann dann auch Brutto und Netowirk besser berechnet werden und P/O2 etc...
6. Blutlaktat modelliern
7. In Tab 1 VO2ss als Prozent von 100% und dann auf gleicher Achse ncoh RQ
8. Ausgabe wie viel Stress score der verschiedeneenanteile und auch wie viel substrate verstoffwechelt wurden
9. In Tab 2 ein VO2-Startpunkt optional festelegen, so dass PCr SPeicher nicht immer direkt leer werden am Start
10. Bi Exponentiell funtkeiornt nioch nicht ganz korrekt.
11. Swap Axes Kram entfernen
12. deltaG, Freie Enthalpie anahand der der Abnehmenden PCr Konzentrationen modellieren -> Abhanme der freien Enthalpie -> Heck S. 56 & Nelsonc Cox 2012 S. 519
-->


<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Metabolic Simulation</title>
    <script src="https://cdn.plot.ly/plotly-3.0.1.min.js"></script></script>
    <script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <style>
        /* Root variables for color scheme */
        :root {
            --primary-color: #2683C6;
            --secondary-color: #9C85C0;  
            --accent-color: #EF5350;
            --light-color: #f8f9fa;
            --dark-color: #343a40;
            --border-color: #dee2e6;
            --gradient-start: #f1f8ff;
            --gradient-end: #ffffff;
            --cho-color: #D81B60; /* Carbohydrate color (orange) */
            --fat-color: #009688; /* Fat color (dark green) */
            --glycogen-color: #D81B60; /* Glycogen color (brown) */
        }
        
        /* Base styles for all elements */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Roboto', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        /* Body styles */
        body {
            background-color: #f5f5f5;
            color: var(--dark-color);
            line-height: 1.6;
            overflow: hidden;
        }
        
        /* Main container layout */
        .container {
            display: flex;
            height: 100vh;
            max-width: 100%;
        }
        
        /* Sidebar styles */
        .sidebar {
            width: 350px;
            flex-shrink: 0; /* Prevent sidebar from shrinking */
            background: linear-gradient(to bottom, var(--gradient-start), var(--gradient-end));
            padding: 20px;
            box-shadow: 2px 0 5px rgba(0,0,0,0.1);
            overflow-y: auto; /* Add scrollbar to sidebar */
            border-right: 1px solid var(--border-color);
            max-height: 100vh;
            position: relative;
            z-index: 10;
        }
        
        /* Main content area */
        .main-content {
            flex: 1;
            padding: 20px;
            display: flex;
            flex-direction: column;
            background-color: #fff;
            overflow-y: auto;
            width: 100%; /* Stelle sicher, dass der Container die volle Breite nutzt */
        }
        
        /* Heading styles */
        h1 {
            color: var(--primary-color);
            margin-bottom: 20px;
            font-size: 1.8rem;
            text-align: center;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--border-color);
        }
        
        /* Control group container */
        .control-group {
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid var(--border-color);
            background-color: white;
            border-radius: 6px;
            padding: 15px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        
        .control-group:last-child {
            border-bottom: none;
        }
        
        /* Control label styles */
        .control-label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: var(--dark-color);
        }
        
        /* Slider container */
        .slider-container {
            margin-bottom: 15px;
        }
        
        .slider-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
        }
        
        .slider-label label {
            flex-grow: 1;
        }
        
        .slider-value {
            min-width: 60px;
            text-align: right;
            font-weight: bold;
            color: var(--primary-color);
        }
        
        /* Range slider styling */
        .range-slider {
            -webkit-appearance: none;
            width: 100%;
            height: 8px;
            border-radius: 5px;
            background: linear-gradient(to right, #ddd, var(--primary-color));
            outline: none;
            margin: 10px 0;
        }
        
        .range-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--primary-color);
            cursor: pointer;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        
        .range-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--primary-color);
            cursor: pointer;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        
        /* Checkbox styling */
        .checkbox-container {
            display: flex;
            align-items: center;
            margin: 10px 0;
            cursor: pointer;
        }
        
        .checkbox-container input {
            margin-right: 10px;
            cursor: pointer;
        }
        
        /* Radio button group */
        .radio-group {
            margin: 10px 0;
        }
        
        .radio-option {
            margin: 5px 0;
            display: flex;
            align-items: center;
            cursor: pointer;
        }
        
        .radio-option input {
            margin-right: 10px;
            cursor: pointer;
        }
        
        /* Button styling */
        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
            margin-top: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        button:hover {
            background-color: #1a6eae;
            transform: translateY(-1px);
            box-shadow: 0 3px 5px rgba(0,0,0,0.15);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        /* Plot container styling */
        #plot-container, #steptest-plot-container, #substrate-plot-container {
            height: 680px; 
            width: 100%; /* Stelle sicher, dass der Container die volle Breite nutzt */
            max-width: 100%; /* Begrenze die maximale Breite */
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.08);
            margin-bottom: 20px;
            padding: 5px;
            box-sizing: border-box; /* Stelle sicher, dass Padding nicht die Breite erhöht */
        }
        
        #substrate-plot-container {
            height: 350px; /* Smaller height for substrate plot */
            display: none; /* Initially hidden */
        }
        
        /* Values container for data display */
        #values-container {
            background-color: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.08);
            font-family: monospace;
            white-space: pre-wrap;
            height: 220px;
            overflow-y: auto;
            color: #444;
            font-size: 0.92rem;
            border-left: 4px solid var(--primary-color);
        }
        
        /* Notification popup */
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background-color: white;
            padding: 10px 15px;
            border-radius: 5px;
            box-shadow: 0 2px 15px rgba(0,0,0,0.2);
            display: none;
            max-width: 300px;
            z-index: 1000;
            animation: fadeIn 0.3s;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .notification.warning {
            border-left: 4px solid #42BA97; 
        }
        
        .notification.info {
            border-left: 4px solid var(--primary-color);
        }
        
        /* Subheading */
        h4 {
            margin-top: 15px;
            color: var(--primary-color);
        }
        
        /* Horizontal rule */
        hr {
            border: 0;
            height: 1px;
            background-color: var(--border-color);
            margin: 15px 0;
        }
        
        /* Dual slider container */
        .dual-slider-container {
            position: relative;
            margin-bottom: 15px;
        }
        
        .dual-slider {
            -webkit-appearance: none;
            width: 100%;
            height: 8px;
            border-radius: 5px;
            background: linear-gradient(to right, #ddd, var(--primary-color));
            outline: none;
            margin: 10px 0;
        }
        
        .dual-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--primary-color);
            cursor: pointer;
            z-index: 2;
        }
        
        .dual-slider-values {
            display: flex;
            justify-content: space-between;
            font-size: 0.9rem;
        }
        
        /* Header section with info icon */
        .header-section {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .info-icon {
        color: var(--primary-color);
        cursor: pointer;
        font-size: 1.2rem;
        display: flex;
        align-items: center;
        justify-content: center;
        width: 22px;
        height: 22px;
        border-radius: 50%;
        background-color: rgba(38, 131, 198, 0.1);
    }

    /* Tooltip styles */
    .tooltip {
        position: relative;
        display: inline-block;
    }

    .tooltip .tooltiptext {
        visibility: hidden;
        width: 220px;
        background-color: #555;
        color: #fff;
        text-align: left;
        border-radius: 6px;
        padding: 10px;
        position: absolute;
        z-index: 1000; /* Hoher z-index für Vordergrundanzeige */
        top: 25px;
        left: -10px; /* Leicht nach links versetzt */
        opacity: 0;
        transition: opacity 0.3s;
        font-size: 0.9rem;
        line-height: 1.4;
        box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        overflow-wrap: break-word;
        word-wrap: break-word;
        pointer-events: none; /* Verhindert, dass der Tooltip Mausklicks blockiert */
    }

    /* Stelle sicher, dass der Tooltip nicht über die Sidebar hinausragt */
    .sidebar .tooltip .tooltiptext {
        max-width: 280px; /* Etwas weniger als die Sidebar-Breite (350px) */
    }

    /* Tooltip position for icons near the right edge of sidebar */
    .sidebar .control-group .header-section .tooltip .tooltiptext,
    .sidebar .control-group .slider-label .tooltip .tooltiptext,
    .sidebar .control-group .parameter-row .tooltip .tooltiptext {
        left: auto;
        right: 0;
    }

    /* Tooltip position for icons in checkboxes that are right-aligned */
    .sidebar .checkbox-container .tooltip .tooltiptext {
        left: auto;
        right: 0;
    }

    .tooltip:hover .tooltiptext {
        visibility: visible;
        opacity: 1;
    }

    /* Axis controls container */
    .axis-controls {
        display: flex;
        justify-content: space-between;
        margin-bottom: 20px;
        padding: 10px;
        background-color: rgba(38, 131, 198, 0.05);
        border-radius: 4px;
    }

    /* Axis control checkbox container */
    .axis-control-container {
        margin-bottom: 10px;
    }

    .card-title {
        margin-bottom: 10px;
        font-weight: 600;
        font-size: 1.1rem;
        color: var(--primary-color);
        border-bottom: 1px solid var(--border-color);
        padding-bottom: 5px;
    }

    /* Fancy checkbox styling */
    .fancy-checkbox {
        display: inline-block;
        position: relative;
        padding-left: 30px;
        cursor: pointer;
        font-size: 0.9rem;
        user-select: none;
    }
        
        .fancy-checkbox input {
            position: absolute;
            opacity: 0;
            cursor: pointer;
            height: 0;
            width: 0;
        }
        
        .checkmark {
            position: absolute;
            top: 0;
            left: 0;
            height: 20px;
            width: 20px;
            background-color: #eee;
            border-radius: 3px;
            transition: all 0.2s;
        }
        
        .fancy-checkbox:hover input ~ .checkmark {
            background-color: #ccc;
        }
        
        .fancy-checkbox input:checked ~ .checkmark {
            background-color: var(--primary-color);
        }
        
        .checkmark:after {
            content: "";
            position: absolute;
            display: none;
        }
        
        .fancy-checkbox input:checked ~ .checkmark:after {
            display: block;
        }
        
        .fancy-checkbox .checkmark:after {
            left: 7px;
            top: 3px;
            width: 5px;
            height: 10px;
            border: solid white;
            border-width: 0 2px 2px 0;
            transform: rotate(45deg);
        }
        
        /* Small text helper */
        .small-text {
            font-size: 0.85rem;
            color: #666;
            margin-top: 5px;
        }
        
        /* Model info box */
        .model-info {
            font-size: 0.9rem;
            color: #666;
            margin: 10px 0;
            padding: 10px;
            border-left: 3px solid var(--secondary-color);
            background-color: rgba(66, 186, 151, 0.05);
        }
        
        /* Badge styles */
        .badge {
            display: inline-block;
            padding: 3px 7px;
            font-size: 0.75rem;
            font-weight: 600;
            border-radius: 12px;
            margin-left: 5px;
            vertical-align: middle;
        }
        
        .badge-primary {
            background-color: var(--primary-color);
            color: white;
        }
        
        .badge-secondary {
            background-color: var(--secondary-color);
            color: white;
        }
        
        .badge-accent {
            background-color: var(--accent-color);
            color: white;
        }
        
        /* Parameter row layout */
        .parameter-row {
            margin-bottom: 12px;
            display: flex;
            align-items: center;
        }
        
        .parameter-label {
            flex-grow: 1;
            font-size: 0.9rem;
        }

        /* Customize scrollbar for the sidebar */
        .sidebar::-webkit-scrollbar {
            width: 8px;
        }
        
        .sidebar::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }
        
        .sidebar::-webkit-scrollbar-thumb {
            background: #bbb;
            border-radius: 10px;
        }
        
        .sidebar::-webkit-scrollbar-thumb:hover {
            background: #999;
        }
        
        /* Tab Styling */
        .tabs {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .tab {
            padding: 10px 20px;
            cursor: pointer;
            transition: all 0.3s;
            border-bottom: 3px solid transparent;
            font-weight: 500;
        }
        
        .tab.active {
            color: var(--primary-color);
            border-bottom: 3px solid var(--primary-color);
        }
        
        .tab:hover:not(.active) {
            background-color: rgba(38, 131, 198, 0.05);
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        /* File Upload Styling */
        .file-upload {
            border: 2px dashed #ccc;
            border-radius: 5px;
            padding: 15px;
            margin: 10px 0;
            text-align: center;
            background-color: #f9f9f9;
            transition: all 0.3s;
            cursor: pointer;
        }
        
        .file-upload:hover {
            border-color: var(--primary-color);
            background-color: rgba(38, 131, 198, 0.05);
        }
        
        .file-upload input {
            display: none;
        }
        
        .file-upload-label {
            display: block;
            font-weight: 500;
            margin-bottom: 10px;
            color: #555;
        }
        
        .file-upload-info {
            font-size: 0.8rem;
            color: #777;
            margin-top: 10px;
        }
        
        .file-name {
            font-weight: 500;
            color: var(--primary-color);
            margin-top: 10px;
            word-break: break-all;
        }
        
        /* Swap axes container - removed as per request */
        .swap-axes-container {
            margin: 15px 0;
            padding: 10px;
            background-color: rgba(38, 131, 198, 0.05);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        /* Exercise Summary Statistics Styling */
        .exercise-summary {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.08);
            padding: 15px;
            margin: 20px 0;
            font-family: 'Roboto', sans-serif;
            height: 300px;
            overflow-y: auto;
            border-left: 4px solid var(--primary-color);
        }

        .exercise-summary h3 {
            margin-top: 0;
            color: var(--primary-color);
            font-size: 1.2rem;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border-color);
        }

        .summary-content {
            font-family: monospace;
            font-size: 0.92rem;
            color: #444;
        }

        .summary-row {
            margin-bottom: 6px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .summary-label {
            font-weight: 600;
        }

        .summary-value {
            font-weight: bold;
            color: var(--dark-color);
        }

        /* Disclaimer alert */
        .disclaimer-alert {
            background-color: #ffecb3;
            color: #7a5700;
            padding: 12px;
            margin-bottom: 15px;
            border-radius: 5px;
            border-left: 5px solid #ffc107;
            font-size: 0.9rem;
        }
        
        /* Efficiency parameter display */
        .eta-value {
            font-weight: bold;
            color: var(--primary-color);
            margin-left: 5px;
        }
        
        .eta-infobox {
            background-color: rgba(38, 131, 198, 0.05);
            padding: 10px;
            margin-top: 10px;
            border-left: 3px solid var(--primary-color);
            font-size: 0.9rem;
        }
        
        .formula {
            font-style: italic;
            margin: 5px 0;
            font-family: 'Times New Roman', serif;
        }
        
        /* Substrate utilization styles */
        .dropdown-container {
            margin: 10px 0;
        }
        
        .dropdown-label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            font-size: 0.9rem;
        }
        
        .dropdown-select {
            width: 100%;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background-color: white;
            font-size: 0.9rem;
            color: var(--dark-color);
            cursor: pointer;
        }
        
        .substrate-info {
            background-color: rgba(255, 165, 0, 0.1);
            padding: 10px;
            margin-top: 10px;
            border-left: 3px solid var(--cho-color);
            font-size: 0.9rem;
        }
    </style>

    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        <script>
            // Optionale MathJax Konfiguration (passen Sie diese bei Bedarf an)
            // Diese Konfiguration stellt sicher, dass Formeln in $$...$$ gerendert werden
            window.MathJax = {
                tex: {
                    inlineMath: [['$', '$'], ['\\(', '\\)']],
                    displayMath: [['$$', '$$'], ['\\[', '\\]']]
                },
                svg: {
                    fontCache: 'global'
                }
            };
        </script>
</head>

<body>
    <div class="container">
        <div class="sidebar" id="sidebar">
            <h1 style="font-size: 1.3em;">Mader's Metabolic Simulation</h1>
          
          <div class="tabs">
              <div class="tab active" data-tab="leistungsdiagramm">P-V̇O<sub>2</sub>-La Dynamics</div>
              <div class="tab" data-tab="belastungssimulation">Exercise Simulation</div>
          </div>
          
          <!-- Tab 1: Power Diagram Controls -->
          <div class="tab-content active" id="leistungsdiagramm-content">
              <div class="control-group" id="ce-controls">
                  <div class="header-section">
                      <div class="control-label">Oxygen Demand Settings</div>
                      <div class="tooltip info-icon">ⓘ
                          <span class="tooltiptext">Describes the P-V̇O<sub>2</sub>Relationship during incrementel cycling exercise</span>
                      </div>
                  </div>
                  
                  <div class="checkbox-container">
                      <label class="fancy-checkbox">
                          <input type="checkbox" id="curvilinear" name="curvilinear">
                          <span class="checkmark"></span>
                          Curvilinear CE relationship
                          <div class="tooltip info-icon" style="margin-left: 47px;">ⓘ
                              <span class="tooltiptext">
                                <p>A linear V̇O<sub>2</sub>-P relationship shows constant oxygen cost per unit work, suggesting uniform efficiency. The curvilinear model exhibits increasing oxygen consumption at higher intensities, reflecting physiological changes and decreased efficiency above lactate threshold.</p>
                                <p>Here, CE<sub>Start</sub> represents efficiency at the beginning of the V̇O<sub>2</sub>-P curve, while CE<sub>Target</sub> represents efficiency at the end, coinciding exactly with V̇O<sub>2,max</sub>.</p>
                              </span>
                          </div>
                      </label>
                  </div>
                  
                  <div id="linear-ce-control" class="slider-container">
                      <div class="slider-label">
                          <label for="CEVO2">CE (ml·min<sup>-1</sup>·W<sup>-1</sup>):</label>
                          <span id="CEVO2-value" class="slider-value">10.9</span>
                      </div>
                      <input type="range" id="CEVO2" class="range-slider" min="8" max="15" value="11" step="0.1">
                      
                      <div class="parameter-row" style="margin-top: 5px;">
                        <div class="parameter-label">Delta Efficiency (Δη):</div>
                        <span id="delta-eta-value" class="slider-value">24.7-26.5%</span>
                        <div class="tooltip info-icon" style="margin-left: 5px;">ⓘ
                            <span class="tooltiptext">                                  
                                <p>Delta efficiency is calculated from the slope of the P-V̇O<sub>2</sub>-Relationship (CE) using the caloric equivalent (depends on the RQ value with a range between 19.62 and 21.13 [kJ·l<sup>-1</sup>]):</p>
                                <p>Δη = 1 / ((CE · caloric Equivalent) / 60)</p>
                                <p>Example: Δη = 1 / ((11.65 · 20.87) / 60) ≈ 24.7%</p>
                            </span>
                        </div>
                    </div>
                    
                    <div class="parameter-row">
                        <div class="parameter-label">η<sub>gross</sub> (Fat<sub>max</sub> | MLSS):</div>
                        <span id="gross-eta-value" class="slider-value">FAT<sub>max</sub>:20.3% | MLSS=23.1%</span>
                        <div class="tooltip info-icon" style="margin-left: 5px;">ⓘ
                            <span class="tooltiptext">                                  
                                <p>Gross efficiency is the ratio of mechanical work performed to total aerobic energy expenditure:</p>
                                <p>η<sub>gross</sub> = (Power output [Watt]) / (Aerobic energy expenditure [Watt])</p>
                                <p>Typically ranging from 19-22% in cycling. Values are calculated at both FAT<sub>max</sub> and MLSS power outputs using the predicted RQ to determine caloric equivalents.</p>
                            </span>
                        </div>
                    </div>
                    
                    <div class="parameter-row">
                        <div class="parameter-label">η<sub>net</sub> (Fat<sub>max</sub> | MLSS):</div>
                        <span id="net-eta-value" class="slider-value">FAT<sub>max</sub>=24.2% | MLSS=27.5%</span>
                        <div class="tooltip info-icon" style="margin-left: 5px;">ⓘ
                            <span class="tooltiptext">                                  
                                <p>Net efficiency is the ratio of mechanical work performed to aerobic energy expenditure above resting level:</p>
                                <p>η<sub>net</sub> = (Power output [Watt]) / (Aerobic energy expenditure - Resting energy expenditure [Watt])</p>
                                <p>By eliminating the influence of resting metabolism, net efficiency yields systematically higher values than gross efficiency, typically between 19-24% in cycling. This calculation accounts for the energy that's actually used for the exercise itself rather than basic bodily functions.</p>
                            </span>
                        </div>
                    </div>
                  </div>
                  
                  <div id="curvilinear-ce-control" class="slider-container" style="display:none;">
                      <div class="slider-label">
                          <label for="CE_range_start">CE<sub>Start</sub> (ml·min<sup>-1</sup>·W<sup>-1</sup>):</label>
                          <span id="CE_range_start-value" class="slider-value">10.0</span>
                      </div>
                      <input type="range" id="CE_range_start" class="range-slider" min="8" max="15" value="11" step="0.1">
                      
                      <div class="slider-label">
                          <label for="CE_range_end">CE<sub>Target</sub> (ml·min<sup>-1</sup>·W<sup>-1</sup>):</label>
                          <span id="CE_range_end-value" class="slider-value">12.5</span>
                      </div>
                      <input type="range" id="CE_range_end" class="range-slider" min="8" max="15" value="12" step="0.1">
                  </div>
              </div>
              
              <div class="control-group">
                  <div class="header-section">
                      <div class="control-label">Cadence Dependency</div>
                      <div class="tooltip info-icon">ⓘ
                          <span class="tooltiptext">Incorporate cycling cadence effects on the V̇O<sub>2</sub>-P relationship as described in Dunst et al. (2025). This modifies metabolic parameters based on the pedaling rate.</span>
                      </div>
                  </div>
                  
                  <div class="checkbox-container">
                      <label class="fancy-checkbox">
                          <input type="checkbox" id="cadence_dependent" name="cadence_dependent">
                          <span class="checkmark"></span>
                          Enable U-Shaped Cadence Dependency
                      </label>
                  </div>
                  
                  <div id="cadence-controls" style="display:none;">
                      <div id="cadence-control" class="slider-container">
                          <div class="slider-label">
                              <label for="cadence">Cadence (rpm):</label>
                              <span id="cadence-value" class="slider-value">80</span>
                          </div>
                          <input type="range" id="cadence" class="range-slider" min="20" max="200" value="80" step="1">
                      </div>
                      
                  <div class="parameter-row">
                      <div class="parameter-label">CE-Dependency:</div>
                      <div class="spacer"></div>
                      <div class="tooltip info-icon">ⓘ
                          <span class="tooltiptext">Formula: CEV̇O<sub>2</sub>(rpm) = 0.0004 · rpm² - 0.094 · rpm + 16.857. Research shows a U-shaped relationship between cadence and oxygen demand per watt.</span>
                      </div>
                      <span class="slider-value">✓</span>
                  </div>
                  
                  <div class="parameter-row">
                      <div class="parameter-label">V̇O<sub>2,Base</sub> Dependency:</div>
                      <div class="spacer"></div>
                      <div class="tooltip info-icon">ⓘ
                          <span class="tooltiptext">Formula: V̇O<sub>2,Base</sub>(rpm) = 0.172 · rpm² - 14.460 · rpm + 548.039. Research shows a U-shaped relationship between cadence and resting oxygen uptake.</span>
                      </div>
                      <span class="slider-value">✓</span>
                  </div>
                      
                  <div class="checkbox-container">
                      <label class="fancy-checkbox">
                          <input type="checkbox" id="vo2max_dependent" name="vo2max_dependent">
                          <span class="checkmark"></span>
                          Include V̇O<sub>2,max</sub> Dependency
                      </label>
                      <div class="tooltip info-icon">ⓘ
                          <span class="tooltiptext">Based on Fig.4 from the paper, V̇O<sub>2,max</sub> might also be slightly cadence-dependent, with optimal values around 80-90 rpm. This is an experimental feature.</span>
                      </div>
                      <span class="slider-value">?</span>
                  </div>
                  
                  <div class="checkbox-container">
                      <label class="fancy-checkbox">
                          <input type="checkbox" id="vlamax_dependent" name="vlamax_dependent">
                          <span class="checkmark"></span>
                          Include vLa<sub>max</sub> Dependency 
                      </label>
                      <div class="tooltip info-icon">ⓘ
                          <span class="tooltiptext">Formula: vLa<sub>max</sub>(rpm) = -0.0002 · rpm² + 0.00931 · rpm. The paper suggests this may not reflect true physiological processes but rather testing methodology limitations.</span>
                      </div>
                      <span class="slider-value">?</span>
                  </div>
              </div>
                  
                  <div class="small-text">Based on the research from Dunst et al. (2025) showing how metabolic parameters vary with cycling cadence.</div>
              </div>
              
              <div class="control-group">
                  <div class="header-section">
                      <div class="control-label">Physiological Input-Parameters</div>
                      <div class="tooltip info-icon">ⓘ
                          <span class="tooltiptext">Physiological input parameters to calculate workload-specific metabolic response according to Mader's metabolic model.</span>
                      </div>
                  </div>
                  
                  <div class="slider-container">
                      <div class="slider-label">
                          <label for="VO2max">V̇O<sub>2,max</sub> (ml·min<sup>-1</sup>):</label>
                          <span id="VO2max-value" class="slider-value">6450</span>
                      </div>
                      <input type="range" id="VO2max" class="range-slider" min="2000" max="7500" value="6450" step="10">
                  </div>
                  
                  <div class="slider-container">
                      <div class="slider-label">
                          <label for="VO2max_kg">V̇O<sub>2,max</sub> (ml·min<sup>-1</sup>·kg<sup>-1</sup>):</label>
                          <span id="VO2max_kg-value" class="slider-value">66.67</span>
                      </div>
                      <input type="range" id="VO2max_kg" class="range-slider" min="30" max="100" value="66.67" step="0.01">
                  </div>
                  
                  <div class="slider-container">
                      <div class="slider-label">
                          <label for="VO2Base">V̇O<sub>2,Base</sub> (ml·min<sup>-1</sup>):</label>
                          <span id="VO2Base-value" class="slider-value">394</span>
                      </div>
                      <input type="range" id="VO2Base" class="range-slider" min="200" max="800" value="394" step="1">
                  </div>
                  
      
                <div class="slider-container">
                        <div class="slider-label" style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <label for="vLamax">vLa<sub>max</sub> (mmol·l<sup>-1</sup>·s<sup>-1</sup>):</label>
                                <span id="vLamax-value" style="margin-left: 50px;" class="slider-value">0.96</span>
                            </div>
                            <div class="tooltip info-icon">ⓘ
                                <span class="tooltiptext" style="width: 270px; left: auto; right: 0;">
                                    <p><strong>vLa<sub>max</sub> (Maximum Glycolytic Rate):</strong><br>
                                    Represents the maximal rate at which lactate can be produced via glycolysis, expressed in mmol of lactate per liter of distribution volume per second (mmol·l<sup>-1</sup>·s<sup>-1</sup>). It's a key determinant of anaerobic capacity.</p>
                                    <hr style="border-color: #777; margin: 5px 0;">
                                    <p><strong>Net Lactate Production Rate:</strong><br>
                                    This rate (vLa<sub>SS</sub> - vLa<sub>ox</sub>), shown in the plot in mmol·l<sup>-1</sup>·min<sup>-1</sup>, indicates the net balance of lactate formation and removal at steady state for each power output.
                                    A positive value indicates net production (typically above MLSS), while a negative value indicates net clearance. It is equivalent to the negative Pyruvate Deficit (-PD).</p>
                                </span>
                            </div>
                        </div>
                        <input type="range" id="vLamax" class="range-slider" min="0.20" max="1.50" value="0.96" step="0.01">
                        
                        <div class="parameter-row" style="margin-top: 5px; font-size: 0.85em;">
                        <div class="parameter-label">Max. Lactic Power <sub>(metabolic | mechanical @η=25%):</sub></div>
                        <span id="maxLacticPowerTab1" class="slider-value" style="min-width: 100px;">-- W | -- W</span>
                        <div class="tooltip info-icon" style="margin-left: 5px;">ⓘ
                            <span class="tooltiptext" style="width: 270px; left: auto; right: 0;">
                                <p><strong>Maximal Lactic Power Calculation (Theoretical Maximum):</strong></p>
                                <p><strong>Metabolic:</strong><br>
                                `vLa_max (mmol/L/s) * ActiveMuscleWater (L) * 1.5 (ATP/La) * ATP_Yield_fixed (kJ/mol) / 1000 (mmol/mol) * 1000 (W/kW)`</p>
                                <p><strong>Mechanical (@25% eff.):</strong><br>
                                `Metabolic Lactic Power * 0.25`</p>
                                <p>This calculation uses a <strong>fixed high ATP yield (e.g., 65.0 kJ/mol at pH 7.0)</strong> to estimate theoretical maximum power. The main exercise simulation uses a <em>dynamic ATP yield</em> dependent on current intramuscular pH and PCr levels.</p>
                                <p>Assumes glycogen as primary substrate (1.5 ATP per lactate). Active muscle water is estimated as 75% of active muscle mass (calculated from body mass and gender in Tab 1).</p>
                            </span>
                        </div>
                    </div>
                    </div>

    

                  <!-- START: Added HR Sliders for Tab 1 -->
              <div class="slider-container">
                <div class="slider-label">
                    <label for="HR_max">HR<sub>max</sub> (bpm):</label>
                    <span id="HR_max-value" class="slider-value">186</span>
                </div>
                <input type="range" id="HR_max" class="range-slider" min="120" max="230" value="186" step="1">
            </div>

            <div class="slider-container">
                <div class="slider-label">
                    <label for="HR_Base">HR<sub>Base</sub> (bpm):</label>
                    <span id="HR_Base-value" class="slider-value">45</span>
                </div>
                <input type="range" id="HR_Base" class="range-slider" min="30" max="100" value="45" step="1">
            </div>

            <div class="slider-container">
                <div class="slider-label" style="display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <label for="CE_HR">CE<sub>HR</sub> (bpm·W<sup>-1</sup>):</label>
                        <span id="CE_HR-value" style="margin-left: 85px;" class="slider-value">0.31</span>
                    </div>
                    <div class="tooltip info-icon">ⓘ
                        <span class="tooltiptext">Heart Rate Efficiency (CE<sub>HR</sub>) or HR-Power slope describes the increase in heart rate (bpm) for each Watt of power increase. Values can vary, typically ranging from 0.25 to 0.45 bpm/W in cyclists. Lower values may indicate better cardiovascular efficiency.</span>
                    </div>
                </div>
                <input type="range" id="CE_HR" class="range-slider" min="0.20" max="0.50" value="0.31" step="0.01">
            </div>

            <!-- Simplified CE_HR Calculation via P/HR Factor -->
        <div style="margin-top: 10px; padding-top:10px; border-top: 1px solid var(--border-color);">
            <div class="control-label" style="margin-bottom: 10px;">Set via P/HR Efficiency Factor:</div>
            <div class="slider-container">
                <div class="slider-label" style="display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <label for="power_hr_factor_tab1">P/HR Factor (W/bpm):</label>
                        <span id="power_hr_factor_tab1-value" class="slider-value">1.90</span>
                    </div>
                    <div class="tooltip info-icon">ⓘ
                        <span class="tooltiptext" style="width: 270px; text-align: left;">
                            <p><strong>P/HR Efficiency Factor (Power per Heartbeat above Base):</strong><br>
                            This factor represents how many Watts you produce per heartbeat above your resting heart rate (HR<sub>Base</sub>). It's an indicator of aerobic efficiency.</p>
                            <p><strong>Calculation Example:</strong><br>
                            If during a steady endurance effort (e.g., 60 min), your average power is 200W and your average HR is 130 bpm, and your HR<sub>Base</sub> is 45 bpm:<br>
                            P/HR Factor = Power / (Average HR - HR<sub>Base</sub>)<br>
                            P/HR Factor = 200 W / (130 bpm - 45 bpm) = 200 / 85 ≈ 2.35 W/bpm.</p>
                            <p>Values are often tracked on platforms like TrainingPeaks or Intervals.icu (may be termed "Aerobic Efficiency", "Efficiency Factor", or similar, though definitions vary). The app uses this factor and your HR<sub>Base</sub> to estimate the CE<sub>HR</sub> (bpm/W) used in the model.</p>
                        </span>
                    </div>
                </div>
                <input type="range" id="power_hr_factor_tab1" class="range-slider" min="0.5" max="5.0" value="1.90" step="0.01">
            </div>
            <div class="small-text">CE<sub>HR</sub> will be calculated as 1 / (P/HR Factor). Uses HR<sub>Base</sub> from above.</div>
        </div>
                  
                  <div class="checkbox-container">
                      <label class="fancy-checkbox">
                          <input type="checkbox" id="weight_based" name="weight_based">
                          <span class="checkmark"></span>
                          Weight-based values
                      </label>
                  </div>
                  </div>
              
              <div class="control-group">
                  <div class="header-section">
                      <div class="control-label">V̇O<sub>2,Base</sub> Calculation</div>
                      <div class="tooltip info-icon">ⓘ
                          <span class="tooltiptext">Calculation of resting oxygen consumption based on anthropometric data.</span>
                      </div>
                  </div>
                  
                  <div class="radio-group">
                      <div class="control-label">Gender:</div>
                      <div class="radio-option">
                          <input type="radio" id="male" name="gender" value="Male" checked>
                          <label for="male">Male</label>
                      </div>
                      <div class="radio-option">
                          <input type="radio" id="female" name="gender" value="Female">
                          <label for="female">Female</label>
                      </div>
                  </div>
                  
                  <div class="slider-container">
                      <div class="slider-label">
                          <label for="body_mass">Body Mass (kg):</label>
                          <span id="body_mass-value" class="slider-value">92.0</span>
                      </div>
                      <input type="range" id="body_mass" class="range-slider" min="40" max="120" value="92" step="0.1">
                  </div>
                  
                  <div class="slider-container">
                      <div class="slider-label">
                          <label for="age">Age (years):</label>
                          <span id="age-value" class="slider-value">28</span>
                      </div>
                      <input type="range" id="age" class="range-slider" min="18" max="100" value="28" step="1">
                  </div>
                  
                  <div class="slider-container">
                      <div class="slider-label">
                          <label for="height">Height (cm):</label>
                          <span id="height-value" class="slider-value">193</span>
                      </div>
                      <input type="range" id="height" class="range-slider" min="140" max="220" value="193" step="1">
                  </div>
                  
                  <button id="calculate_vo2base" type="button">Calculate V̇O<sub>2</sub>Base</button>
                  
                  <div class="small-text">Uses the Harris-Benedict equation to estimate basal metabolic rate, which is then converted to oxygen consumption.</div>
              </div>
              
              <!-- Substrate utilization section -->
              <div class="control-group">
                  <div class="header-section">
                      <div class="control-label">Substrate Utilization</div>
                      <div class="tooltip info-icon">ⓘ
                          <span class="tooltiptext">Display carbohydrate and fat oxidation rates based on lactate balance calculation. Shows the substrate contribution to total energy production across workloads.</span>
                      </div>
                  </div>
                  
                  <div class="checkbox-container">
                      <label class="fancy-checkbox">
                          <input type="checkbox" id="show_substrate" name="show_substrate">
                          <span class="checkmark"></span>
                          Show Substrate Utilization
                      </label>
                  </div>
                  
                  <div id="substrate-controls" style="display:none;">
                      <div class="dropdown-container">
                          <label for="energy_unit" class="dropdown-label">Energy Unit:</label>
                          <select id="energy_unit" class="dropdown-select">
                              <option value="g/h">g/h</option>
                              <option value="kcal/h">kcal/h</option>
                              <option value="kJ/h">kJ/h</option>
                          </select>
                      </div>
                      
                      <div class="checkbox-container">
                          <label class="fancy-checkbox">
                              <input type="checkbox" id="show_kh_adjust" name="show_kh_adjust">
                              <span class="checkmark"></span>
                              Adjust CHO utilization at rest
                              <div class="tooltip info-icon" style="margin-left: 5px;">ⓘ
                                  <span class="tooltiptext">Allows adjustment of the carbohydrate utilization at rest (default is based purely on the model calculations, but you can adjust to match empirical values. According to Friedlander (1998, 1999) and Brooks (2012), total CHO percentage at rest is approximately 35-40%, at 45% of V̇O<sub>2,peak</sub> about 50-60%, and at 65% of V̇O<sub>2,peak</sub> about 60-70%. It should be noted that empirical measurements tend to show higher fat metabolism and carbohydrate utilization at rest compared to pure model calculations).</span>
                              </div>
                          </label>
                      </div>
                      
                      <div id="kh-adjust-control" style="display:none;">
                          <div class="slider-container">
                              <div class="slider-label">
                                  <label for="rest_kh_percentage">Resting CHO percentage (%):</label>
                                  <span id="rest_kh_percentage-value" class="slider-value">20</span>
                              </div>
                              <input type="range" id="rest_kh_percentage" class="range-slider" min="0" max="100" value="20" step="1">
                          </div>
                      </div>
                      
                      <!-- Swap VO2 and Power axes option removed as per request -->
                  </div>
                  
                <div class="substrate-info" style="display:none;" id="substrate-info">
                    <p>The substrate utilization calculation is based on the metabolic model:</p>
                    <ul style="padding-left: 20px; margin: 5px 0;">
                        <li>Carbohydrate oxidation increases with power, reaching 100% at MLSS</li>
                        <li>Fat oxidation is highest at FAT<sub>max</sub> intensity</li>
                        <li>CHO:Fat ratio is determined by the relationship between lactate production (vLa<sub>ss</sub>) and elimination (vLa<sub>ox</sub>)</li>
                    </ul>
                    <p>The energy equivalents used: 4.1 kcal/g for CHO and 9.45 kcal/g for fat.</p>
                    <p>The predicted Respiratory Quotient (RQ) is calculated from the substrate mix (0.70 for 100% fat, 1.00 for 100% CHO). 
                    The caloric equivalent is determined from RQ using Stegemann's table (1990), which is used for efficiency calculations.</p>
                </div>
              </div>
              
              <div class="control-group">
                  <div class="axis-controls">
                      <div class="card-title">Plot Settings</div>
                      <div>
                          <label class="fancy-checkbox">
                              <input type="checkbox" id="lock_y_axis" name="lock_y_axis" checked>
                              <span class="checkmark"></span>
                              Lock Y-Axis
                          </label>
                      </div>
                      <div>
                          <label class="fancy-checkbox">
                              <input type="checkbox" id="lock_x_axis" name="lock_x_axis" checked>
                              <span class="checkmark"></span>
                              Lock X-Axis
                          </label>
                      </div>
                  </div>
              </div>
          </div>

          <!-- Tab 2: Exercise Simulation Controls -->
          <div class="tab-content" id="belastungssimulation-content">
              <!-- Disclaimer Alert -->
              <div class="disclaimer-alert">
                  <strong><em>Disclaimer:</em> This tab and all calculations are still under development and should be considered experimental only!</strong>
              </div>
              
              <div class="control-group">
                  <div class="header-section">
                      <div class="control-label">Step Test Simulation Parameters</div>
                      <div class="tooltip info-icon">ⓘ
                          <span class="tooltiptext">Parameters for the step test or exercise simulation.</span>
                      </div>
                  </div>
                  
                  <div class="slider-container">
                      <div class="slider-label">
                          <label for="step_watt">Step Increment (Watts):</label>
                          <span id="step_watt-value" class="slider-value">20</span>
                      </div>
                      <input type="range" id="step_watt" class="range-slider" min="1" max="200" value="20" step="1">
                  </div>
                  
                  <div class="slider-container">
                      <div class="slider-label">
                          <label for="step_duration">Step Duration (s):</label>
                          <span id="step_duration-value" class="slider-value">30</span>
                      </div>
                      <input type="range" id="step_duration" class="range-slider" min="1" max="1800" value="30" step="1">
                  </div>
                  
                  <div class="slider-container">
                      <div class="slider-label">
                          <label for="max_power_step">Maximum Power (Watts):</label>
                          <span id="max_power_step-value" class="slider-value">560</span>
                      </div>
                      <input type="range" id="max_power_step" class="range-slider" min="100" max="1000" value="560" step="10">
                  </div>
                  
                  <div class="slider-container">
                      <div class="slider-label">
                          <label for="power_scale">Power Adjustment (%):</label>
                          <span id="power_scale-value" class="slider-value">100</span>
                      </div>
                      <input type="range" id="power_scale" class="range-slider" min="0" max="200" value="100" step="1">
                  </div>
                  
                  <button id="load_interval_example" type="button">Load Example Exercise Data</button>
                  
                  <div class="file-upload" style="margin-top: 20px;">
                    <label for="power_data" class="file-upload-label">Insert workout file</label>
                    <input type="file" id="power_data" accept=".csv,.txt,.xlsx,.xls">
                    <div class="file-upload-info">Supported formats: CSV, TXT, XLSX with time/timestamp, power and cadence data</div>
                    <div id="file-name" class="file-name"></div>
                </div>

                <div class="checkbox-container">
                    <label class="fancy-checkbox">
                        <input type="checkbox" id="has_header" name="has_header" checked>
                        <span class="checkmark"></span>
                        File has headers
                    </label>
                </div>

                <div class="radio-group" style="margin-top: 10px; font-size: 0.95em;">
                    <div class="control-label">Uploaded workout data gap processing:</div>
                    <div class="radio-option">
                      <input type="radio" id="gap_handling_last" name="gap_handling" value="last" checked>
                      <label for="gap_handling_last">Maintain last values</label>
                      <div class="tooltip info-icon" style="margin-left: 5px;">ⓘ
                        <span class="tooltiptext">When processing your uploaded workout file, time gaps will be filled with the last recorded power value. This displays intervals without drops in power visualization, ideal to construct interval training data.</span>
                      </div>
                    </div>
                    <div class="radio-option">
                      <input type="radio" id="gap_handling_zero" name="gap_handling" value="zero"> 
                      <label for="gap_handling_zero">Insert zero values</label>
                      <div class="tooltip info-icon" style="margin-left: 5px;">ⓘ
                        <span class="tooltiptext">When processing your uploaded workout file, all time gaps will be filled with zero power values. This creates clear visual breaks in your power data, suitable for analyzing training sessions with rest periods.</span>
                      </div>
                    </div>
                  </div>
                
                <button id="smooth_power" type="button">Smooth Power Curve (5-point window)</button>

                <div class="control-group">
                    <div class="header-section">
                        <div class="control-label">Display Window Settings</div>
                        <div class="tooltip info-icon">ⓘ
                            <span class="tooltiptext">Adjust the display window for time and Y-Axis values in the plot without affecting the simulation calculations.</span>
                        </div>
                    </div>
                    
                    <div class="axis-control-container">
                        <label class="fancy-checkbox">
                            <input type="checkbox" id="customize_time_window" name="customize_time_window">
                            <span class="checkmark"></span>
                            Adjust X-Axis range
                        </label>
                    </div>
                    
                    <div id="time-window-sliders" style="display:none;">
                        <div class="slider-container">
                            <div class="slider-label">
                                <label for="view_time_start">Start Time (s):</label>
                                <span id="view_time_start-value" class="slider-value">0</span>
                            </div>
                            <input type="range" id="view_time_start" class="range-slider" min="0" max="7200" value="0" step="1">
                        </div>

                              
                    <div class="axis-control-container" id="summary-for-window-container" style="display:none; margin-top:10px;">
                        <label class="fancy-checkbox">
                            <input type="checkbox" id="calculate_summary_for_window" name="calculate_summary_for_window">
                            <span class="checkmark"></span>
                            Calculate summary for selected window
                            <div class="tooltip info-icon" style="margin-left: 5px;">ⓘ
                                <span class="tooltiptext">If checked, the Exercise Summary Statistics will be calculated only for the currently selected X-Axis (time) window.</span>
                            </div>
                        </label>
                    </div>

                        <div class="slider-container">
                            <div class="slider-label">
                                <label for="view_time_end">End Time (s):</label>
                                <span id="view_time_end-value" class="slider-value">3600</span>
                            </div>
                            <input type="range" id="view_time_end" class="range-slider" min="0" max="14400" value="3600" step="1">
                        </div>
                    </div>
                    
                    <div class="axis-control-container">
                        <label class="fancy-checkbox">
                            <input type="checkbox" id="customize_y_axis" name="customize_y_axis">
                            <span class="checkmark"></span>
                            Adjust Y-Axis ranges
                        </label>
                    </div>
                    
                    <div id="y-axis-sliders" style="display:none;">
                        <div class="slider-container">
                            <div class="slider-label">
                                <label for="view_power_max">Power Y-Axis Maximum:</label>
                                <span id="view_power_max-value" class="slider-value">1420</span>
                            </div>
                            <input type="range" id="view_power_max" class="range-slider" min="100" max="2000" value="1420" step="50">
                        </div>
                        
                        <div class="slider-container">
                            <div class="slider-label">
                                <label for="view_vo2_max">V̇O<sub>2</sub> Y-Axis Maximum:</label>
                                <span id="view_vo2_max-value" class="slider-value">6500</span>
                            </div>
                            <input type="range" id="view_vo2_max" class="range-slider" min="1000" max="10000" value="6500" step="500">
                        </div>
                        
                        <div class="slider-container">
                            <div class="slider-label">
                                <label for="view_lactate_min">Lactate Y-Axis Minimum:</label>
                                <span id="view_lactate_min-value" class="slider-value">0</span>
                            </div>
                            <input type="range" id="view_lactate_min" class="range-slider" min="-20" max="5" value="0" step="1">
                        </div>
                        
                        <div class="slider-container">
                            <div class="slider-label">
                                <label for="view_lactate_max">Lactate Y-Axis Maximum:</label>
                                <span id="view_lactate_max-value" class="slider-value">25</span>
                            </div>
                            <input type="range" id="view_lactate_max" class="range-slider" min="5" max="50" value="25" step="1">
                        </div>
                    </div>
                </div>
              </div>

              <div class="control-group">
                <div class="header-section">
                    <div class="control-label">Cadence Dependency</div>
                    <div class="tooltip info-icon">ⓘ
                        <span class="tooltiptext">Incorporate cycling cadence effects for the exercise simulation. This modifies metabolic parameters based on the pedaling rate.</span>
                    </div>
                </div>
                
                <div class="checkbox-container">
                    <label class="fancy-checkbox">
                        <input type="checkbox" id="cadence_dependent_step" name="cadence_dependent_step">
                        <span class="checkmark"></span>
                        Enable U-Shaped Cadence Dependency
                    </label>
                </div>
                
                <div id="cadence-controls-step" style="display:none;">
                    <div class="slider-container">
                        <div class="slider-label">
                            <label for="cadence_step">Fixed Cadence (rpm):</label>
                            <span id="cadence_step-value" class="slider-value">90</span>
                        </div>
                        <input type="range" id="cadence_step" class="range-slider" min="20" max="200" value="90" step="1">
                    </div>
                    
                    <div class="checkbox-container">
                        <label class="fancy-checkbox">
                            <input type="checkbox" id="use_file_cadence" name="use_file_cadence" checked>
                            <span class="checkmark"></span>
                            Use cadence from file (if available)
                            <div class="tooltip info-icon" style="margin-left: 5px;">ⓘ
                                <span class="tooltiptext">If checked and available in the uploaded data, cadence values from the file will be used instead of the fixed value above.</span>
                            </div>
                        </label>
                    </div>
                    
                    <div class="parameter-row">
                        <div class="parameter-label">CE (CEV̇O<sub>2</sub>) Dependency:</div>
                        <div class="tooltip info-icon">ⓘ
                            <span class="tooltiptext">Formula: CEV̇O<sub>2</sub>(rpm) = 0.0004 · rpm² - 0.094 · rpm + 16.857</span>
                        </div>
                        <span class="slider-value">✓</span>
                    </div>
                    
                    <div class="parameter-row">
                        <div class="parameter-label">V̇O<sub>2,Base</sub> Dependency:</div>
                        <div class="tooltip info-icon">ⓘ
                            <span class="tooltiptext">Formula: V̇O<sub>2,Base</sub>(rpm) = 0.172 · rpm² - 14.460 · rpm + 548.039</span>
                        </div>
                        <span class="slider-value">✓</span>
                    </div>
                    
                    <div class="checkbox-container">
                        <label class="fancy-checkbox">
                            <input type="checkbox" id="vo2max_dependent_step" name="vo2max_dependent_step">
                            <span class="checkmark"></span>
                            Include V̇O<sub>2,max</sub> Dependency
                        </label>
                    </div>
                    
                    <div class="checkbox-container">
                        <label class="fancy-checkbox">
                            <input type="checkbox" id="vlamax_dependent_step" name="vlamax_dependent_step">
                            <span class="checkmark"></span>
                            Include vLa<sub>max</sub> Dependency
                        </label>
                    </div>
                </div>
                
                <div class="small-text">Based on the research from Dunst et al. (2025) showing how metabolic parameters vary with cycling cadence.</div>
            </div>
            
            <div class="control-group">
                <div class="header-section">
                    <div class="control-label">Physiological Parameters</div>
                    <div class="tooltip info-icon">ⓘ
                        <span class="tooltiptext">Physiological parameters for the simulation calculation.</span>
                    </div>
                </div>

                    <div class="slider-container">
                        <div class="slider-label" style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <label for="vo2_start">V̇O₂ Start (ml·min<sup>-1</sup>):</label>
                                <span id="vo2_start-value" class="slider-value">--</span>
                            </div>
                            <div class="tooltip info-icon">ⓘ
                                <span class="tooltiptext">Initial V̇O₂ value for the exercise simulation. Constrained between V̇O₂Base and V̇O₂max.</span>
                            </div>
                        </div>
                        <input type="range" id="vo2_start" class="range-slider" min="200" max="7500" value="400" step="1">
                    </div>
                
             <!-- Container for Mono-exponential ON Slider -->
            <div id="monoexponential-on-control">
                <div class="slider-container">
                    <div class="slider-label">
                        <label for="vo2_up_time_constant">V̇O<sub>2,on</sub> time constant (τ<sub>on</sub>) (s):</label>
                        <span id="vo2_up_time_constant-value" class="slider-value">30</span>
                    </div>
                    <input type="range" id="vo2_up_time_constant" class="range-slider" min="6" max="120" value="30" step="1"> <!-- Min value adjusted to 6 -->
                </div>

                <!-- START: Intensity-Dependent Tau_On Checkbox -->
                <div class="checkbox-container" style="margin-top: -5px; margin-bottom: 15px;">
                    <label class="fancy-checkbox">
                        <input type="checkbox" id="dynamic_tau_on" name="dynamic_tau_on" checked="checked">
                        <span class="checkmark"></span>
                        Intensity-Dependent τ<sub>on</sub>
                        <div class="tooltip info-icon" style="margin-left: 5px;">ⓘ
                            <span class="tooltiptext" style="width: 260px; left: auto; right: 0;">
                                <p><strong>Dynamic τ<sub>on</sub>:</strong> Adjusts V̇O₂ uptake time (τ<sub>on</sub>) based on the previous step's intensity.</p>
                                <p><strong>How:</strong> Uses V̇O₂ (% of V̇O₂<sub>max</sub>) from the *immediately preceding* time step.</p>
                                <p><strong>Formula:</strong> Calculates a base τ<sub>on</sub> using:<br>
                                   <code>τ<sub>on_base</sub> = 0.38 * PrevIntensity% + 6</code></p>
                                <p><strong>Slider Role:</strong> When active, slider sets τ<sub>on</sub> for <strong>50%</strong> intensity (default ≈ 25s), shifting the linear τ<sub>on</sub>-intensity relationship.</p>
                                <p><em>Simulates slower V̇O₂ rise after higher intensity starting points.</em></p>
                            </span>
                        </div>
                    </label>
                </div>
                <!-- END: Intensity-Dependent Tau_On Checkbox -->

            </div>

            <!-- Container for Mono-exponential OFF Slider -->
            <div id="monoexponential-off-control">
                <div class="slider-container">
                    <div class="slider-label">
                        <label for="vo2_down_time_constant">V̇O<sub>2,off</sub> time constant (τ<sub>off</sub>) (s):</label>
                        <span id="vo2_down_time_constant-value" class="slider-value">35</span>
                    </div>
                          
<input type="range" id="vo2_down_time_constant" class="range-slider" min="10" max="120" value="35" step="1"> <!-- Min value adjusted to 10 -->
</div>

<!-- START: Intensity-Dependent Tau_Off Checkbox -->
<div class="checkbox-container" style="margin-top: -5px; margin-bottom: 15px;">
    <label class="fancy-checkbox">
        <input type="checkbox" id="dynamic_tau_off" name="dynamic_tau_off">
        <span class="checkmark"></span>
        Intensity-Dependent τ<sub>off</sub>
        <div class="tooltip info-icon" style="margin-left: 5px;">ⓘ
            <span class="tooltiptext" style="width: 260px; left: auto; right: 0;"> <!-- Adjusted width slightly -->
                <p><strong>Dynamic τ<sub>off</sub>:</strong> Adjusts V̇O₂ recovery time (τ<sub>off</sub>) based on recent intensity.</p>
                <p><strong>How:</strong> Finds max V̇O₂ (% of V̇O₂<sub>max</sub>) in the last <strong>2 * previous τ<sub>off</sub></strong> seconds.</p>
                <p><strong>Formula:</strong> Calculates a base τ<sub>off</sub> using:<br>
                   <code>τ<sub>off_base</sub> = 0.45 * Intensity% + 10</code></p>
                <p><strong>Slider Role:</strong> When active, slider sets τ<sub>off</sub> for <strong>50%</strong> intensity (default ≈ 33s), shifting the linear τ<sub>off</sub>-intensity relationship.</p>
                <p><em>Simulates faster recovery after lower intensity, slower after higher intensity.</em></p>
            </span>
        </div>
    </label>
</div>
<!-- END: Intensity-Dependent Tau_Off Checkbox -->

<!-- NEW: VO2 Delay Slider -->


            <div class="slider-container">
                    <div class="slider-label" style="display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <label for="vo2_delay">V̇O₂ Response Delay (s):</label>
                            <span id="vo2_delay-value" class="slider-value">2</span>
                        </div>
                        <div class="tooltip info-icon">ⓘ
                            <span class="tooltiptext">Pure time delay (in seconds) before V̇O₂ starts responding kinetically to a change in intensity. Simulates transport and initial metabolic inertia. Affects V̇O₂ actual, O₂ deficit, vLa<sub>ox</sub>, etc. Default: 2s. Range: 0-10s.</span>
                        </div>
                    </div>
                    <input type="range" id="vo2_delay" class="range-slider" min="0" max="10" value="3" step="1">
                </div>
            </div>
                
                <div class="slider-container">
                    <div class="slider-label">
                        <label for="la_max">Lactate exercise termination value (mmol·l<sup>-1</sup>):</label>
                        <span id="la_max-value" class="slider-value">20.0</span>
                    </div>
                    <input type="range" id="la_max" class="range-slider" min="4" max="30" value="20" step="0.5">
                </div>
                
                <div class="checkbox-container">
                    <label class="fancy-checkbox">
                        <input type="checkbox" id="use_lactate_abort" name="use_lactate_abort">
                        <span class="checkmark"></span>
                        Terminate simulation when lactate exceeds max value
                        <div class="tooltip info-icon" style="margin-left: 5px;">ⓘ
                            <span class="tooltiptext">When checked, the simulation will terminate if blood lactate concentration exceeds the specified maximum value.</span>
                        </div>
                    </label>
                </div>
                
                <div class="slider-container">
                    <div class="slider-label">
                        <label for="la_base">Resting Lactate-value (mmol·l<sup>-1</sup>):</label>
                        <span id="la_base-value" class="slider-value">0.8</span>
                    </div>
                    <input type="range" id="la_base" class="range-slider" min="0.5" max="2" value="0.8" step="0.1">
                </div>

                            <!-- vLass ON Time Constant Slider -->
                            <div class="slider-container">
                                <div class="slider-label" style="display: flex; justify-content: space-between; align-items: center;">
                                    <div>
                                        <label for="vLass_on_tau">vLa<sub>SS,on</sub> Time Constant (τ<sub>vLaSS,on</sub>) (s):</label>
                                        <span id="vLass_on_tau-value" class="slider-value">5</span>
                                    </div>
                                    <div class="tooltip info-icon">ⓘ
                                        <span class="tooltiptext">Time constant for the exponential rise of the lactate production rate (vLa<sub>SS</sub>) during increases in intensity. Represents how quickly vLa<sub>SS</sub> approaches its higher target value. Default: 5s.</span>
                                    </div>
                                </div>
                                <input type="range" id="vLass_on_tau" class="range-slider" min="1" max="60" value="5" step="1">
                            </div>

                            <!-- vLass OFF Time Constant Slider -->
                            <div class="slider-container">
                                <div class="slider-label" style="display: flex; justify-content: space-between; align-items: center;">
                                    <div>
                                        <label for="vLass_off_tau">vLa<sub>SS,off</sub> Time Constant (τ<sub>vLaSS,off</sub>) (s):</label>
                                        <span id="vLass_off_tau-value" class="slider-value">2</span>
                                    </div>
                                    <div class="tooltip info-icon">ⓘ
                                        <span class="tooltiptext">Time constant for the exponential fall of the lactate production rate (vLa<sub>SS</sub>) during decreases in intensity or recovery. Represents how quickly vLa<sub>SS</sub> approaches its lower target value. Default: 2s.</span>
                                    </div>
                                </div>
                                <input type="range" id="vLass_off_tau" class="range-slider" min="1" max="60" value="2" step="1">
                            </div>
                            <!-- vLaSS Delay Slider -->
                            <div class="slider-container">
                                <div class="slider-label" style="display: flex; justify-content: space-between; align-items: center;">
                                    <div>
                                        <label for="vlass_delay">vLa<sub>SS</sub> Response Delay (s):</label>
                                        <span id="vlass_delay-value" class="slider-value">2</span>
                                    </div>
                                    <div class="tooltip info-icon">ⓘ
                                        <span class="tooltiptext">Pure time delay (in seconds) before lactate production rate (vLa<sub>SS</sub>) starts responding kinetically to a change in intensity. Simulates delays in glycolytic pathway activation. Affects calculated lactate dynamics. Default: 2s. Range: 0-10s.</span>
                                    </div>
                                </div>
                                <input type="range" id="vlass_delay" class="range-slider" min="0" max="10" value="2" step="1">
                            </div>

                                  
                        <!-- Optional vLa<sub>SS</sub> Capping Checkbox -->
                        <div class="checkbox-container" style="margin-top: 5px;">
                            <label class="fancy-checkbox">
                                <input type="checkbox" id="cap_vlass_by_o2_deficit" name="cap_vlass_by_o2_deficit" checked="checked">
                                <span class="checkmark"></span>
                                Cap vLa<sub>SS</sub> by V̇O₂ Deficit
                                <div class="tooltip info-icon" style="margin-left: 5px;">ⓘ
                                    <span class="tooltiptext" style="width: 270px; left: auto; right: 0;">
                                        <p><strong>Optional Cap on vLa<sub>SS</sub>:</strong></p>
                                        <p>If checked, the actual lactate production rate (vLa<sub>SS</sub>) will be capped.</p>
                                        <p><strong>Mechanism:</strong> It prevents the *net* anaerobic energy supply (from lactate production minus lactate oxidation) from exceeding the current calculated oxygen deficit (V̇O₂ Demand - V̇O₂ Actual).</p>
                                        <p><strong>Purpose:</strong> Aims for higher physiological plausibility by preventing unrealistic "overshooting" of anaerobic energy production when aerobic supply is still increasing or limited.</p>
                                        <p><strong>Default: Off.</strong> The simulation uses the kinetically determined vLa<sub>SS</sub> without this energy-demand cap.</p>
                                    </span>
                                </div>
                            </label>
                        </div>

                        <div class="checkbox-container" style="margin-top: 5px;">
                            <label class="fancy-checkbox">
                                <input type="checkbox" id="boost_vlass_by_deficit" name="boost_vlass_by_deficit" checked="checked">
                                <span class="checkmark"></span>
                                Boost vLa<sub>SS</sub> by V̇O₂ Deficit
                                <div class="tooltip info-icon" style="margin-left: 5px;">ⓘ
                                    <span class="tooltiptext" style="width: 270px; left: auto; right: 0;">
                                        <p><strong>Optional vLa<sub>SS</sub> Boost:</strong></p>
                                        <p>If checked, the target lactate production rate (vLa<sub>SS</sub>) will be additionally increased based on the current V̇O₂ deficit (V̇O₂ Demand - V̇O₂ Actual).</p>
                                        <p><strong>Mechanism:</strong> A fraction (controlled by the boost factor) of the energy equivalent of the O2 deficit is converted to an additional target vLa<sub>SS</sub>.</p>
                                        <p><strong>Purpose:</strong> Simulates a more aggressive glycolytic response when aerobic supply significantly lags behind demand.</p>
                                        <p><strong>Default: Off.</strong></p>
                                    </span>
                                </div>
                            </label>
                        </div>

                        <div id="vlass_boost_factor_control" class="slider-container" style="display:none; margin-left: 20px;">
                            <div class="slider-label">
                                <label for="vlass_boost_factor">vLa<sub>SS</sub> Deficit Boost Factor:</label>
                                <span id="vlass_boost_factor-value" class="slider-value">0.30</span>
                            </div>
                            <input type="range" id="vlass_boost_factor" class="range-slider" min="0" max="1.0" value="0.30" step="0.05">
                        </div>

                            <div style="margin-top: 15px; padding-top: 10px; border-top: 1px solid var(--border-color);">
                                <div class="header-section" style="margin-bottom: 5px;">
                                    <div class="parameter-label" style="flex-grow: 1;">Muscle pH (pH<sub>m</sub>) Simulation</div>
                                    <div class="tooltip info-icon" style="margin-left: 5px;">ⓘ
                                        <span class="tooltiptext" style="width: 270px; left: auto; right: 0;"> <!-- Tooltip nach links öffnen -->
                                            <p><strong>Muscle pH (pH<sub>m</sub>) & Glycolysis Simulation (Tab 2):</strong></p>
                                            <p>pH<sub>m</sub> is calculated based on Mader (2003) / Heck & Bartmus (2022, Ch. 4), using estimated [Pi] (from PCr), [La]<sub>m</sub> (from La<sub>Accumulation</sub>), and pCO₂ (from %V̇O₂max).</p>
                                            <p> The calculated pH<sub>m</sub> of the previous step is used to regulate the effective maximal lactate production rate (vLa<sub>max,eff</sub>) for the current step, simulating pH inhibition of PFK (phosphofructokinase):</p>
                                            <p style="font-family: monospace; font-size: 0.85em; margin-left: 10px;">vLa<sub>max,eff</sub> = vLa<sub>max,base</sub> * PFK_Activity_Factor(pH<sub>m</sub>)</p>
                                            <p>This pH-modulated vLa<sub>max,eff</sub> then determines the target lactate production rate (vLa<sub>ss</sub>).</p>
                                            <p><i>Ref: Heck, H., & Bartmus, U. (2022). Laktat (p. 59, 85). Springer.</i></p>
                                            <p><i>Note: Uses approximations.</i></p>
                                        </span>
                                    </div>
                                </div>
                            </div>
            </div>
            
            <!-- Glycogen Storage Parameters Section -->
            <div class="control-group">
                <div class="header-section">
                    <div class="control-label">Glycogen Storage Parameters</div>
                    <div class="tooltip info-icon">ⓘ
                        <span class="tooltiptext">Parameters for simulating muscle glycogen storage dynamics during exercise and carbohydrate intake.</span>
                    </div>
                </div>
                
                <!-- Added auto-calculate button for glycogen values based on muscle mass -->
                <div class="checkbox-container">
                    <label class="fancy-checkbox">
                        <input type="checkbox" id="auto_glycogen" name="auto_glycogen">
                        <span class="checkmark"></span>
                        Auto-calculate glycogen values based on muscle mass
                        <div class="tooltip info-icon" style="margin-left: 5px;">ⓘ
                            <span class="tooltiptext">Calculate glycogen-store values based on active muscle mass.</span>
                        </div>
                    </label>
                </div>
                
                <div class="slider-container">
                    <div class="slider-label">
                        <label for="glycogen_init">Initial Glycogen Storage (g):</label>
                        <span id="glycogen_init-value" class="slider-value">350</span>
                    </div>
                    <input type="range" id="glycogen_init" class="range-slider" min="0" max="800" value="350" step="10">
                </div>
                
                <div class="slider-container">
                    <div class="slider-label">
                        <label for="glycogen_max">Maximum Glycogen Storage (g):</label>
                        <span id="glycogen_max-value" class="slider-value">350</span>
                    </div>
                    <input type="range" id="glycogen_max" class="range-slider" min="100" max="800" value="350" step="10">
                </div>
                
                <div class="slider-container">
                    <div class="slider-label">
                        <label for="carb_intake_rate">Carbohydrate Intake Rate (g·h<sup>-1</sup>):</label>
                        <span id="carb_intake_rate-value" class="slider-value">0</span>
                    </div>
                    <input type="range" id="carb_intake_rate" class="range-slider" min="0" max="150" value="0" step="5">
                </div>
                
                <div class="substrate-info">
                    <p>Glycogen storage model assumptions:</p>
                    <ul style="padding-left: 20px; margin: 5px 0;">
                        <li>Carbohydrate utilization increases with intensity and reaches 100% at and above MLSS</li>
                        <li>Glycogen depletion rate is calculated from actual CHO oxidation rate</li>
                        <li>A typical well-loaded muscle glycogen storage is 350-500g for a trained cyclist</li>
                        <li>Maximum carbohydrate intake and utilization is typically 60-90g/h (with appropriate training)</li>
                    </ul>
                </div>
            </div>
            
            <div class="control-group">
                <div class="header-section">
                    <div class="control-label">W' Balance Parameters</div>
                    <div class="tooltip info-icon">ⓘ
                        <span class="tooltiptext">Parameters for the W' balance model calculation.</span>
                    </div>
                </div>
                
                
                <div class="slider-container">
                    <div class="slider-label">
                        <label for="critical_power">Critical Power (CP) (W):</label>
                        <span id="critical_power-value" class="slider-value">365</span>
                    </div>
                    <input type="range" id="critical_power" class="range-slider" min="100" max="500" value="365" step="1">
                </div>
                
                <div class="slider-container">
                    <div class="slider-label">
                        <label for="w_prime">W' (kJ):</label>
                        <span id="w_prime-value" class="slider-value">25.0</span>
                    </div>
                    <input type="range" id="w_prime" class="range-slider" min="5" max="40" value="20" step="0.5">
                </div>

                <div class="slider-container">
                    <div class="label-info-value-line" style="display: flex; align-items: center;">
                        <div class="slider-label" style="margin-right: 5px;">
                            <label for="pmax">P<sub>max</sub> (W):</label>
                        </div>
                        <div class="tooltip info-icon" style="margin-right: 5px;">ⓘ
                            <span class="tooltiptext">Maximum instantaneous power an athlete can produce, representing the third parameter in the 3-parameter critical power model. This represents the capacity of the alactic (PCr/immediate) energy system.</span>
                        </div>
                        <span id="pmax-value" class="slider-value">1400</span>
                    </div>
                    <input type="range" id="pmax" class="range-slider" min="400" max="2000" value="1400" step="20">
                </div>
                
                <div class="checkbox-container">
                    <label class="fancy-checkbox">
                        <input type="checkbox" id="use_mlss_as_cp" name="use_mlss_as_cp" checked="checked">
                        <span class="checkmark"></span>
                        Use MLSS from Tab 1 as CP
                        <div class="tooltip info-icon" style="margin-left: 5px;">ⓘ
                            <span class="tooltiptext">When checked, Critical Power will automatically update to match the MLSS value from Tab 1.</span>
                        </div>
                    </label>
                </div>
                
                <div class="slider-container">
                    <div class="slider-label">
                        <label for="w_prime_balance_min">W' Balance Minimum (kJ):</label>
                        <span id="w_prime_balance_min-value" class="slider-value">-20.0</span>
                    </div>
                    <input type="range" id="w_prime_balance_min" class="range-slider" min="-20" max="10" value="0" step="0.5">
                </div>
                
                <div class="checkbox-container">
                    <label class="fancy-checkbox">
                        <input type="checkbox" id="use_w_prime_balance_abort" name="use_w_prime_balance_abort">
                        <span class="checkmark"></span>
                        Abort simulation when W' Balance falls below slider minimum
                        <div class="tooltip info-icon" style="margin-left: 5px;">ⓘ
                            <span class="tooltiptext">When checked, the simulation will terminate if W' Balance falls below the specified minimum.</span>
                        </div>
                    </label>
                </div>

                W' Balance model (Skiba et al. 2015):
            <div class="model-info">
                <p><b>Depletion (P > CP):</b><br>
                   W'<sub>BAL</sub>(t) = W'<sub>BAL</sub>(u) - (P - CP) · (t-u)</p>
                <p><b>Recovery (P < CP):</b><br>
                   W'<sub>BAL</sub>(t) = W'<sub>0</sub> - (W'<sub>0</sub> - W'<sub>BAL</sub>(u)) · e<sup>-(DCP/W'<sub>0</sub>) · (t-u)</sup></p>
                <p>Where W'<sub>0</sub> is initial W' (J), DCP = CP - P<sub>recovery</sub> (W).</p>
            </div>

                MAP & Strain Score (SS) model :
                <div class="tooltip info-icon" style="margin-left: 5px;">ⓘ
                    <span class="tooltiptext">Maximum instantaneous power an athlete can produce, representing the third parameter in the 3-parameter critical power model. Based on Kontro et al. (2025), this is used to calculate MPA (Maximum Power Available) and the Strain Score (SS), which are novel metrics for fatigue quantification. P<sub>max</sub> represents the capacity of the alactic (PCr/immediate) energy system.</span>
                </div>
                <div class="model-info">
                    <p>SS = Σ(SR) · (P<sub>max</sub>/CP²) · (100/3600)</p>
                    <p>SR = k<sub>strain</sub> · P</p>
                    <p></p>k<sub>strain</sub> = (P<sub>max</sub> - MPA + CP)/(P<sub>max</sub> - P + CP)</p>
                    <p>MPA = P<sub>max</sub> - (P<sub>max</sub> - CP) · (W'<sub>EXP</sub>/W')²</p>
                </div>
            </div>
            
            <div class="control-group">
                  <div class="header-section">
                      <div class="control-label">PCr and O<sub>2</sub> Deficit Model</div>
                      <div class="tooltip info-icon">ⓘ
                          <span class="tooltiptext">Simulation of PCr dynamics and O<sub>2</sub> deficit based on mismatch between O<sub>2</sub> demand and actual O<sub>2</sub> uptake.</span>
                      </div>
                  </div>
                  
                  <div id="pcr-model-controls">
                  <div class="slider-container">
                      <div class="slider-label" style="display: flex; justify-content: space-between; align-items: center;">
                          <div>
                              <label for="pcr_init">Resting PCr (mmol·kg<sup>-1</sup>):</label>
                              <span id="pcr_init-value" style="margin-left: 23px;" class="slider-value">24.0</span>
                          </div>
                          <div class="tooltip info-icon">ⓘ
                              <span class="tooltiptext">Initial phosphocreatine (PCr) concentration in active muscle tissue. Typical values range from 15-38 mmol·kg<sup>-1</sup> of muscle wet weight.</span>
                          </div>
                      </div>
                      <input type="range" id="pcr_init" class="range-slider" min="15" max="38" value="25" step="0.1">
                  </div>
              
                  <div class="slider-container">
                      <div class="slider-label" style="display: flex; justify-content: space-between; align-items: center;">
                          <div>
                              <label for="p_o_ratio">P/O<sub>2</sub> (mol ATP · mol O<sub>2</sub><sup>-1</sup>):</label>
                              <span id="p_o_ratio-value" style="margin-left: 10px;" class="slider-value">4.80</span>
                          </div>
                          <div class="tooltip info-icon">ⓘ
                              <span class="tooltiptext">P/O<sub>2</sub> Ratio represents the amount of ATP molecules generated per oxygen molecule consumed. Value depends on substrate mixture (4.61 for purely fat, 5.0 for purely carbohydrate metabolism).</span>
                          </div>
                      </div>
                      <input type="range" id="p_o_ratio" class="range-slider" min="4.61" max="5.0" value="4.80" step="0.01">
                  </div>
                  
                  <div class="slider-container">
                      <div class="slider-label" style="display: flex; justify-content: space-between; align-items: center;">
                          <div>
                              <label for="active_muscle_mass">Active Muscle Mass (kg):</label>
                              <span id="active_muscle_mass-value" style="margin-left: 19px;" class="slider-value">25.0</span>
                          </div>
                          <div class="tooltip info-icon">ⓘ
                              <span class="tooltiptext">
                                  <strong>Research-based recommendations:</strong><br>
                                  • For cyclists, active muscle mass depends on gender, body weight, and position:<br>
                                  <br>
                                  <u>Women</u>:<br>
                                  - Seated cycling: ~22% of body weight (0.34 × 0.65)<br>
                                  - Standing cycling: ~25.5% of body weight (0.34 × 0.75)<br>
                                  <br>
                                  <u>Men</u>:<br>
                                  - Seated cycling: ~27% of body weight (0.42 × 0.65)<br>
                                  - Standing cycling: ~31.5% of body weight (0.42 × 0.75)<br>
                                  <br>
                                  Based on Janssen et al. (2000) MRI data and exercise physiology research on cycling biomechanics.
                              </span>
                          </div>
                      </div>
                      <input type="range" id="active_muscle_mass" class="range-slider" min="5" max="40" value="25" step="0.5">
                  </div>

                  <div class="parameter-row" style="margin-top: 10px;">
                    <div class="parameter-label">O<sub>2</sub>-Lactate Equiv. (β):</div>
                    <div class="tooltip info-icon" style="margin-left: 5px;">ⓘ
                        <span class="tooltiptext">Oxygen equivalent of lactate accumulation in blood (β). Represents the amount of O₂ (ml/kg) required aerobically to produce the energy equivalent to accumulating 1 mM of lactate in the blood. Value ≈ 3.0 ml O₂·kg⁻¹·mM⁻¹. Used here to estimate the O₂ deficit covered by net lactate production. (di Prampero, P. E. (1981). Energetics of muscular exercise. *Rev Physiol Biochem Pharmacol*, 89, 143-222. See Sect. 6.4).</span>
                    </div>
                    <span class="slider-value">≈ 3.0 ml·kg⁻¹·mM⁻¹</span>
                  </div>
                  
                  <div class="checkbox-container">
                      <label class="fancy-checkbox">
                          <input type="checkbox" id="show_vo2_demand" name="show_vo2_demand" checked="checked">
                          <span class="checkmark"></span>
                          Show V̇O<sub>2</sub> Demand Curve
                          <div class="tooltip info-icon" style="margin-left: 5px;">ⓘ
                              <span class="tooltiptext">Shows the actual V̇O<sub>2</sub> demand for each power output as a dotted line, with the area between actual V̇O<sub>2</sub> and demand filled to visualize O<sub>2</sub> deficit.</span>
                          </div>
                      </label>
                  </div>
                  
                  <div class="eta-infobox">
                      <p>The PCr model calculates phosphocreatine dynamics based on O<sub>2</sub> deficit/surplus:</p>
                      <p class="formula">PCr<sub>Store</sub>(t) = PCr<sub>Initial</sub> - ∫<sub>0</sub><sup>t</sup>(O<sub>2</sub>Deficit × P/O<sub>2</sub> Ratio)</p>
                      <p>Accumulated O<sub>2</sub> deficit represents the mismatch between O<sub>2</sub> demand and uptake.</p>
                   </div>
                </div>
            </div>
            
            <div class="control-group">
              <div class="header-section">
                  <div class="control-label">Model Parameters</div>
                  <div class="tooltip info-icon">ⓘ
                      <span class="tooltiptext">Parameters for the metabolic model of the simulation.</span>
                  </div>
              </div>
              
              <div class="checkbox-container">
                  <label class="fancy-checkbox">
                      <input type="checkbox" id="use_tab1_params" name="use_tab1_params" checked="checked">
                      <span class="checkmark"></span>
                      Use model parameters from Tab 1
                  </label>
              </div>
              
              <!-- Individual parameters if not imported -->
              <div id="individual-params" style="display:block;">
                  <div class="checkbox-container">
                      <label class="fancy-checkbox">
                          <input type="checkbox" id="curvilinear_step" name="curvilinear_step">
                          <span class="checkmark"></span>
                          Curvilinear CE relationship
                          <div class="tooltip info-icon" style="margin-left: 5px;">ⓘ
                              <span class="tooltiptext">Based on the curvilinear relationship between power output and energy consumption.</span>
                          </div>
                      </label>
                  </div>
                  
                  <div id="linear-ce-control-step" class="slider-container">
                      <div class="slider-label">
                          <label for="CEVO2_step">CE (ml·min<sup>-1</sup>·W<sup>-1</sup>):</label>
                          <span id="CEVO2_step-value" class="slider-value">10.9</span>
                      </div>
                      <input type="range" id="CEVO2_step" class="range-slider" min="8" max="15" value="11" step="0.1">
                  </div>
                  
                  <div id="curvilinear-ce-control-step" class="slider-container" style="display:none;">
                      <div class="slider-label">
                          <label for="CE_range_start_step">CE<sub>Start</sub> (ml·min<sup>-1</sup>·W<sup>-1</sup>):</label>
                          <span id="CE_range_start_step-value" class="slider-value">10.9</span>
                      </div>
                      <input type="range" id="CE_range_start_step" class="range-slider" min="8" max="15" value="11" step="0.1">
                      
                      <div class="slider-label">
                          <label for="CE_range_end_step">CE<sub>Target</sub> (ml·min<sup>-1</sup>·W<sup>-1</sup>):</label>
                          <span id="CE_range_end_step-value" class="slider-value">12.5</span>
                      </div>
                      <input type="range" id="CE_range_end_step" class="range-slider" min="8" max="15" value="12" step="0.1">
                  </div>
                  
                  <div class="slider-container">
                      <div class="slider-label">
                          <label for="VO2max_step">V̇O<sub>2,max</sub> (ml·min<sup>-1</sup>):</label>
                          <span id="VO2max_step-value" class="slider-value">6450</span>
                      </div>
                      <input type="range" id="VO2max_step" class="range-slider" min="2000" max="7500" value="6450" step="10">
                  </div>
                  
                  <div class="slider-container">
                      <div class="slider-label">
                          <label for="VO2Base_step">V̇O<sub>2,Base</sub> (ml·min<sup>-1</sup>):</label>
                          <span id="VO2Base_step-value" class="slider-value">394</span>
                      </div>
                      <input type="range" id="VO2Base_step" class="range-slider" min="200" max="800" value="394" step="1">
                  </div>
                  
                  <div class="slider-container">
                      <div class="slider-label">
                          <label for="vLamax_step">vLa<sub>max</sub> (mmol·l<sup>-1</sup>·s<sup>-1</sup>):</label>
                          <span id="vLamax_step-value" class="slider-value">0.96</span>
                      </div>
                      <input type="range" id="vLamax_step" class="range-slider" min="0.20" max="1.50" value="0.96" step="0.01">
                        <div class="parameter-row" style="margin-top: 5px; font-size: 0.85em;">
                            <div class="parameter-label">Max. Lactic Power <sub>(metabolic | mechanical @η=25%):</div>
                            <span id="maxLacticPowerTab2" class="slider-value" style="min-width: 100px;">-- W | -- W</span>
                            <div class="tooltip info-icon" style="margin-left: 5px;">ⓘ
                                <span class="tooltiptext" style="width: 270px; left: auto; right: 0;">
                                <p><strong>Maximal Lactic Power Calculation (Theoretical Maximum):</strong></p>
                                <p><strong>Metabolic:</strong><br>
                                `vLa_max (mmol/L/s) * ActiveMuscleWater (L) * 1.5 (ATP/La) * ATP_Yield_fixed (kJ/mol) / 1000 (mmol/mol) * 1000 (W/kW)`</p>
                                <p><strong>Mechanical (@25% eff.):</strong><br>
                                `Metabolic Lactic Power * 0.25`</p>
                                <p>This calculation uses a <strong>fixed high ATP yield (e.g., 65.0 kJ/mol at pH 7.0)</strong> to estimate theoretical maximum power. The main exercise simulation uses a <em>dynamic ATP yield</em> dependent on current intramuscular pH and PCr levels.</p>
                                <p>Assumes glycogen as primary substrate (1.5 ATP per lactate). Active muscle water is estimated as 75% of active muscle mass (calculated from body mass and gender in Tab 1).</p>
                            </span>
                            </div>
                    </div>
                  </div>
                  
                  <div class="slider-container">
                      <div class="slider-label">
                          <label for="body_mass_step">Body Mass (kg):</label>
                          <span id="body_mass_step-value" class="slider-value">92.0</span>
                      </div>
                      <input type="range" id="body_mass_step" class="range-slider" min="40" max="120" value="92" step="0.1">
                  </div>

                  <!-- Added HR Sliders for Tab 2 -->
                    <div class="slider-container">
                        <div class="slider-label">
                            <label for="HR_max_step">HR<sub>max</sub> (bpm):</label>
                            <span id="HR_max_step-value" class="slider-value">186</span>
                        </div>
                        <input type="range" id="HR_max_step" class="range-slider" min="120" max="230" value="186" step="1">
                    </div>

                    <div class="slider-container">
                        <div class="slider-label">
                            <label for="HR_Base_step">HR<sub>Base</sub> (bpm):</label>
                            <span id="HR_Base_step-value" class="slider-value">45</span>
                        </div>
                        <input type="range" id="HR_Base_step" class="range-slider" min="30" max="100" value="45" step="1">
                    </div>

                    <div class="slider-container">
                        <div class="slider-label" style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <label for="CE_HR_step">CE<sub>HR</sub> (bpm·W<sup>-1</sup>):</label>
                                <span id="CE_HR_step-value" class="slider-value">0.31</span>
                            </div>
                            <div class="tooltip info-icon">ⓘ
                                <span class="tooltiptext">Heart Rate Efficiency (CE<sub>HR</sub>) or HR-Power slope describes the increase in heart rate (bpm) for each Watt of power increase. Values can vary, typically ranging from 0.25 to 0.45 bpm/W in cyclists. Lower values may indicate better cardiovascular efficiency.</span>
                            </div>
                        </div>
                        <input type="range" id="CE_HR_step" class="range-slider" min="0.20" max="0.50" value="0.31" step="0.01">
                    </div>
              </div>
              </div>
        </div>
    </div>
    
    <div class="main-content">
        <div id="leistungsdiagramm-tab" class="tab-content active">
            <div id="plot-container"></div>
            <div id="substrate-plot-container"></div>
            <div id="values-container"></div>
        </div>
        
        <div id="belastungssimulation-tab" class="tab-content">
            <div id="steptest-plot-container"></div>
        
                        <div id="exercise-summary" class="values-container exercise-summary">
                <h3>Exercise Summary Statistics</h3>
                <div class="summary-content">
                    <div class="summary-row" style="margin-top: 10px;"><span class="summary-label">Average mechanical Power:</span> <span id="avg-power" class="summary-value">--</span></div>
                    <div class="summary-row"><span class="summary-label">Normalized mechanical Power:</span> <span id="norm-power" class="summary-value">--</span></div>
                    <div class="summary-row"><span class="summary-label" style="color: darkgrey;">Total mechanical Work:</span> <span id="total-work" class="summary-value" style="color: darkgrey;">--</span></div>
                     <div class="summary-row" style="margin-left: 10px;"><span class="summary-label" style="color: #42BA97;">• Mechanical Work > CP:</span> <span id="work-above-cp" class="summary-value" style="color: #42BA97;">--</span></div>
                                        <div class="summary-row"><span class="summary-label" style="color: #1CADE4;">Total Aerobic Energy Expenditure (gross):</span> <span id="total-energy" class="summary-value" style="color: #1CADE4;">--</span></div>
                    <div class="summary-row"><span class="summary-label" style="color: rgb(117, 117, 117);">Total metabolic Work:</span> <span id="total-metabolic-work" class="summary-value" style="color: rgb(117, 117, 117);">--</span></div>

                    <div class="summary-row" style="margin-left: 10px; margin-top: 10px;">
                        <span class="summary-label" style="color: #2683C6;">• Aerobic contribution:</span>
                        <span id="aerobic-contribution" class="summary-value" style="color: #2683C6;">-- kJ | --%</span>
                    </div>
                    <div class="summary-row" style="margin-left: 10px;">
                        <span class="summary-label" style="color: #F4737A;">• Anaerobic-lactic contribution:</span>
                        <span id="lactic-contribution" class="summary-value" style="color: #F4737A;">-- kJ | --%</span>
                    </div>
                    <div class="summary-row" style="margin-left: 10px;">
                        <span class="summary-label" style="color: #FFEB3B;">• Anaerobic-alactic contribution:</span>
                        <span id="alactic-contribution" class="summary-value" style="color: #FFEB3B;">-- kJ | --%</span>
                    </div>

                    <div style="margin-top: 0px;">
                        <h4 style="font-size: 1em; color: var(--dark-color); margin-bottom: 8px; text-align: left;">Net Substrate & Metabolite Utilization/Changes:</h4>
                    </div>

                    <div class="summary-row" style="margin-left: 10px;">
                        <span class="summary-label" style="color: #2683C6;">• Total Net Oxygen Utilized:</span>
                        <span id="net-oxygen-utilized" class="summary-value" style="color: #2683C6;">-- L</span>
                    </div>
                    <div class="summary-row" style="margin-left: 10px;">
                        <span class="summary-label" style="color: #F4737A;">• Total Net Lactate Accumulated (muscle):</span>
                        <span id="net-lactate-accumulated-muscle" class="summary-value" style="color: #F4737A;">-- mmol·l<sup>-1</sup></span>
                    </div>
                    <div class="summary-row" style="margin-left: 10px;">
                        <span class="summary-label" style="color: #FFEB3B;">• Total Net PCr Utilized (muscle):</span>
                        <span id="net-pcr-utilized-muscle" class="summary-value" style="color: #FFEB3B;">-- mmol·kg<sup>-1</sup></span>
                    </div>

                    <div style="margin-top: 0px;">
                        <h4 style="font-size: 1em; color: var(--dark-color); margin-bottom: 8px; text-align: left;">Efficiency Metrics:</h4>
                    </div>

                    <div class="summary-row" style="display: flex; align-items: center; margin-left: 10px;">
                        <span class="summary-label">• η<sub>gross</sub></span> <span class="summary-formula" style="font-size:0.9em; color: #555; margin-left: 5px;">$ (\frac{W_{mech}}{W_{Aerob,gross}}) $:</span>
                        <span id="eta-gross" class="summary-value" style="margin-left: auto;">--%</span>
                    </div>
                    <div class="summary-row" style="display: flex; align-items: center; margin-left: 10px;">
                        <span class="summary-label">• η<sub>net</sub>:</span> <span class="summary-formula" style="font-size:0.9em; color: #555; margin-left: 5px;">$ (\frac{W_{mech}}{W_{Aerob,net}}) $:</span>
                        <span id="eta-net" class="summary-value" style="margin-left: auto;">--%</span>
                    </div>
                    <div class="summary-row" style="display: flex; align-items: center; margin-left: 10px;">
                        <span class="summary-label">• η<sub>total</sub>:</span> <span class="summary-formula" style="font-size:0.9em; color: #555; margin-left: 5px;">$ (\frac{W_{mech}}{W_{Aerob,net} + W_{Anaerob,laktazid} +W_{Anaerob,alaktazid}}) $:</span>
                        <span id="eta-total" class="summary-value" style="margin-left: auto;">--%</span>
                    </div>

                    <div style="margin-top: 0px;">
                        <h4 style="font-size: 1em; color: var(--dark-color); margin-bottom: 8px; text-align: left;">Macronutrient Fuel Utilization:</h4>
                    </div>

                    <div class="summary-row" style="margin-left: 10px;">
                        <span class="summary-label" style="color: #D81B60;">• Total Carbohydrate Utilization:</span> <span id="cho-utilization" class="summary-value" style="color: #D81B60;">--</span>
                    </div>
                    <div class="summary-row" style="margin-left: 10px;">
                        <span class="summary-label" style="color: #009688;">• Total Fat Utilization:</span> <span id="fat-utilization" class="summary-value" style="color: #009688;">--</span>
                    </div>

                    <div class="summary-row";>
                        <span class="summary-label" style="color: #F06292;">Strain Score (SS):</span> <span id="total-ss" class="summary-value" style="color: #F06292;">--</span>
                    </div>
                    <div class="summary-row" style="margin-left: 10px;">
                        <span class="summary-label" style="color: #42BA97;">• SS<sub>CP</sub>:</span> <span id="ss-cp" class="summary-value" style="color: #42BA97;">--</span>
                    </div>
                    <div class="summary-row" style="margin-left: 10px;">
                        <span class="summary-label" style="color: #EF5350;">• SS<sub>W'</sub>:</span> <span id="ss-wprime" class="summary-value" style="color: #EF5350;">--</span>
                    </div>
                    <div class="summary-row" style="margin-left: 10px;">
                        <span class="summary-label" style="color: #607D8B;">• SS<sub>Pmax</sub>:</span> <span id="ss-pmax" class="summary-value" style="color: #607D8B;">--</span>
                    </div>
                    
                    <div class="summary-row" style="display: flex; align-items: center;"><span class="summary-label">Training Stress Score (TSS):</span> <span class="summary-formula" style="font-size:0.9em; color: #555; margin-left: 5px;"></span> <span id="tss-value" class="summary-value" style="margin-left: auto;">--</span> </div>
                    
                </div>
            </div>
        </div>

    
</div>

<div id="notification" class="notification"></div>
</body>
</html>

<script>
    // App state management
    // Global Anchor Points for Dynamic ATP Yield (-ΔG_ATP,cyt in kJ/mol)
    // Based on Mader (2003), Eur J Appl Physiol, 88:317–338, Fig. 1 and Heck & Bartmus (2022), Laktat, Abb. 4.2 / 4.4
    // Lower pH generally leads to higher magnitude of -ΔG_ATP,cyt.
    const PH_REF_VERY_HIGH = 7.4; // More alkaline
    const PH_REF_OPTIMAL  = 7.0;  // Reference/Optimal
    const PH_REF_ACIDIC   = 6.0;  // More acidic 

    // Yields at pH 7.4 (Mader Fig 1: lowest curves)
    const ATP_YIELD_MAX_pH74 = 58.0; // High PCr/Rest
    const ATP_YIELD_MIN_pH74 = 46.0; // Low PCr/Fatigue

    // Yields at pH 7.0 (Mader Fig 1: middle curves)
    const ATP_YIELD_MAX_pH70 = 62.0; // High PCr/Rest
    const ATP_YIELD_MIN_pH70 = 48.0; // Low PCr/Fatigue

    const ATP_YIELD_MAX_pH60 = 68.0; // High PCr/Rest
    const ATP_YIELD_MIN_pH60 = 53.0; // Low PCr/Fatigue

    const ATP_PER_LACTATE_FROM_GLYCOGEN = 1.5;

    const appState = {
        // Tab 1 Parameters
        traceVisibility: {}, 
        CEVO2: 10.9,
        CE_range: [10.0, 12.5],
        VO2max: 6450,           
        VO2max_kg: 70.80,       
        VO2Base: 394,
        vLamax: 0.96,   
        HR_max: 186,
        HR_Base: 45, // Default value from your HTML
        CE_HR: 0.31,  // Default value from your HTML        
        body_mass: 92.0,        
        gender: 'Male',
        age: 29,                
        height: 193,
        curvilinear: false,
        weight_based: false,
        lock_y_axis: true,
        lock_x_axis: true,
        calculated_vo2base: null,
        w_prime_balance_min: -20.0,
        use_w_prime_balance_abort: false,
        use_lactate_abort: false, 
        // View window state
        view_time_start: 0,
        view_time_end: 3600,
        customize_time_window: false,
        customize_y_axis: false,
        calculateSummaryForWindow: false,
        view_power_max: 1420,
        view_vo2_max: 6500,
        view_lactate_min: 0,
        view_lactate_max: 25,
        vLass_on_tau: 5,  // Default ON time constant for vLass
        vLass_off_tau: 2, // Default OFF time constant for vLass
        mlss_value: null, 
        // Substrate utilization parameters 
        show_substrate: false,
        energy_unit: "g/h",
        rest_kh_percentage: 20,
        show_kh_adjust: false,
        swap_axes: false, // Still in state but not shown in UI
        // Cadence Dependency Tab 1
        cadence_dependent: false,
        cadence: 80,
        vo2max_dependent: false,
        vlamax_dependent: false,
        // Tab 2 Parameters
        step_watt: 20,
        step_duration: 30,
        max_power_step: 560, 
        // V̇O₂ Kinetics Model
        vo2_start: 400, // Initial default, will be updated
        vo2_at_fatmax: null, // To store the calculated default
        vo2_up_time_constant: 30,
        dynamic_tau_on: true,
        vo2_down_time_constant: 35,
        dynamic_tau_off: false,
        vo2_delay: 3,       // Default VO2 delay in seconds
        vlass_delay: 2,      // Default vLaSS delay in seconds
        cap_vlass_by_o2_deficit: true, // NEW: Default to off
        boost_vlass_by_deficit: true,
        vlass_boost_factor: 0.30, // Default boost factor (e.g., 10% of deficit energy converted to vLass target)
        la_max: 20,
        la_base: 0.8,
        smooth_power: false,
        has_header: true,
        separator: ';',
        gap_handling: 'last', // Default: last values for intervals
        use_tab1_params: true,
        CEVO2_step: 10.9,
        curvilinear_step: false,
        CE_range_step: [10.0, 12.5],
        VO2max_step: 6450,      
        VO2Base_step: 394,
        vLamax_step: 0.96, 
        HR_max_step: 186,
        HR_Base_step: 45,
        CE_HR_step: 0.31,     
        body_mass_step:92.0,   
        critical_power: 365,
        w_prime: 25.0,
        pmax: 1420, // Maximum power for 3-parameter CP model
        use_mlss_as_cp: true,
        power_scale: 100, // Standardwert 100%
        pcr_init: 24.0,
        p_o_ratio: 4.80,
        active_muscle_mass: 25.0,
        show_vo2_demand: true,
        
        // New auto-calculate glycogen values
        auto_glycogen: false,
        
        // Glycogen storage parameters
        glycogen_init: 350,
        glycogen_max: 350,
        carb_intake_rate: 0,
        
        // Cadence Dependency Tab 2
        cadence_dependent_step: false,
        cadence_step: 80,
        vo2max_dependent_step: false,
        vlamax_dependent_step: false,
        use_file_cadence: false,
        
        // Interval Data
        interval_data: null,
        power_data: null,

        // Speichert den Sichtbarkeitsstatus für jeden Trace
        traceVisibility: {}, 

        // Cache for MLSS
        mlss_value: null
        };
        
        // DOM elements for Tab 1
                const elements = {
            // Tab Navigation
            tabs: document.querySelectorAll('.tab'),
            tabContents: document.querySelectorAll('.tab-content'),
            tabContentLeistungsdiagramm: document.getElementById('leistungsdiagramm-content'),
            tabContentBelastungssimulation: document.getElementById('belastungssimulation-content'),
            leistungsdiagrammTab: document.getElementById('leistungsdiagramm-tab'),
            belastungssimulationTab: document.getElementById('belastungssimulation-tab'),

            // Tab 1 Elements
            CEVO2: document.getElementById('CEVO2'),
            CEVO2Value: document.getElementById('CEVO2-value'),
            CE_range_start: document.getElementById('CE_range_start'),
            CE_range_startValue: document.getElementById('CE_range_start-value'),
            CE_range_end: document.getElementById('CE_range_end'),
            CE_range_endValue: document.getElementById('CE_range_end-value'),
            VO2max: document.getElementById('VO2max'),
            VO2maxValue: document.getElementById('VO2max-value'),
            VO2max_kg: document.getElementById('VO2max_kg'),
            VO2max_kgValue: document.getElementById('VO2max_kg-value'),
            VO2Base: document.getElementById('VO2Base'),
            VO2BaseValue: document.getElementById('VO2Base-value'),
            vLamax: document.getElementById('vLamax'),
            vLamaxValue: document.getElementById('vLamax-value'),
            HR_max: document.getElementById('HR_max'),
            HR_maxValue: document.getElementById('HR_max-value'),
            HR_Base: document.getElementById('HR_Base'),
            HR_BaseValue: document.getElementById('HR_Base-value'),
            CE_HR: document.getElementById('CE_HR'),
            CE_HRValue: document.getElementById('CE_HR-value'),
            power_hr_factor_tab1: document.getElementById('power_hr_factor_tab1'), // Hinzugefügt
            power_hr_factor_tab1Value: document.getElementById('power_hr_factor_tab1-value'), // Hinzugefügt
            body_mass: document.getElementById('body_mass'),
            body_massValue: document.getElementById('body_mass-value'),
            age: document.getElementById('age'),
            ageValue: document.getElementById('age-value'),
            height: document.getElementById('height'),
            heightValue: document.getElementById('height-value'),
            male: document.getElementById('male'),
            female: document.getElementById('female'),
            curvilinear: document.getElementById('curvilinear'),
            weight_based: document.getElementById('weight_based'),
            lock_y_axis: document.getElementById('lock_y_axis'),
            lock_x_axis: document.getElementById('lock_x_axis'),
            calculate_vo2base: document.getElementById('calculate_vo2base'),
            linearCeControl: document.getElementById('linear-ce-control'),
            curvilinearCeControl: document.getElementById('curvilinear-ce-control'),
            plotContainer: document.getElementById('plot-container'),
            valuesContainer: document.getElementById('values-container'),
            maxLacticPowerTab1: document.getElementById('maxLacticPowerTab1'), // Hinzugefügt

            // Substrate Utilization Elements
            show_substrate: document.getElementById('show_substrate'),
            energy_unit: document.getElementById('energy_unit'),
            show_kh_adjust: document.getElementById('show_kh_adjust'),
            rest_kh_percentage: document.getElementById('rest_kh_percentage'),
            rest_kh_percentageValue: document.getElementById('rest_kh_percentage-value'),
            kh_adjust_control: document.getElementById('kh-adjust-control'),
            substrate_plot_container: document.getElementById('substrate-plot-container'),
            substrate_info: document.getElementById('substrate-info'),
            substrate_controls: document.getElementById('substrate-controls'),

            // Cadence Dependency Tab 1
            cadence_dependent: document.getElementById('cadence_dependent'),
            cadence: document.getElementById('cadence'),
            cadenceValue: document.getElementById('cadence-value'),
            cadenceControls: document.getElementById('cadence-controls'),
            vo2max_dependent: document.getElementById('vo2max_dependent'),
            vlamax_dependent: document.getElementById('vlamax_dependent'),

            // Tab 2 Elements
            step_watt: document.getElementById('step_watt'),
            step_wattValue: document.getElementById('step_watt-value'),
            step_duration: document.getElementById('step_duration'),
            step_durationValue: document.getElementById('step_duration-value'),
            max_power_step: document.getElementById('max_power_step'),
            max_power_stepValue: document.getElementById('max_power_step-value'),
            vo2_up_time_constant: document.getElementById('vo2_up_time_constant'),
            vo2_up_time_constantValue: document.getElementById('vo2_up_time_constant-value'),
            dynamic_tau_on: document.getElementById('dynamic_tau_on'),
            vo2_down_time_constant: document.getElementById('vo2_down_time_constant'),
            vo2_down_time_constantValue: document.getElementById('vo2_down_time_constant-value'),
            dynamic_tau_off: document.getElementById('dynamic_tau_off'),
            monoexponentialOnControl: document.getElementById('monoexponential-on-control'),
            monoexponentialOffControl: document.getElementById('monoexponential-off-control'),
            vo2_start: document.getElementById('vo2_start'),
            vo2_startValue: document.getElementById('vo2_start-value'),
            la_max: document.getElementById('la_max'),
            la_maxValue: document.getElementById('la_max-value'),
            la_base: document.getElementById('la_base'),
            la_baseValue: document.getElementById('la_base-value'),
            critical_power: document.getElementById('critical_power'),
            critical_powerValue: document.getElementById('critical_power-value'),
            w_prime: document.getElementById('w_prime'),
            w_primeValue: document.getElementById('w_prime-value'),
            w_prime_balance_min: document.getElementById('w_prime_balance_min'),
            w_prime_balance_minValue: document.getElementById('w_prime_balance_min-value'),
            pmax: document.getElementById('pmax'),
            pmaxValue: document.getElementById('pmax-value'),
            use_w_prime_balance_abort: document.getElementById('use_w_prime_balance_abort'),
            use_lactate_abort: document.getElementById('use_lactate_abort'),
            use_mlss_as_cp: document.getElementById('use_mlss_as_cp'),
            load_interval_example: document.getElementById('load_interval_example'),
            power_data: document.getElementById('power_data'),
            fileName: document.getElementById('file-name'),
            has_header: document.getElementById('has_header'),
            gap_handling_last: document.getElementById('gap_handling_last'),
            gap_handling_zero: document.getElementById('gap_handling_zero'),
            smooth_power: document.getElementById('smooth_power'),
            use_tab1_params: document.getElementById('use_tab1_params'),
            individual_params: document.getElementById('individual-params'),
            CEVO2_step: document.getElementById('CEVO2_step'),
            CEVO2_stepValue: document.getElementById('CEVO2_step-value'),
            curvilinear_step: document.getElementById('curvilinear_step'),
            linearCeControlStep: document.getElementById('linear-ce-control-step'),
            curvilinearCeControlStep: document.getElementById('curvilinear-ce-control-step'),
            CE_range_start_step: document.getElementById('CE_range_start_step'),
            CE_range_start_stepValue: document.getElementById('CE_range_start_step-value'),
            CE_range_end_step: document.getElementById('CE_range_end_step'),
            CE_range_end_stepValue: document.getElementById('CE_range_end_step-value'),
            VO2max_step: document.getElementById('VO2max_step'),
            VO2max_stepValue: document.getElementById('VO2max_step-value'),
            VO2Base_step: document.getElementById('VO2Base_step'),
            VO2Base_stepValue: document.getElementById('VO2Base_step-value'),
            vLamax_step: document.getElementById('vLamax_step'),
            vLamax_stepValue: document.getElementById('vLamax_step-value'),
            maxLacticPowerTab2: document.getElementById('maxLacticPowerTab2'), // Hinzugefügt
            HR_max_step: document.getElementById('HR_max_step'),
            HR_max_stepValue: document.getElementById('HR_max_step-value'),
            HR_Base_step: document.getElementById('HR_Base_step'),
            HR_Base_stepValue: document.getElementById('HR_Base_step-value'),
            CE_HR_step: document.getElementById('CE_HR_step'),
            CE_HR_stepValue: document.getElementById('CE_HR_step-value'),
            vLass_on_tau: document.getElementById('vLass_on_tau'),
            vLass_on_tauValue: document.getElementById('vLass_on_tau-value'),
            vLass_off_tau: document.getElementById('vLass_off_tau'),
            vLass_off_tauValue: document.getElementById('vLass_off_tau-value'),
            vo2_delay: document.getElementById('vo2_delay'),
            vo2_delayValue: document.getElementById('vo2_delay-value'),
            vlass_delay: document.getElementById('vlass_delay'),
            vlass_delayValue: document.getElementById('vlass_delay-value'),
            cap_vlass_by_o2_deficit: document.getElementById('cap_vlass_by_o2_deficit'),
            boost_vlass_by_deficit: document.getElementById('boost_vlass_by_deficit'),
            vlass_boost_factor_control: document.getElementById('vlass_boost_factor_control'),
            vlass_boost_factor: document.getElementById('vlass_boost_factor'),
            vlass_boost_factorValue: document.getElementById('vlass_boost_factor-value'),
            body_mass_step: document.getElementById('body_mass_step'),
            body_mass_stepValue: document.getElementById('body_mass_step-value'),
            steptestPlotContainer: document.getElementById('steptest-plot-container'),
            power_scale: document.getElementById('power_scale'),
            power_scaleValue: document.getElementById('power_scale-value'),

            // New auto-calculate glycogen element
            auto_glycogen: document.getElementById('auto_glycogen'),

            // Glycogen Storage Elements
            glycogen_init: document.getElementById('glycogen_init'),
            glycogen_initValue: document.getElementById('glycogen_init-value'),
            glycogen_max: document.getElementById('glycogen_max'),
            glycogen_maxValue: document.getElementById('glycogen_max-value'),
            carb_intake_rate: document.getElementById('carb_intake_rate'),
            carb_intake_rateValue: document.getElementById('carb_intake_rate-value'),

            // PCr Model Controls
            pcr_model_controls: document.getElementById('pcr-model-controls'),
            pcr_init: document.getElementById('pcr_init'),
            pcr_initValue: document.getElementById('pcr_init-value'),
            p_o_ratio: document.getElementById('p_o_ratio'),
            p_o_ratioValue: document.getElementById('p_o_ratio-value'),
            active_muscle_mass: document.getElementById('active_muscle_mass'),
            active_muscle_massValue: document.getElementById('active_muscle_mass-value'),
            show_vo2_demand: document.getElementById('show_vo2_demand'),

            // Cadence Dependency Tab 2
            cadence_dependent_step: document.getElementById('cadence_dependent_step'),
            cadence_step: document.getElementById('cadence_step'),
            cadence_stepValue: document.getElementById('cadence_step-value'),
            cadenceControlsStep: document.getElementById('cadence-controls-step'),
            vo2max_dependent_step: document.getElementById('vo2max_dependent_step'),
            vlamax_dependent_step: document.getElementById('vlamax_dependent_step'),
            use_file_cadence: document.getElementById('use_file_cadence'),

            /// Exercise Summary Statistics
            avg_power: document.getElementById('avg-power'),
            norm_power: document.getElementById('norm-power'),
            total_work: document.getElementById('total-work'),
            work_above_cp: document.getElementById('work-above-cp'),
            total_energy: document.getElementById('total-energy'),
            cho_utilization: document.getElementById('cho-utilization'),
            fat_utilization: document.getElementById('fat-utilization'),
            tss_value: document.getElementById('tss-value'),
            total_ss: document.getElementById('total-ss'),
            ss_cp: document.getElementById('ss-cp'),
            ss_wprime: document.getElementById('ss-wprime'),
            ss_pmax: document.getElementById('ss-pmax'),
            total_metabolic_work: document.getElementById('total-metabolic-work'),
            aerobic_contribution: document.getElementById('aerobic-contribution'),
            lactic_contribution: document.getElementById('lactic-contribution'),
            alactic_contribution: document.getElementById('alactic-contribution'),
            // Neue/Geänderte Elemente für spezifische Anzeigen
            net_oxygen_utilized: document.getElementById('net-oxygen-utilized'),
            net_lactate_accumulated_muscle: document.getElementById('net-lactate-accumulated-muscle'), // ID geändert
            net_pcr_utilized_muscle: document.getElementById('net-pcr-utilized-muscle'),
            eta_gross: document.getElementById('eta-gross'),
            eta_net: document.getElementById('eta-net'),
            eta_total: document.getElementById('eta-total'),

            // Notification
            notification: document.getElementById('notification'),

            // View window settings
            view_time_start: document.getElementById('view_time_start'),
            view_time_startValue: document.getElementById('view_time_start-value'),
            view_time_end: document.getElementById('view_time_end'),
            view_time_endValue: document.getElementById('view_time_end-value'),
            customize_time_window: document.getElementById('customize_time_window'),
            time_window_sliders: document.getElementById('time-window-sliders'),
            customize_y_axis: document.getElementById('customize_y_axis'),
            y_axis_sliders: document.getElementById('y-axis-sliders'),
            view_power_max: document.getElementById('view_power_max'),
            view_power_maxValue: document.getElementById('view_power_max-value'),
            view_vo2_max: document.getElementById('view_vo2_max'),
            view_vo2_maxValue: document.getElementById('view_vo2_max-value'),
            view_lactate_min: document.getElementById('view_lactate_min'),
            view_lactate_minValue: document.getElementById('view_lactate_min-value'),
            view_lactate_max: document.getElementById('view_lactate_max'),
            view_lactate_maxValue: document.getElementById('view_lactate_max-value'),
            summary_for_window_container: document.getElementById('summary-for-window-container'),
            calculate_summary_for_window: document.getElementById('calculate_summary_for_window')
        };
    
    // Tab switching logic
    elements.tabs.forEach(tab => {
        tab.addEventListener('click', () => {
            const tabName = tab.getAttribute('data-tab');
            
            // Deactivate all tabs and contents
            elements.tabs.forEach(t => t.classList.remove('active'));
            elements.tabContents.forEach(c => c.classList.remove('active'));
            document.getElementById('leistungsdiagramm-tab').classList.remove('active');
            document.getElementById('belastungssimulation-tab').classList.remove('active');
            
            // Activate selected tab and content
            tab.classList.add('active');
            document.getElementById(`${tabName}-content`).classList.add('active');
            document.getElementById(`${tabName}-tab`).classList.add('active');
            
            // If switching to belastungssimulation tab, update step test plot
            if (tabName === 'belastungssimulation') {
                // Check if CP should be set to MLSS
                if (appState.use_mlss_as_cp && appState.mlss_value) {
                    appState.critical_power = appState.mlss_value;
                    elements.critical_power.value = appState.critical_power;
                    elements.critical_powerValue.textContent = appState.critical_power;
                }
                updateStepTestPlot();
            } else {
                updatePlot();
                if (appState.show_substrate) {
                    updateSubstratePlot();
                }
            }
        calculateAndUpdateMaxLacticPower();
        });
    });
    
    // Function to calculate basal metabolic rate (BMR)
    function calculateBMR(gender, mass, height, age) {
        if (gender === 'Male') {
            return 66.5 + (13.75 * mass) + (5.003 * height) - (6.775 * age);
        } else {
            return 655.1 + (9.563 * mass) + (1.850 * height) - (4.676 * age);
        }
    }
    
    // Function to calculate VO2Base from BMR
    function calculateVO2Base(kcalDay, gender) {
        const ka = 19.946;
        const factor = gender === 'Male' ? 1.287 : 1.278;
        return (kcalDay / (24 * 60 * ka)) * 4.1868 * factor * 1000;
    }
    
    // Function to find optimal 'a' coefficient for curvilinear relationship
    function findOptimalA(startCE, targetCE, VO2max, VO2Base) {
        // Objective function to minimize: find 'a' that makes the slope at the VO2max intersection equal targetCE
        const objective = function(a) {
            const b = startCE;
            const c = VO2Base - VO2max;
            const discriminant = b*b - 4*a*c;
            if (discriminant < 0) return 1e6;
            const xIntersect = (-b + Math.sqrt(discriminant))/(2*a);
            if (xIntersect <= 0) return 1e6;
            const slopeAtIntersection = 2*a*xIntersect + startCE;
            return Math.pow(slopeAtIntersection - targetCE, 2);
        };
        
        // Simple optimization algorithm
        let aMin = 0.001;
        let aMax = 0.1;
        let iterations = 100;
        let step = (aMax - aMin) / iterations;
        let bestA = aMin;
        let bestError = objective(aMin);
        
        for (let i = 1; i <= iterations; i++) {
            const a = aMin + i * step;
            const error = objective(a);
            if (error < bestError) {
                bestError = error;
                bestA = a;
            }
        }
        
        return bestA;
    }
    
    // Function to smooth data with a rolling window
    function smoothData(data, windowSize) {
        if (!Array.isArray(data) || data.length < windowSize) {
            return data;
        }
        
        const result = [];
        
        for (let i = 0; i < data.length; i++) {
            let sum = 0;
            let count = 0;
            
            for (let j = Math.max(0, i - Math.floor(windowSize/2)); 
                 j <= Math.min(data.length - 1, i + Math.floor(windowSize/2)); 
                 j++) {
                sum += data[j];
                count++;
            }
            
            result.push(sum / count);
        }
        
        return result;
    }
    
    // Cadence-dependent functions from Dunst et al. paper
    function calculateCadenceDependentCEVO2(cadence) {
        // Formula from paper: CEVȮ2(PR) = 0.0004 * PR² - 0.094 * PR + 16.857
        return 0.0004 * Math.pow(cadence, 2) - 0.094 * cadence + 16.857;
    }
    
    function calculateCadenceDependentVO2Base(cadence) {
        // Formula from paper: VȮ2Base(PR) = 0.172 * PR² - 14.460 * PR + 548.039
        return 0.172 * Math.pow(cadence, 2) - 14.460 * cadence + 548.039;
    }
    
    function calculateCadenceDependentVLamax(cadence) {
        // Formula from paper: vLamax(PR) = -0.0002 * PR² + 0.00931 * PR
        return -0.0002 * Math.pow(cadence, 2) + 0.00931 * cadence;
    }
    
    function calculateCadenceDependentVO2max(cadence, baseVO2max) {
        // Implementation based on a quadratic approach with peak at 90 rpm
        const peakCadence = 90;     // Maximum at 90 rpm
        const zeroCadence = 210;    // At 210 rpm VO2 = 0
        const zeroRatio = 0.1;      // At 0 rpm VO2 is 10% of maximum
        
        if (cadence >= peakCadence) {
            // Right side of parabola: Maximum at peakCadence, zero at zeroCadence
            return Math.max(0, baseVO2max * (1 - Math.pow((cadence - peakCadence) / (zeroCadence - peakCadence), 2)));
        } else {
            // Left side: Maximum at peakCadence, 10% at 0 rpm
            // Using quadratic function: f(x) = ax² + bx + c
                    
            const a = baseVO2max * (zeroRatio - 1) / Math.pow(peakCadence, 2);
            const b = -2 * a * peakCadence;
            const c = baseVO2max + a * Math.pow(peakCadence, 2);
            
            return Math.max(0, a * Math.pow(cadence, 2) + b * cadence + c);
        }
    }
    
    // Function to adjust carbohydrate percentage with rest percentage
    function adjustCarbPercentageWithRestValue(carbPercentage, restKhPercentage) {
        if (!appState.show_kh_adjust) return carbPercentage;
        
        // Determine the initial value at x=0 (at rest)
        const initialCarb0 = carbPercentage[0];
        
        // Ensure the target value is not less than the current minimum
        const targetRestPercentage = Math.max(restKhPercentage, Math.min(...carbPercentage));
        
        // If the target value is already the current value, no change needed
        if (targetRestPercentage === initialCarb0) return carbPercentage;
        
        // Calculate the range (possible adjustment range)
        const rangeUp = 100 - initialCarb0;
        
        // Calculate the percentage adjustment upward
        const percentageAdjustment = (targetRestPercentage - initialCarb0) / rangeUp;
        
        // Calculate new values with percentage increase based on available range
        const adjustedValues = [];
        for (let i = 0; i < carbPercentage.length; i++) {
            const currentValue = carbPercentage[i];
            const availableRange = 100 - currentValue;
            const adjustment = percentageAdjustment * availableRange;
            adjustedValues.push(Math.min(100, currentValue + adjustment));
        }
        
        return adjustedValues;
    }
    
    // New function to calculate glycogen storage values based on active muscle mass
    function calculateGlycogenValues() {
        // Scientific constants for glycogen storage (in g/kg of muscle tissue)
        const glycogenPerKgMuscle = {
            normal: 15, // Normal levels in g/kg 
            loaded: 20,  // Carb-loaded levels in g/kg
            max: 25      // Maximum theoretical levels in g/kg
        };
        
        let muscleMass;
        
        // Use active_muscle_mass if PCr model is enabled, otherwise estimate from body mass
        if (appState.show_pcr_model) {
            muscleMass = appState.active_muscle_mass;
        } else {
            // Estimate active muscle mass based on gender and body mass
            // Research suggests ~27% for men and ~22% for women during seated cycling
            const musclePercentage = appState.gender === 'Male' ? 0.27 : 0.22;
            muscleMass = appState.body_mass * musclePercentage;
        }
        
        // Calculate values
        const initialGlycogen = Math.round(muscleMass * glycogenPerKgMuscle.normal);
        const maxGlycogen = Math.round(muscleMass * glycogenPerKgMuscle.loaded);
        
        return {
            initialGlycogen,
            maxGlycogen
        };
    }
    
    // Main function to calculate metabolic values for Tab 1
    function calculateValues() {
    // Apply cadence dependency if enabled
    let effectiveCEVO2 = appState.CEVO2;
    let effectiveVO2Base = appState.VO2Base;
    let effectiveVLamax = appState.vLamax;
    let effectiveVO2max = appState.VO2max;
    let effectiveHR_max = appState.HR_max;
    let effectiveHR_Base = appState.HR_Base;
    let effectiveCE_HR = appState.CE_HR;
        
        // Apply cadence dependency if enabled
        if (appState.cadence_dependent) {
            // CE and VO2Base dependency are always applied when cadence dependency is enabled
            effectiveCEVO2 = calculateCadenceDependentCEVO2(appState.cadence);
            effectiveVO2Base = calculateCadenceDependentVO2Base(appState.cadence);
            
        // Optional vLamax dependency
        if (appState.vlamax_dependent) {
            effectiveVLamax = calculateCadenceDependentVLamax(appState.cadence);
        }
            
            // Optional VO2max dependency
            if (appState.vo2max_dependent) {
                effectiveVO2max = calculateCadenceDependentVO2max(appState.cadence, appState.VO2max);
            }
        }
        
        // Metabolic model constants
        const CELaO2 = 0.02049 / appState.body_mass;
        const beta_O2_lactate_equiv = 3.0; // ml O2 / kg Körpermasse / mM 
        const VolLa = 0.4;
        const ks1 = 0.0635;
        const ks2 = Math.pow(1.1, 3);
        
        // Calculate max power with linear CE value
        const maxPower = appState.curvilinear ?
            ((effectiveVO2max - effectiveVO2Base) / appState.CE_range[0]) * 1.7 :
            ((effectiveVO2max - effectiveVO2Base) / effectiveCEVO2) * 1.7;

        const P = Array.from({length: Math.ceil(maxPower) + 1}, (_, i) => i);

        let VO2ss_unlimited;
        let aOpt = null;
        
        if (appState.curvilinear) {
            // Calculate optimal coefficient for curvilinear relationship
            aOpt = findOptimalA(appState.CE_range[0], appState.CE_range[1], effectiveVO2max, effectiveVO2Base);
            
            // Curvilinear VO2ss calculation
            VO2ss_unlimited = P.map(p => aOpt * p * p + appState.CE_range[0] * p + effectiveVO2Base);
        } else {
            // Linear VO2ss calculation
            VO2ss_unlimited = P.map(p => effectiveCEVO2 * p + effectiveVO2Base);
        }
        
        // Find where VO2ss crosses VO2max
        const crossIndices = VO2ss_unlimited.findIndex(v => v >= effectiveVO2max);
        const crossPoint = crossIndices !== -1 ? crossIndices : VO2ss_unlimited.length;
        const VO2ss = VO2ss_unlimited.map(v => Math.min(v, effectiveVO2max));

        // Calculate HR_ss
        const HR_ss_unlimited = P.map(p => effectiveCE_HR * p + effectiveHR_Base);
        const HR_ss = HR_ss_unlimited.map(hr => Math.min(hr, effectiveHR_max)); 
        
        // Calculate vLass
        const vLass = VO2ss.map(vo2 => 
            effectiveVLamax / (1 + ks2 * Math.pow((effectiveVO2max - vo2)/(ks1 * vo2), 3/2))
        );
        
        // Calculate vLaox
        const vLaox = VO2ss_unlimited.map(vo2 => (CELaO2 * vo2) / (VolLa * 60));
        
        // Calculate pyruvate deficit
        const PD = vLaox.map((ox, i) => ox - vLass[i]);
        
        // Convert to minutes for display
        const vLass_min = vLass.map(v => v * 60);
        const vLaox_min = vLaox.map(v => v * 60);
        const PD_min = PD.map(p => p * 60);
        
        // Calculate Net Lactate Production Rate (vLass_min - vLaox_min)
        const netLactateProductionRate_min = PD_min.map(pd_val => Math.max(0, -pd_val)); 
        
        // Find important points
        const pdMaxPos = P[PD_min.indexOf(Math.max(...PD_min))];
        
        // Find closest to zero (MLSS)
        let minAbsPD = Infinity;
        let pdZeroPos = 0;
        for (let i = 0; i < PD_min.length; i++) {
            const absPD = Math.abs(PD_min[i]);
            if (absPD < minAbsPD) {
                minAbsPD = absPD;
                pdZeroPos = P[i];
            }
        }
        
        // Store previous MLSS value
        const oldMlssValue = appState.mlss_value;
        // Update MLSS value
        appState.mlss_value = pdZeroPos;
        
        // If MLSS value has changed and use_mlss_as_cp is active,
        // update CP value immediately whether in Tab 1 or Tab 2
        if (oldMlssValue !== pdZeroPos) {
            if (appState.use_mlss_as_cp) {
                // Update CP to match new MLSS value
                appState.critical_power = pdZeroPos;
                if (elements.critical_power) {
                    elements.critical_power.value = pdZeroPos;
                    elements.critical_powerValue.textContent = pdZeroPos;
                    elements.critical_power.disabled = true;
                }
            }
        }
        
        // Calculate substrate utilization if feature is enabled
        let carbPercentage = [];
        let fatPercentage = [];
        let carbGramPerHour = [];
        let fatGramPerHour = [];
        let carbKcalPerHour = [];
        let fatKcalPerHour = [];
        let carbKjPerHour = [];
        let fatKjPerHour = [];
        let totalEnergyKcalPerHour = [];
        let predictedRQ = []; // Added for RQ calculation
        
        if (appState.show_substrate) {
            // Constants for energy equivalents
            const kcalPerO2L = 4.86;
            const kcalPerGramCarb = 4.1;
            const kcalPerGramFat = 9.45;
            const kjPerKcal = 4.184;
            
            // Convert VO2 (ml/min) to L/min and then to kcal/h
            const VO2L_min = VO2ss.map(vo2 => vo2 / 1000);
            const totalKcalMin = VO2L_min.map(vo2 => vo2 * kcalPerO2L);
            totalEnergyKcalPerHour = totalKcalMin.map(kcal => kcal * 60);
            
            // Calculate carbohydrate oxidation based on lactate production vs oxidation
            carbPercentage = new Array(P.length);
            for (let i = 0; i < P.length; i++) {
                if (vLaox_min[i] <= 0) {
                    // If no lactate oxidation occurs
                    carbPercentage[i] = 0;
                } else if (PD_min[i] <= 0) {
                    // At or above the crossing point (MLSS): 100% CHO
                    carbPercentage[i] = 100;
                } else {
                    // Below the crossing point: percentage based on vLass to vLaox ratio
                    carbPercentage[i] = Math.min(100, (vLass_min[i] / vLaox_min[i]) * 100);
                }
            }
            
            // Apply adjustments if rest CHO percentage adjustment is enabled
            if (appState.show_kh_adjust) {
                carbPercentage = adjustCarbPercentageWithRestValue(carbPercentage, appState.rest_kh_percentage);
            }
            
            fatPercentage = carbPercentage.map(cp => 100 - cp);

            // Calculate predicted RQ based on substrate mix
            predictedRQ = carbPercentage.map(cp => calculateRQ(cp));
            
            // Calculate absolute substrate oxidation rates
            const carbKcalMin = totalKcalMin.map((kcal, i) => kcal * (carbPercentage[i] / 100));
            const fatKcalMin = totalKcalMin.map((kcal, i) => kcal * (fatPercentage[i] / 100));
            
            carbKcalPerHour = carbKcalMin.map(kcal => kcal * 60);
            fatKcalPerHour = fatKcalMin.map(kcal => kcal * 60);
            
            carbKjPerHour = carbKcalPerHour.map(kcal => kcal * kjPerKcal);
            fatKjPerHour = fatKcalPerHour.map(kcal => kcal * kjPerKcal);
            
            const carbGramMin = carbKcalMin.map(kcal => kcal / kcalPerGramCarb);
            const fatGramMin = fatKcalMin.map(kcal => kcal / kcalPerGramFat);
            
            carbGramPerHour = carbGramMin.map(g => g * 60);
            fatGramPerHour = fatGramMin.map(g => g * 60);
        }
        
        return {
            P,
            VO2ss,
            VO2ss_unlimited,
            HR_ss, // This will be the array of HR values capped by HR_max
            HR_ss_unlimited, // Optional: if you want to show the extrapolated line
            crossPoint,
            vLass_min,
            vLaox_min,
            PD_min,
            netLactateProductionRate_min, // Renamed and recalculated
            pd_max_pos: pdMaxPos,
            pd_zero_pos: pdZeroPos,
            max_power: maxPower,
            a_opt: aOpt,
            effective_values: {
                CEVO2: effectiveCEVO2,
                VO2Base: effectiveVO2Base,
                vLamax: effectiveVLamax,
                VO2max: effectiveVO2max,
                HR_max: effectiveHR_max,
                HR_Base: effectiveHR_Base,
                CE_HR: effectiveCE_HR
            },
            // Substrate data
            carb_percentage: carbPercentage,
            fat_percentage: fatPercentage,
            carb_g_h: carbGramPerHour,
            fat_g_h: fatGramPerHour,
            carb_kcal_h: carbKcalPerHour,
            fat_kcal_h: fatKcalPerHour,
            carb_kj_h: carbKjPerHour,
            fat_kj_h: fatKjPerHour,
            total_energy_kcal_h: totalEnergyKcalPerHour,
            predicted_rq: predictedRQ 
        };
    }
    
    // Function to update the plot in Tab 1
    function updatePlot() {
        const vals = calculateValues();

        // Define units for hover text consistently
        const displayPowerUnitHover = appState.weight_based ? "W·kg<sup>-1</sup>" : "W";
        const displayVO2UnitHover = appState.weight_based ? "ml·min<sup>-1</sup>·kg<sup>-1</sup>" : "ml·min<sup>-1</sup>";
        const lactateRateUnitHover = "mmol·l<sup>-1</sup>·min<sup>-1</sup>";
        const lactateConcUnitHover = "mmol·l<sup>-1</sup>";
        const hrUnitHover = "bpm"; // For actual HR in hover


        const relVO2max = vals.effective_values.VO2max / appState.body_mass;
        const relPower = vals.P.map(p => p / appState.body_mass);
        const relVO2ss = vals.VO2ss.map(vo2 => vo2 / appState.body_mass);
        const relVO2ss_unlimited = vals.VO2ss_unlimited.map(vo2 => vo2 / appState.body_mass);
        const relPdMaxPos = vals.pd_max_pos / appState.body_mass;
        const relPdZeroPos = vals.pd_zero_pos / appState.body_mass;

        const displayPower = appState.weight_based ? relPower : vals.P;
        const displayVO2ss = appState.weight_based ? relVO2ss : vals.VO2ss;
        const displayVO2ss_unlimited = appState.weight_based ? relVO2ss_unlimited : vals.VO2ss_unlimited;
        const displayVO2max = appState.weight_based ? relVO2max : vals.effective_values.VO2max;
        const displayHR_ss_scaled = vals.HR_ss.map(hr => hr / 10);
        const displayPdMaxPos = appState.weight_based ? relPdMaxPos : vals.pd_max_pos;
        const displayPdZeroPos = appState.weight_based ? relPdZeroPos : vals.pd_zero_pos;

        const y1Max = displayVO2max * 1.25;
        const xMax = Math.max(...displayPower, 0);
        const xMid = xMax / 2;


        let displaySubstrateData = {
            cho: null,
            fat: null,
            unit: ""
        };

        if (appState.show_substrate) {
            switch(appState.energy_unit) {
                case "g/h":
                    displaySubstrateData.cho = vals.carb_g_h;
                    displaySubstrateData.fat = vals.fat_g_h;
                    displaySubstrateData.unit = "g·h<sup>-1</sup>";
                    break;
                case "kcal/h":
                    displaySubstrateData.cho = vals.carb_kcal_h;
                    displaySubstrateData.fat = vals.fat_kcal_h;
                    displaySubstrateData.unit = "kcal·h<sup>-1</sup>";
                    break;
                case "kJ/h":
                    displaySubstrateData.cho = vals.carb_kj_h;
                    displaySubstrateData.fat = vals.fat_kj_h;
                    displaySubstrateData.unit = "kJ·h<sup>-1</sup>";
                    break;
            }
        }

        const traces = [];

        // --- START: Determine x-axis formatting based on weight_based for hover ---
        const powerFormat = appState.weight_based ? ':.1f' : ':.0f';
        const vo2Format = appState.weight_based ? ':.1f' : ':.0f';
        // --- END: Determine x-axis formatting ---

        if (appState.swap_axes) { // Although this is to be removed, keeping the logic for now
            // --- SWAPPED AXES ---
            traces.push({ // VO2max line
                y: displayPower, x: Array(displayPower.length).fill(displayVO2max), name: "V̇O<sub>2,max</sub>", type: 'scatter', mode: 'lines',
                line: {color: '#CCCCCC', dash: 'dot', width: 2}, showlegend: false, hoverinfo: 'skip'
            });
            if (displayPdMaxPos >= Math.min(...displayPower) && displayPdMaxPos <= Math.max(...displayPower)) { // FATmax line
                traces.push({
                    y: [displayPdMaxPos, displayPdMaxPos], x: [0, y1Max], name: "FAT<sub>max</sub>", type: 'scatter', mode: 'lines',
                    line: {color: '#CCCCCC', dash: 'dot', width: 2}, showlegend: false, hoverinfo: 'skip'
                });
            }
            if (displayPdZeroPos >= Math.min(...displayPower) && displayPdZeroPos <= Math.max(...displayPower)) { // MLSS line
                traces.push({
                    y: [displayPdZeroPos, displayPdZeroPos], x: [0, y1Max], name: "MLSS", type: 'scatter', mode: 'lines',
                    line: {color: '#CCCCCC', dash: 'dot', width: 2}, showlegend: false, hoverinfo: 'skip'
                });
            }
            traces.push({ // VO2ss Curve
                y: displayPower, x: displayVO2ss, name: "V̇O<sub>2,SS</sub>", type: 'scatter', mode: 'lines',
                line: {color: '#2683C6', width: 3}, showlegend: true,
                hovertemplate: `<b>V̇O<sub>2,SS</sub></b><br>Power: %{y${powerFormat}} ${displayPowerUnitHover}<br>V̇O<sub>2</sub>: %{x${vo2Format}} ${displayVO2UnitHover}<extra></extra>`
            });
            traces.push({ // HR_ss Curve for SWAPPED axes
                y: displayPower,
                x: displayHR_ss_scaled,
                customdata: vals.HR_ss,
                name: "HR<sub>SS</sub> ⋅ 10⁻¹",
                type: 'scatter',
                mode: 'lines',
                yaxis: 'y2',
                line: {color: '#388E3C', dash: 'dash', width: 2, opacity: 0.8},
                showlegend: true,
                hovertemplate: `<b>HR<sub>SS</sub></b><br>Power: %{y${powerFormat}} ${displayPowerUnitHover}<br>HR: %{customdata:.0f} ${hrUnitHover}<extra></extra>`
            });
            traces.push({ // vLass
                x: displayPower, y: vals.vLass_min, name: "vLa<sub>SS</sub>", type: 'scatter', mode: 'lines', yaxis: 'y2',
                line: {color: '#EF5350', dash: 'dash', width: 2}, showlegend: true,
                hovertemplate: `<b>vLa<sub>SS</sub></b><br>Power: %{x${powerFormat}} ${displayPowerUnitHover}<br>Value: %{y:.3f} ${lactateRateUnitHover}<extra></extra>`
            });
            traces.push({ // vLaox
                x: displayPower, y: vals.vLaox_min, name: "vLa<sub>ox</sub>", type: 'scatter', mode: 'lines', yaxis: 'y2',
                line: {color: '#1CADE4', dash: 'dash', width: 2}, showlegend: true,
                hovertemplate: `<b>vLa<sub>ox</sub></b><br>Power: %{x${powerFormat}} ${displayPowerUnitHover}<br>Value: %{y:.3f} ${lactateRateUnitHover}<extra></extra>`
            });
            traces.push({ // PD
                x: displayPower, y: vals.PD_min, name: "PD", type: 'scatter', mode: 'lines', yaxis: 'y2',
                line: {color: "#9C85C0", width: 3}, showlegend: true,
                hovertemplate: `<b>PD</b><br>Power: %{x${powerFormat}} ${displayPowerUnitHover}<br>Value: %{y:.3f} ${lactateRateUnitHover}<extra></extra>`
            });
            traces.push({ // Net Lactate Production Rate
                x: displayPower, y: vals.netLactateProductionRate_min, name: "Net Lactate<sub>Accumulation Rate</sub>", type: 'scatter', mode: 'lines', yaxis: 'y2',
                line: {color: '#C8133B', width: 3}, showlegend: true,
                hovertemplate: `<b>Net Lactate<sub>Accumulation Rate</sub> </b><br>Power: %{x${powerFormat}} ${displayPowerUnitHover}<br>Value: %{y:.3f} ${lactateRateUnitHover}<extra></extra>`
            });
            if (appState.show_substrate) {
                const vo2maxReachedIdx = vals.crossPoint;
                traces.push({
                    y: displayPower.slice(0, vo2maxReachedIdx), x: displaySubstrateData.cho.slice(0, vo2maxReachedIdx),
                    name: `CHO (${displaySubstrateData.unit})`, type: 'scatter', mode: 'lines', xaxis: 'x2',
                    line: {color: '#D81B60', dash: 'dot', width: 2}, showlegend: true,
                    hovertemplate: `<b>CHO (${displaySubstrateData.unit})</b><br>Power: %{y${powerFormat}} ${displayPowerUnitHover}<br>Value: %{x:.1f} ${displaySubstrateData.unit}<extra></extra>`
                });
                const pdZeroIdx = displayPower.findIndex(p => p >= displayPdZeroPos);
                if (pdZeroIdx > 0) {
                    traces.push({
                        y: displayPower.slice(0, pdZeroIdx), x: displaySubstrateData.fat.slice(0, pdZeroIdx),
                        name: `Fat (${displaySubstrateData.unit})`, type: 'scatter', mode: 'lines', xaxis: 'x2',
                        line: {color: '#009688', dash: 'dot', width: 2}, showlegend: true,
                        hovertemplate: `<b>Fat (${displaySubstrateData.unit})</b><br>Power: %{y${powerFormat}} ${displayPowerUnitHover}<br>Value: %{x:.1f} ${displaySubstrateData.unit}<extra></extra>`
                    });
                }
            }
        } else {
            // --- NORMAL AXES ---
            traces.push({
                x: displayPower, y: Array(displayPower.length).fill(displayVO2max), name: "V̇O<sub>2,max</sub>", type: 'scatter', mode: 'lines',
                line: {color: '#CCCCCC', dash: 'dot', width: 2}, showlegend: false, hoverinfo: 'skip'
            });
            if (displayPdMaxPos >= Math.min(...displayPower) && displayPdMaxPos <= Math.max(...displayPower)) {
                traces.push({
                    x: [displayPdMaxPos, displayPdMaxPos], y: [0, 20], name: "FAT<sub>max</sub>", type: 'scatter', mode: 'lines',
                    line: {color: '#CCCCCC', dash: 'dot', width: 2}, showlegend: false, yaxis: 'y2', hoverinfo: 'skip'
                });
            }
            if (displayPdZeroPos >= Math.min(...displayPower) && displayPdZeroPos <= Math.max(...displayPower)) {
                traces.push({
                    x: [displayPdZeroPos, displayPdZeroPos], y: [0, 20], name: "MLSS", type: 'scatter', mode: 'lines',
                    line: {color: '#CCCCCC', dash: 'dot', width: 2}, showlegend: false, yaxis: 'y2', hoverinfo: 'skip'
                });
            }
            // VO2ss Curve
            if (vals.crossPoint > 1) {
                traces.push({
                    x: displayPower.slice(0, vals.crossPoint), y: displayVO2ss_unlimited.slice(0, vals.crossPoint),
                    name: "V̇O<sub>2,SS</sub>", type: 'scatter', mode: 'lines',
                    line: {color: '#2683C6', width: 3}, showlegend: true,
                    hovertemplate: `<b>V̇O<sub>2,SS</sub></b><br>Power: %{x${powerFormat}} ${displayPowerUnitHover}<br>V̇O<sub>2</sub>: %{y${vo2Format}} ${displayVO2UnitHover}<extra></extra>`
                });
                if (vals.crossPoint < displayPower.length) {
                    traces.push({
                        x: displayPower.slice(vals.crossPoint), y: displayVO2ss_unlimited.slice(vals.crossPoint),
                        name: "V̇O<sub>2,SS,extrapolated</sub>", type: 'scatter', mode: 'lines',
                        line: {color: '#2683C6', dash: 'dash', width: 3}, showlegend: true,
                        hovertemplate: `<b>V̇O<sub>2,SS,extrapolated</sub></b><br>Power: %{x${powerFormat}} ${displayPowerUnitHover}<br>V̇O<sub>2</sub>: %{y${vo2Format}} ${displayVO2UnitHover}<extra></extra>`
                    });
                }
            }

            // HR_ss Curve for NORMAL axes
            traces.push({
                x: displayPower,
                y: displayHR_ss_scaled, // Plot scaled HR
                customdata: vals.HR_ss, // Original HR for hover
                name: "HR<sub>SS</sub> ⋅ 10⁻¹",
                type: 'scatter',
                mode: 'lines',
                yaxis: 'y2', // On the same axis as lactate rates
                line: {color: '#388E3C', dash: 'dash', width: 2, opacity: 0.8}, // Solid line
                showlegend: true,
                hovertemplate: `<b>HR<sub>SS</sub></b><br>Power: %{x${powerFormat}} ${displayPowerUnitHover}<br>HR: %{customdata:.0f} ${hrUnitHover}<extra></extra>`
            });

            // Lactate rates and accumulation
            traces.push({
                x: displayPower, y: vals.vLass_min, name: "vLa<sub>SS</sub>", type: 'scatter', mode: 'lines', yaxis: 'y2',
                line: {color: '#EF5350', dash: 'dash', width: 2}, showlegend: true,
                hovertemplate: `<b>vLa<sub>SS</sub></b><br>Power: %{x${powerFormat}} ${displayPowerUnitHover}<br>Value: %{y:.3f} ${lactateRateUnitHover}<extra></extra>`
            });
            traces.push({
                x: displayPower, y: vals.vLaox_min, name: "vLa<sub>ox</sub>", type: 'scatter', mode: 'lines', yaxis: 'y2',
                line: {color: '#1CADE4', dash: 'dash', width: 2}, show2legend: true,
                hovertemplate: `<b>vLa<sub>ox</sub></b><br>Power: %{x${powerFormat}} ${displayPowerUnitHover}<br>Value: %{y:.3f} ${lactateRateUnitHover}<extra></extra>`
            });
            traces.push({
                x: displayPower, y: vals.PD_min, name: "PD", type: 'scatter', mode: 'lines', yaxis: 'y2',
                line: {color: "#9C85C0", width: 3}, showlegend: true,
                hovertemplate: `<b>PD</b><br>Power: %{x${powerFormat}} ${displayPowerUnitHover}<br>Value: %{y:.3f} ${lactateRateUnitHover}<extra></extra>`
            });
            traces.push({ // This trace now represents Net Lactate Production Rate
                            x: displayPower, y: vals.netLactateProductionRate_min, name: "Lactate<sub>Accumulation Rate</sub>", type: 'scatter', mode: 'lines', yaxis: 'y2',
                            line: {color: '#C8133B', width: 3}, showlegend: true,
                            hovertemplate: `<b>Net Lactate<sub>Accumulation Rate</sub> </b><br>Power: %{x${powerFormat}} ${displayPowerUnitHover}<br>Value: %{y:.3f} ${lactateRateUnitHover}<extra></extra>`
                        });

            if (appState.show_substrate) {
                const vo2maxReachedIdx = vals.crossPoint;
                traces.push({
                    x: displayPower.slice(0, vo2maxReachedIdx), y: displaySubstrateData.cho.slice(0, vo2maxReachedIdx),
                    name: `CHO (${displaySubstrateData.unit})`, type: 'scatter', mode: 'lines', yaxis: 'y3',
                    line: {color: '#D81B60', dash: 'dot', width: 2}, showlegend: true,
                    hovertemplate: `<b>CHO (${displaySubstrateData.unit})</b><br>Power: %{x${powerFormat}} ${displayPowerUnitHover}<br>Value: %{y:.1f} ${displaySubstrateData.unit}<extra></extra>`
                });
                const pdZeroIdx = displayPower.findIndex(p => p >= displayPdZeroPos);
                if (pdZeroIdx > 0) {
                    traces.push({
                        x: displayPower.slice(0, pdZeroIdx), y: displaySubstrateData.fat.slice(0, pdZeroIdx),
                        name: `Fat (${displaySubstrateData.unit})`, type: 'scatter', mode: 'lines', yaxis: 'y3',
                        line: {color: '#009688', dash: 'dot', width: 2}, showlegend: true,
                        hovertemplate: `<b>Fat (${displaySubstrateData.unit})</b><br>Power: %{x${powerFormat}} ${displayPowerUnitHover}<br>Value: %{y:.1f} ${displaySubstrateData.unit}<extra></extra>`
                    });
                }
            }
        }

        const annotations = [];
        const fixedYAxisRange = appState.weight_based ? [0, 100] : [0, 7500];
        const xaxisRange = appState.lock_x_axis ?
            (appState.weight_based ? [0, 600 / appState.body_mass] : [0, 600]) :
            (displayPower.length > 0 ? [0, Math.max(...displayPower) * 1.05] : [0, 600]);
        const yaxisRange = appState.lock_y_axis ? fixedYAxisRange :
            (displayVO2ss_unlimited.length > 0 ? [0, Math.max(...displayVO2ss_unlimited) * 1.1] : [0, 7500]);

        let layout;
        if (appState.swap_axes) { // Although to be removed, I'll keep the conditional logic for now.
            layout = {
                title: { text: "V̇O<sub>2,SS</sub>, vLa<sub>SS</sub>, vLa<sub>ox</sub>, PD and Lactate Accumulation", font: { size: 18, color: '#2683C6' }},
                margin: {l: 60, r: 60, t: 60, b: 80},
                xaxis: {
                    title: { text: `V̇O<sub>2</sub>ss (${appState.weight_based ? "ml·min<sup>-1</sup>·kg<sup>-1</sup>" : "ml·min<sup>-1</sup>"})`, font: { size: 14 }},
                    range: yaxisRange, showgrid: true, gridcolor: 'rgba(200,200,200,0.2)'
                },
                yaxis: {
                    title: { text: `Power (${appState.weight_based ? "W·kg<sup>-1</sup>" : "W"})`, font: { size: 14 }},
                    side: "left", range: xaxisRange, showgrid: true, gridcolor: 'rgba(200,200,200,0.2)'
                },
                yaxis2: {
                    title: { text: "Lactate & Metabolic Rates (mmol·l<sup>-1</sup>·min<sup>-1</sup>) / HR ⋅ 10⁻¹ (bpm)", font: { size: 10 } },
                    overlaying: "y", side: "right", range: [0, 20], showgrid: false, dtick: 2
                },
                showlegend: true,
                legend: { x: 0.5, y: 1.05, xanchor: 'center', yanchor: 'top', orientation: 'h', bgcolor: 'rgba(255, 255, 255, 0)', bordercolor: 'rgba(0,0,0,0)', borderwidth: 0},
                annotations: annotations, paper_bgcolor: 'rgba(255,255,255,0)', plot_bgcolor: 'rgba(255,255,255,0.5)', hovermode: 'closest'
            };
            if (appState.show_substrate) {
                const substrateMaxX = (displaySubstrateData.cho && displaySubstrateData.cho.length > 0) ? Math.max(...displaySubstrateData.cho.filter(v => !isNaN(v))) : 0;
                layout.xaxis2 = {
                    title: { text: `Substrate Utilization (${displaySubstrateData.unit})`, font: { size: 12 }},
                    overlaying: "x", side: "top", showgrid: false,
                    range: [0, substrateMaxX > 0 ? substrateMaxX * 1.1 : 100]
                };
            }
            annotations.push(
                { y: displayPdMaxPos, x: y1Max * 0.9, text: `FAT<sub>max</sub><br>${(appState.weight_based ? displayPdMaxPos.toFixed(1) : Math.round(displayPdMaxPos))} ${appState.weight_based ? "W·kg<sup>-1</sup>" : "W"}`, showarrow: false, font: {color: '#666666'}, xanchor: "center" },
                { y: displayPdZeroPos, x: y1Max * 0.9, text: `MLSS<br>${(appState.weight_based ? displayPdZeroPos.toFixed(1) : Math.round(displayPdZeroPos))} ${appState.weight_based ? "W·kg<sup>-1</sup>" : "W"}`, showarrow: false, font: {color: '#666666'}, xanchor: "center" }
            );
            annotations.push({ y: xMid, x: displayVO2max + (y1Max - displayVO2max) * 0.1, text: `V̇O<sub>2,max</sub>: ${relVO2max.toFixed(1)} ml·min<sup>-1</sup>·kg<sup>-1</sup>`, showarrow: false, font: {color: '#666666'}, yanchor: "center"});
        } else {
            layout = {
                title: { text: "V̇O<sub>2,SS</sub>, vLa<sub>SS</sub>, vLa<sub>ox</sub>, PD and Lactate Accumulation", font: { size: 18, color: '#2683C6' }},
                margin: {l: 60, r: 60, t: 60, b: 80},
                xaxis: {
                    title: { text: `Power (${appState.weight_based ? "W·kg<sup>-1</sup>" : "W"})`, font: { size: 14 }},
                    range: xaxisRange, showgrid: true, gridcolor: 'rgba(200,200,200,0.2)'
                },
                yaxis: {
                    title: { text: `V̇O<sub>2</sub>ss (${appState.weight_based ? "ml·min<sup>-1</sup>·kg<sup>-1</sup>" : "ml·min<sup>-1</sup>"})`, font: { size: 14 }},
                    side: "left", range: yaxisRange, showgrid: true, gridcolor: 'rgba(200,200,200,0.2)'
                },
                yaxis2: {
                    title: { text: "Lactate & Metabolic Rates (mmol·l<sup>-1</sup>·min<sup>-1</sup>) / HR ⋅ 10⁻¹ (bpm)", font: { size: 10 } },
                    overlaying: "y", side: "right", range: [0, 20], showgrid: false, dtick: 2 // Adjust range as needed, or make dynamic
                },
                showlegend: true,
                legend: { x: 0.5, y: 1.05, xanchor: 'center', yanchor: 'top', orientation: 'h', bgcolor: 'rgba(255, 255, 255, 0)', bordercolor: 'rgba(0,0,0,0)', borderwidth: 0},
                annotations: annotations, paper_bgcolor: 'rgba(255,255,255,0)', plot_bgcolor: 'rgba(255,255,255,0.5)', hovermode: 'closest'
            };
            if (appState.show_substrate) {
                const substrateCHOMax = displaySubstrateData.cho && displaySubstrateData.cho.length > 0 ? Math.max(...displaySubstrateData.cho.filter(v => !isNaN(v))) : 0;
                const substrateFatMax = displaySubstrateData.fat && displaySubstrateData.fat.length > 0 ? Math.max(...displaySubstrateData.fat.filter(v => !isNaN(v))) : 0;
                const substrateMaxValue = Math.max(substrateCHOMax, substrateFatMax) * 1.1;
                layout.yaxis3 = {
                    title: { text: `Substrate Utilization (${displaySubstrateData.unit})`, font: { size: 12 }},
                    overlaying: "y", side: "right", anchor: "free", position: 0.93,
                    range: [0, substrateMaxValue > 0 ? substrateMaxValue : 100],
                    showgrid: false
                };
            }
            annotations.push(
                { x: xMid * 0.70, y: displayVO2max + (y1Max - displayVO2max) * 0.1, text: `V̇O<sub>2,max</sub>: ${relVO2max.toFixed(1)} ml·min<sup>-1</sup>·kg<sup>-1</sup>`, showarrow: false, font: {color: '#666666'}, xanchor: "center" },
                { x: displayPdMaxPos, y: y1Max * 0.90, text: `FAT<sub>max</sub><br>${(appState.weight_based ? displayPdMaxPos.toFixed(1) : Math.round(displayPdMaxPos))} ${appState.weight_based ? "W·kg<sup>-1</sup>" : "W"}`, showarrow: false, font: {color: '#666666'}, xanchor: "center" },
                { x: displayPdZeroPos, y: y1Max * 0.90, text: `MLSS<br>${(appState.weight_based ? displayPdZeroPos.toFixed(1) : Math.round(displayPdZeroPos))} ${appState.weight_based ? "W·kg<sup>-1</sup>" : "W"}`, showarrow: false, font: {color: '#666666'}, xanchor: "center" }
            );
        }

        let formulaTextVO2 = '';
        if (appState.curvilinear) {
            if (appState.weight_based) {
                formulaTextVO2 = `V̇O<sub>2,SS</sub> (P) = ${vals.a_opt ? vals.a_opt.toFixed(4) : 'N/A'}·P² + ${appState.CE_range[0].toFixed(1)}·P + ${(vals.effective_values.VO2Base/appState.body_mass).toFixed(1)}`;
            } else {
                formulaTextVO2 = `V̇O<sub>2,SS</sub> (P) = ${vals.a_opt ? vals.a_opt.toFixed(4) : 'N/A'}·P² + ${appState.CE_range[0].toFixed(1)}·P + ${Math.round(vals.effective_values.VO2Base)}`;
            }
        } else {
            if (appState.weight_based) {
                formulaTextVO2 = `V̇O<sub>2,SS</sub> (P) = ${vals.effective_values.CEVO2.toFixed(1)}·P + ${(vals.effective_values.VO2Base/appState.body_mass).toFixed(1)}`;
            } else {
                formulaTextVO2 = `V̇O<sub>2,SS</sub> (P) = ${vals.effective_values.CEVO2.toFixed(1)}·P + ${Math.round(vals.effective_values.VO2Base)}`;
            }
        }
        if (appState.cadence_dependent) {
            formulaTextVO2 += `<br>(Cadence: ${appState.cadence} rpm)`;
        }

        let formulaTextHR = '';
        // HR formula is independent of weight_based for its direct display string here
        formulaTextHR = `HR<sub>SS</sub> (P) = ${vals.effective_values.CE_HR.toFixed(2)}·P + ${Math.round(vals.effective_values.HR_Base)}`;
        
        const combinedFormulaText = `${formulaTextVO2}<br>${formulaTextHR}`;

        if (appState.swap_axes) { // Will be removed, but keep for consistency for now
            annotations.push({
                y: (displayPower.length > 0 ? 0.15 * Math.max(...displayPower) : 0), x: 0.15 * displayVO2max, text: combinedFormulaText, showarrow: false,
                font: { family: "Arial", size: 12, color: "#666666" }, xanchor: "left", yanchor: "middle", align: "left"
            });
        } else {
            annotations.push({
                x: (displayPower.length > 0 ? 0.15 * Math.max(...displayPower) : 0), y: 0.15 * displayVO2max, text: combinedFormulaText, showarrow: false,
                font: { family: "Arial", size: 12, color: "#666666" }, xanchor: "left", yanchor: "middle", align: "left"
            });
        }

        layout.annotations = annotations;

        Plotly.newPlot('plot-container', traces, layout, {
            displayModeBar: true,
            responsive: true
        });

        updateValuesDisplay(vals);
        const fatmaxIdx = vals.PD_min.indexOf(Math.max(...vals.PD_min));
        let minAbsPD_eff = Infinity;
        let pdZeroIdx_eff = 0;
        for (let i = 0; i < vals.PD_min.length; i++) {
            const absPD_eff = Math.abs(vals.PD_min[i]);
            if (absPD_eff < minAbsPD_eff) {
                minAbsPD_eff = absPD_eff;
                pdZeroIdx_eff = i;
            }
        }
        const fatmaxRQ = vals.predicted_rq && vals.predicted_rq.length > fatmaxIdx ? vals.predicted_rq[fatmaxIdx] : 0.85;
        const mlssRQ = vals.predicted_rq && vals.predicted_rq.length > pdZeroIdx_eff ? vals.predicted_rq[pdZeroIdx_eff] : 0.95;
        const fatmaxEfficiency = calculateEfficiency(vals.P[fatmaxIdx], vals.VO2ss[fatmaxIdx], fatmaxRQ, vals.effective_values.VO2Base);
        const mlssEfficiency = calculateEfficiency(vals.P[pdZeroIdx_eff], vals.VO2ss[pdZeroIdx_eff], mlssRQ, vals.effective_values.VO2Base);
        if (appState.cadence_dependent) {
            const effectiveCE = vals.effective_values.CEVO2;
            const deltaEta = calculateDeltaEfficiency(effectiveCE);
            document.getElementById('delta-eta-value').textContent = `${deltaEta.min.toFixed(1)}-${deltaEta.max.toFixed(1)}%`;
        }
        if (document.getElementById('gross-eta-value')) {
            document.getElementById('gross-eta-value').innerHTML = `${fatmaxEfficiency.gross.toFixed(1)}% | ${mlssEfficiency.gross.toFixed(1)}%`;
        }
        if (document.getElementById('net-eta-value')) {
            document.getElementById('net-eta-value').innerHTML = `${fatmaxEfficiency.net.toFixed(1)}% | ${mlssEfficiency.net.toFixed(1)}%`;
        }
        if (appState.show_substrate) {
            updateSubstratePlot();
        }
    }

    // Function to update the values display in Tab 1
    function updateValuesDisplay(vals) {
        const pdMaxIdx = vals.PD_min.indexOf(Math.max(...vals.PD_min));
        
        // Find index of MLSS (PD closest to zero)
        let minAbsPD = Infinity;
        let pdZeroIdx = 0;
        for (let i = 0; i < vals.PD_min.length; i++) {
            const absPD = Math.abs(vals.PD_min[i]);
            if (absPD < minAbsPD) {
                minAbsPD = absPD;
                pdZeroIdx = i;
            }
        }
        
        // Format the output text with proper units
        const formatOutput = (positionName, idx) => {
            const powerValue = appState.weight_based ? vals.P[idx]/appState.body_mass : vals.P[idx];
            const vo2ssValue = appState.weight_based ? vals.VO2ss[idx]/appState.body_mass : vals.VO2ss[idx];
            const powerUnit = appState.weight_based ? "W·kg<sup>-1</sup>" : "W";
            const vo2ssUnit = appState.weight_based ? "ml·min<sup>-1</sup>·kg<sup>-1</sup>" : "ml·min<sup>-1</sup>";
            
            // Calculate percentage of VO2max
            const vo2maxValue = appState.weight_based ? vals.effective_values.VO2max/appState.body_mass : vals.effective_values.VO2max;
            const vo2Percentage = (vo2ssValue / vo2maxValue) * 100;
            const hrValue = vals.HR_ss[idx]; // Using the HR_ss array calculated in calculateValues()
            
            // Get predicted RQ value
            const rqValue = vals.predicted_rq && idx < vals.predicted_rq.length ? vals.predicted_rq[idx] : 0.85;
            
            // Calculate efficiency values
            const effValues = calculateEfficiency(
                vals.P[idx], 
                vals.VO2ss[idx], 
                rqValue, 
                vals.effective_values.VO2Base
            );
            
            // Prepare substrate info if feature is enabled
            let substrateInfo = "";
            if (appState.show_substrate && idx < vals.carb_percentage.length) {
                // Get values and unit based on energy unit selection
                let choValue, fatValue, unit;
                switch(appState.energy_unit) {
                    case "g/h":
                        choValue = vals.carb_g_h[idx];
                        fatValue = vals.fat_g_h[idx];
                        unit = "g·h<sup>-1</sup>";
                        break;
                    case "kcal/h":
                        choValue = vals.carb_kcal_h[idx];
                        fatValue = vals.fat_kcal_h[idx];
                        unit = "kcal·h<sup>-1</sup>";
                        break;
                    case "kJ/h":
                        choValue = vals.carb_kj_h[idx];
                        fatValue = vals.fat_kj_h[idx];
                        unit = "kJ·h<sup>-1</sup>";
                        break;
                }
                
                substrateInfo = `  Carbohydrates: ${choValue.toFixed(1)} ${unit} (${vals.carb_percentage[idx].toFixed(1)}%)\n` +
                                `  Fat: ${fatValue.toFixed(1)} ${unit} (${vals.fat_percentage[idx].toFixed(1)}%)\n` +
                                `  Predicted RQ: ${rqValue.toFixed(3)}\n`;
            }
            
            return `${positionName} (${powerValue.toFixed(1)} ${powerUnit}):\n` +
                `  V̇O<sub>2,SS</sub>: ${vo2ssValue.toFixed(2)} ${vo2ssUnit} (${vo2Percentage.toFixed(1)}% of V̇O<sub>2,max</sub>)\n` +
                `  HR<sub>SS</sub>: ${hrValue.toFixed(0)} bpm\n` +
                `  vLa<sub>SS</sub>: ${vals.vLass_min[idx].toFixed(4)} mmol·l<sup>-1</sup>·min<sup>-1</sup>\n` +
                `  vLa<sub>ox</sub>: ${vals.vLaox_min[idx].toFixed(4)} mmol·l<sup>-1</sup>·min<sup>-1</sup>\n` +
                `  PD: ${vals.PD_min[idx].toFixed(4)} mmol·l<sup>-1</sup>·min<sup>-1</sup>\n` +
                substrateInfo +
                `  η<sub>gross</sub>: ${effValues.gross.toFixed(1)}%\n` +
                `  η<sub>net</sub>: ${effValues.net.toFixed(1)}%\n`;
        };
                    
        let outputText = "";
        
        // Add cadence info if enabled
        if (appState.cadence_dependent) {
            outputText += `Cadence: ${appState.cadence} rpm\n`;
            outputText += `CE: ${vals.effective_values.CEVO2.toFixed(2)} ml·min⁻¹·W⁻¹, ` +
                        `V̇O<sub>2,Base</sub>: ${Math.round(vals.effective_values.VO2Base)} ml·min⁻¹\n`;
            
            if (appState.vo2max_dependent) {
                outputText += `V̇O<sub>2,max</sub>: ${Math.round(vals.effective_values.VO2max)} ml·min⁻¹\n`;
            }
            
            if (appState.vlamax_dependent) {
                outputText += `vLa<sub>max</sub>: ${vals.effective_values.vLamax.toFixed(2)} mmol·l⁻¹·s⁻¹\n`;
            }
            
            outputText += `\n`;
        }
        
        outputText += 
            formatOutput("FAT<sub>max</sub>", pdMaxIdx) +
            formatOutput("MLSS", pdZeroIdx);
        
        elements.valuesContainer.innerHTML = outputText;
    }

    
    
    // Function to create power data for step test
    function createPowerData() {
        // Check if interval data is available
        if (appState.interval_data) {
            const data = appState.interval_data;
            
            // Sort by time
            data.sort((a, b) => a.time_s - b.time_s);
            
            // If we have at least two datapoints
            if (data.length > 1) {
                const minTime = data[0].time_s;
                const maxTime = data[data.length - 1].time_s;
                const allSeconds = [];
                const allPower = [];
                const allCadence = [];
                
                // Generate data for every second
                for (let t = minTime; t <= maxTime; t++) {
                    allSeconds.push(t);
                    
                    // Find the last power value at or before this time
                    let lastIdx = 0;
                    for (let i = 0; i < data.length; i++) {
                        if (data[i].time_s <= t) {
                            lastIdx = i;
                        } else {
                            break;
                        }
                    }
                    
                    allPower.push(data[lastIdx].power);
                    
                    // Add cadence if it exists
                    if (data[lastIdx].cadence !== undefined) {
                        allCadence.push(data[lastIdx].cadence);
                    } else {
                        allCadence.push(null);
                    }
                }
                
                return {
                    time_s: allSeconds,
                    power: allPower,
                    cadence: allCadence.every(c => c === null) ? null : allCadence
                };
            }
            
            // If there's cadence data in the interval data
            if (data.some(d => d.cadence !== undefined)) {
                return {
                    time_s: data.map(d => d.time_s),
                    power: data.map(d => d.power),
                    cadence: data.map(d => d.cadence || null)
                };
            } else {
                return {
                    time_s: data.map(d => d.time_s),
                    power: data.map(d => d.power),
                    cadence: null
                };
            }
        }
        // Check if a file was uploaded
        else if (appState.power_data) {
            return appState.power_data;
        }
        // Create step test data
        else {
            const stepWatt = appState.step_watt;
            const stepDurationSec = appState.step_duration;
            const maxPower = appState.max_power_step;
            
            // Create time and power arrays
            const numSteps = Math.floor(maxPower / stepWatt) + 1;
            const stepEndPower = (numSteps - 1) * stepWatt; // Last regular step
            const totalDurationSec = numSteps * stepDurationSec;
            const timeSec = [];
            const power = [];
            
            // Add step test (ensure maxPower is not exceeded)
            for (let i = 0; i < totalDurationSec; i++) {
                timeSec.push(i);
                const currentStep = Math.floor(i / stepDurationSec);
                const currentPower = currentStep * stepWatt;
                // Ensure maxPower is not exceeded
                power.push(Math.min(currentPower, stepEndPower));
            }
            
            // Add cool-down phase (1800s at 0 Watt) after the step test
            const cooldownDuration = 1800; // 1800 seconds (10 minutes)
            const lastTime = timeSec[timeSec.length - 1];
            
            for (let i = 1; i <= cooldownDuration; i++) {
                timeSec.push(lastTime + i);
                power.push(0); // 0 Watt during cooldown
            }
            
            return {
                time_s: timeSec,
                power: power,
                cadence: null // No cadence in generated data
            };
        }
    }
    
    function initializeVo2StartSlider() {
        // Bestimme die effektiven VO2Base und VO2max Werte basierend auf use_tab1_params
        const base = appState.use_tab1_params ? appState.VO2Base : appState.VO2Base_step;
        const maxVal = appState.use_tab1_params ? appState.VO2max : appState.VO2max_step;

        if (elements.vo2_start) { // Sicherstellen, dass das Element existiert
            elements.vo2_start.min = base;
            elements.vo2_start.max = maxVal;

            let updateToDefault = false;
            if (appState.vo2_start === 400 && base !== 400) { // Initialer Platzhalter und Base ist anders
                updateToDefault = true;
            }

            if (updateToDefault || appState.vo2_start < base) {
                appState.vo2_start = base; // Setze auf VO2Base als Standard oder wenn unter Minimum
            } else if (appState.vo2_start > maxVal) {
                appState.vo2_start = maxVal; // Klemme auf VO2max, wenn darüber
            }

            elements.vo2_start.value = appState.vo2_start;
            elements.vo2_startValue.textContent = Math.round(appState.vo2_start); // Runde für die Anzeige
        }
    }
    initializeVo2StartSlider(); // Call it after the first plot updates

    // Calculate W' Balance using Skiba's model
    function calcWPrimeBalance(powerValues, timeValues, cp, wprime) {
        const wprimeBalance = [];
        wprimeBalance[0] = wprime * 1000;  // Convert to Joules
        
        for (let i = 1; i < powerValues.length; i++) {
            // Time difference between current and previous measurement
            const deltaT = timeValues[i] - timeValues[i-1];
            
            // Calculate W' consumption/recovery
            if (powerValues[i-1] > cp) {
                // W' is consumed when power > CP
                const wprimeExp = (powerValues[i-1] - cp) * deltaT;
                wprimeBalance[i] = wprimeBalance[i-1] - wprimeExp;
            } else {
                // W' recovers when power < CP
                // Calculate DCP and time constant using Skiba's formula
                const dcp = cp - powerPrev; // Difference Critical Power (CP - Power_recovery)
                const wPrimeInitialJoules = wprime * 1000; // W₀ (initial W') in Joules

                // Implement Skiba et al. (2015) Appendix 1 recovery model
                if (dcp > 0 && wPrimeInitialJoules > 0) { // Only recover if power is below CP and W' is not zero
                    const recoveryRateFactor = dcp / wPrimeInitialJoules; // This is the term DCP/W₀
                    wPrimeNext = wPrimeInitialJoules - (wPrimeInitialJoules - wPrimePrev) * Math.exp(-recoveryRateFactor * deltaT);
                } else {
                    // No recovery if power is >= CP or initial W' is zero
                    wPrimeNext = wPrimePrev; // W' balance remains the same in this step
                }
            }
            
            // Ensure W' Balance doesn't exceed maximum
            wprimeBalance[i] = Math.min(wprimeBalance[i], wprime * 1000);
        }
        
        // Convert from Joules to kJ for display
        return wprimeBalance.map(w => w / 1000);
    }

    // Calculate MPA (Maximum Power Available) based on W' expenditure
    function calculateMPA(wprime_balance, wprime, pmax, cp) {
        // W'exp is the amount of W' expended (wprime - wprime_balance)
        const wprimeExp = wprime * 1000 - wprime_balance * 1000; // Convert to Joules
        
        // Use the modified 3-parameter model from Kontro et al. (2024) where W'exp/W' is raised to the 2nd power
        const mpa = pmax - (pmax - cp) * Math.pow((wprimeExp / (wprime * 1000)), 2);
        
        return Math.max(cp, mpa); // MPA cannot drop below CP
    }

    // Calculate the contribution of each energy system to power output
    function calculateEnergySystemContributions(power, cp, pmax) {
        // Power contributions
        let pCP, pWprime, pPmax;
        
        if (power <= cp) {
            // If power is below CP, all energy comes from aerobic system
            pCP = power;
            pWprime = 0;
            pPmax = 0;
        } else {
            // Calculate Pmax contribution using Equation 11
            pPmax = Math.pow(power - cp, 2) / (pmax - cp);
            
            // Calculate W' contribution using Equation 12
            pWprime = power - cp - pPmax;
            
            // CP contribution is just CP (Equation 13)
            pCP = cp;
        }
        
        return {
            pCP: pCP,
            pWprime: pWprime, 
            pPmax: pPmax
        };
    }

    // Calculate strain coefficient using Equation 14
    function calculateStrainCoefficient(power, mpa, cp, pmax) {
        return (pmax - mpa + cp) / (pmax - power + cp);
    }

    // Calculate strain rate using Equation 15
    function calculateStrainRate(kstrain, power) {
        return kstrain * power;
    }

    // Calculate Strain Score using Equation 16
    function calculateStrainScore(strainRates, cp, pmax) {
        // Sum all strain rates and normalize
        const sumSR = strainRates.reduce((sum, sr) => sum + sr, 0);
        
        // Multiply by normalization factor to get 100 at CP for one hour
        const normalizationFactor = (pmax / Math.pow(cp, 2)) * (100 / 3600);
        
        return sumSR * normalizationFactor;
    }

    // Calculate energy system-specific strain rates
    function calculateSystemStrainRates(power, mpa, cp, pmax) {
        // Get strain coefficient
        const kstrain = calculateStrainCoefficient(power, mpa, cp, pmax);
        
        // Get energy system contributions
        const contributions = calculateEnergySystemContributions(power, cp, pmax);
        
        // Calculate strain rates for each system
        const srCP = kstrain * contributions.pCP;
        const srWprime = kstrain * contributions.pWprime;
        const srPmax = kstrain * contributions.pPmax;
        
        return {
            total: kstrain * power,
            CP: srCP,
            Wprime: srWprime,
            Pmax: srPmax
        };
    }
    
       // Function to calculate step test simulation
        function calculateStepTest() {
            // Get parameters - either from tab 1 or individual
            let CE = appState.use_tab1_params ? appState.CEVO2 : appState.CEVO2_step;
            let CE_range = appState.use_tab1_params ? appState.CE_range : appState.CE_range_step;
            let isCurvilinear = appState.use_tab1_params ? appState.curvilinear : appState.curvilinear_step;
            let VO2max = appState.use_tab1_params ? appState.VO2max : appState.VO2max_step;
            let VO2Base = appState.use_tab1_params ? appState.VO2Base : appState.VO2Base_step;
            let vLamax_base = appState.use_tab1_params ? appState.vLamax : appState.vLamax_step; // Base vLamax before pH/cadence adjustment
            let body_mass = appState.use_tab1_params ? appState.body_mass : appState.body_mass_step;
            let HR_max = appState.use_tab1_params ? appState.HR_max : appState.HR_max_step;
            let HR_Base = appState.use_tab1_params ? appState.HR_Base : appState.HR_Base_step;
            let CE_HR = appState.use_tab1_params ? appState.CE_HR : appState.CE_HR_step;
            const TAU_HR_ON = 60;  // Fixed time constant for HR increase (seconds)
            const TAU_HR_OFF = 55; // Fixed time constant for HR decrease (seconds)

            // Determine parameters for dynamic PCr resynthesis factor
            const mlss_power_for_pcr_logic = appState.mlss_value; // From Tab 1 calculations (MLSS power)
            let vo2_at_mlss_for_pcr_logic;
            // Get VO2base depending on whether Tab 1 or Tab 2 parameters are used
            const vo2_base_for_pcr_logic = appState.use_tab1_params ? appState.VO2Base : appState.VO2Base_step;
            let max_vo2_diff_for_recovery_span = 0; // Initialize

            if (mlss_power_for_pcr_logic !== null && mlss_power_for_pcr_logic !== undefined) {
                // Calculate VO2 at MLSS based on current CE model (linear or curvilinear)
                // These parameters should reflect what's active in Tab 2 (either from Tab 1 or Tab 2's own settings)
                const current_active_CE_linear = appState.use_tab1_params ? appState.CEVO2 : appState.CEVO2_step;
                const current_active_is_curvilinear = appState.use_tab1_params ? appState.curvilinear : appState.curvilinear_step;
                const current_active_CE_range_start = appState.use_tab1_params ? appState.CE_range[0] : appState.CE_range_step[0];
                const current_active_CE_range_end = appState.use_tab1_params ? appState.CE_range[1] : appState.CE_range_step[1];
                // Ensure VO2max for aOpt calculation is also from the correct source for Tab 2
                const vo2max_for_aOpt_calc = appState.use_tab1_params ? appState.VO2max : appState.VO2max_step;


                if (current_active_is_curvilinear) {
                    // 'aOpt' is calculated later in the main loop if needed for VO2ss.
                    // For consistency, we should ideally use the same 'aOpt' or recalculate it here
                    // based on the active parameters for Tab 2.
                    // Let's assume 'aOpt' (if needed by the main VO2ss calc) will be available,
                    // or we can make a local one for this specific logic.
                    // For robustness, we can make a local calculation for aOpt if not already globally available.
                    let local_aOpt_for_pcr = aOpt; // 'aOpt' is from the broader function scope
                    if (!local_aOpt_for_pcr) { // If aOpt wasn't calculated yet (e.g. if this code runs before main aOpt calc)
                         // We need a VO2max and VO2Base that are consistent with the CE_range being used.
                         // This might be tricky if effectiveVO2Base/Max are themselves cadence-dependent and calculated per step.
                         // For simplicity, let's use the global/Tab 2 VO2max and VO2Base here.
                        local_aOpt_for_pcr = findOptimalA(current_active_CE_range_start, current_active_CE_range_end, vo2max_for_aOpt_calc, vo2_base_for_pcr_logic);
                    }

                    if (local_aOpt_for_pcr) {
                         vo2_at_mlss_for_pcr_logic = local_aOpt_for_pcr * Math.pow(mlss_power_for_pcr_logic, 2) + current_active_CE_range_start * mlss_power_for_pcr_logic + vo2_base_for_pcr_logic;
                    } else {
                        // Fallback if aOpt cannot be determined (should not happen if parameters are valid)
                        vo2_at_mlss_for_pcr_logic = current_active_CE_linear * mlss_power_for_pcr_logic + vo2_base_for_pcr_logic;
                    }
                } else {
                    vo2_at_mlss_for_pcr_logic = current_active_CE_linear * mlss_power_for_pcr_logic + vo2_base_for_pcr_logic;
                }
                 // Ensure vo2_at_mlss is not less than vo2_base
                vo2_at_mlss_for_pcr_logic = Math.max(vo2_at_mlss_for_pcr_logic, vo2_base_for_pcr_logic);
                max_vo2_diff_for_recovery_span = vo2_at_mlss_for_pcr_logic - vo2_base_for_pcr_logic;
            } else {
                // Fallback if MLSS power is not available:
                // Set vo2_at_mlss high to effectively disable intensity-dependent scaling or use a default.
                // This means the dynamic factor might not work as intended, defaults to a simpler resynthesis.
                vo2_at_mlss_for_pcr_logic = appState.use_tab1_params ? appState.VO2max : appState.VO2max_step; // A high value
                max_vo2_diff_for_recovery_span = vo2_at_mlss_for_pcr_logic - vo2_base_for_pcr_logic;
                console.warn("MLSS power not available for dynamic PCr resynthesis logic. Using fallback.");
            }
            // Ensure max_vo2_diff_for_recovery_span is not negative if vo2_at_mlss ended up being less than vo2_base (e.g. due to extreme CE values or errors)
            if (max_vo2_diff_for_recovery_span < 0) max_vo2_diff_for_recovery_span = 0;

            // Parameters & Volumes for 2-Compartment Model 
            const Kdiff_s = (0.065 / 60) * 2.5; // Diffusion constant (min⁻¹ -> s⁻¹) from Mader 2003 -> ~0.001083 s⁻¹ oder hier 0.065/60 -> Aber höhere Term klappt besser, deshalb * 3.5 oder mehr
            const k_clearance_b = 0.0005; // Clearance rate in blood (s⁻¹, example value - can be adjusted)
            const Vd_lactate_fraction = 0.45; // Lactate distribution volume fraction of body mass
            const Vm_water_fraction = 0.75; // Wasseranteil in aktiver Muskelmasse

    

            // Get current body mass and active muscle mass
            let current_body_mass = appState.use_tab1_params ? appState.body_mass : appState.body_mass_step;
            let current_active_muscle_mass = appState.active_muscle_mass; // Already used in PCr section

            const Vm = current_active_muscle_mass * Vm_water_fraction; // Muscle water (Liters)
            const Vd = current_body_mass * Vd_lactate_fraction; // Total lactate distribution volume (Liters)
            const Vb = Math.max(1, Vd - Vm); // Blood/passive compartment volume (Liters, min. 1L)
            const Vrel = (Vb > 0) ? Vm / Vb : 0; // Volume ratio Vm/Vb (dimensionless)

            // Intensity-Dependent Tau_Off Setup ---
                    const use_dynamic_tau_off = appState.dynamic_tau_off;
                    const tau_off_slider_value = appState.vo2_down_time_constant; // This is the baseline at 50% if dynamic is ON
                    // Calculate offset based on deviation from the formula's 50% value (0.45*50+10 = 32.5)
                    const tau_off_adjustment = use_dynamic_tau_off ? (tau_off_slider_value - 32.5) : 0;
                    const tau_off_values = []; // Array to store calculated tau_off for each step
                    // --- END: Intensity-Dependent Tau_Off Setup ---

                  
            // --- START: Intensity-Dependent Tau_On Setup ---
                    const use_dynamic_tau_on = appState.dynamic_tau_on;
                    const tau_on_slider_value = appState.vo2_up_time_constant; // Baseline at 50% if dynamic is ON
                    // Calculate offset based on deviation from formula's 50% value (0.38*50+6 = 25)
                    const tau_on_adjustment = use_dynamic_tau_on ? (tau_on_slider_value - 25.0) : 0;
                    // --- END: Intensity-Dependent Tau_On Setup ---

                

            // Get power data
            const powerData = createPowerData();
            // Check if powerData is valid
            if (!powerData || !powerData.time_s || powerData.time_s.length === 0) {
                console.error("Failed to get power data or power data is empty.");
                showNotification("Error loading or generating power data.", "warning");
                // Return an empty object or default structure to prevent crashes downstream
                return {
                    time_sec: [], power: [], VO2: [], vo2_demand: [], vLass_min: [], vLaox_min: [],
                    PD: [], La_conc: [], w_prime_bal: [], glycogen_store: [], carb_gram_min: [],
                    fat_gram_min: [], abort_power: null, abort_time: null, abort_reason: null,
                    cadence: null, is_curvilinear: false, a_opt: null, ce_range: [0,0],
                    pcr_store: null, accumulated_o2_deficit: null, pHm: null, mpa: [],
                    strain_rates: [], strain_rates_cp: [], strain_rates_wprime: [],
                    strain_rates_pmax: [], cumulative_strain_score: [], pmax: 0
                };
            }
            const timePoints = powerData.time_s;
            let powerValues = [...powerData.power];

            // Scale power values based on power scale (0-200%)
            if (appState.power_scale !== 100) {
                const scaleFactor = appState.power_scale / 100;
                powerValues = powerValues.map(p => p * scaleFactor);
            }

            // Extract cadence data if available
            let cadenceValues = null;
            if (appState.cadence_dependent_step && powerData.cadence && appState.use_file_cadence) {
                cadenceValues = [...powerData.cadence];
                // Fill any null values with the fixed cadence value
                cadenceValues = cadenceValues.map(c => (c === null || isNaN(c)) ? appState.cadence_step : c);
            }

            // Smooth power values if selected
            if (appState.smooth_power && powerValues.length >= 15) {
                powerValues = smoothData(powerValues, 15);
                // Replace NaN values at beginning and end after smoothing
                const naIndices = powerValues.map((v, i) => isNaN(v) ? i : null).filter(i => i !== null);
                if (naIndices.length > 0) {
                    const firstValidIdx = powerValues.findIndex(v => !isNaN(v));
                    const lastValidIdx = powerValues.map((v, i) => !isNaN(v) ? i : null).filter(i => i !== null).pop();
                    // Ensure valid indices exist before assigning
                    const firstVal = (firstValidIdx !== -1) ? powerValues[firstValidIdx] : 0; // Default to 0 if no valid value found
                    const lastVal = (lastValidIdx !== -1) ? powerValues[lastValidIdx] : 0;   // Default to 0 if no valid value found
                    for (const i of naIndices) {
                        powerValues[i] = (i < firstValidIdx) ? firstVal : lastVal;
                    }
                }
                // Smooth cadence values if available
                if (cadenceValues) {
                    cadenceValues = smoothData(cadenceValues, 10); // Use 10-point window for cadence
                    // Replace NaN values for cadence
                    const naCadenceIndices = cadenceValues.map((v, i) => isNaN(v) ? i : null).filter(i => i !== null);
                    if (naCadenceIndices.length > 0) {
                        const firstValidCadIdx = cadenceValues.findIndex(v => !isNaN(v));
                        const lastValidCadIdx = cadenceValues.map((v, i) => !isNaN(v) ? i : null).filter(i => i !== null).pop();
                        // Ensure valid indices exist before assigning
                        const firstCadVal = (firstValidCadIdx !== -1) ? cadenceValues[firstValidCadIdx] : appState.cadence_step; // Default to fixed cadence
                        const lastCadVal = (lastValidCadIdx !== -1) ? cadenceValues[lastValidCadIdx] : appState.cadence_step;   // Default to fixed cadence
                        for (const i of naCadenceIndices) {
                            cadenceValues[i] = (i < firstValidCadIdx) ? firstCadVal : lastCadVal;
                        }
                    }
                }
            }

            // Arrays to store time-dependent effective parameters
            const effectiveCEVO2 = new Array(timePoints.length);
            const effectiveVO2Base = new Array(timePoints.length);
            const effectiveVLamax_input = new Array(timePoints.length); // vLamax before pH adjustment
            const effectiveVO2max = new Array(timePoints.length);

            // Calculate cadence-dependent parameters *before* the main loop
            for (let i = 0; i < timePoints.length; i++) {
                if (appState.cadence_dependent_step) {
                    // Use cadence from file or fixed value, ensure it's a number
                    const currentCadence = (cadenceValues && appState.use_file_cadence && cadenceValues[i] !== null && !isNaN(cadenceValues[i])) ?
                        cadenceValues[i] : appState.cadence_step;

                    effectiveCEVO2[i] = calculateCadenceDependentCEVO2(currentCadence);
                    effectiveVO2Base[i] = calculateCadenceDependentVO2Base(currentCadence);

                    if (appState.vlamax_dependent_step) {
                        effectiveVLamax_input[i] = calculateCadenceDependentVLamax(currentCadence);
                    } else {
                        effectiveVLamax_input[i] = vLamax_base; // Use the base value from state
                    }

                    if (appState.vo2max_dependent_step) {
                        effectiveVO2max[i] = calculateCadenceDependentVO2max(currentCadence, VO2max);
                    } else {
                        effectiveVO2max[i] = VO2max;
                    }
                } else {
                    // If cadence dependency not enabled, use fixed values
                    effectiveCEVO2[i] = CE;
                    effectiveVO2Base[i] = VO2Base;
                    effectiveVLamax_input[i] = vLamax_base; // Use base value from state
                    effectiveVO2max[i] = VO2max;
                }
            }

            // Constants
            const CELaO2 = 0.02049 / body_mass;
            const VolLa = 0.4;
            const ks1 = 0.0635; // ADP^2 dependency for VO2ss
            const ks2 = Math.pow(1.1, 3); // ADP^3 dependency for vLass (original Mader)
            // Parameter für Laktat-Clearance-Bonus-VO2 (können später angepasst/kalibriert werden)
            const lactateClearanceVo2FactorY = 30.0;   // ml O2/min pro (mmol/L Laktat über Base)
            const maxLactateBonusVo2PercentOfBase = 5.00; // Max Bonus als % des aktuellen Ruhe-VO2 (effectiveVO2Base[i])
            const beta_O2_lactate_equiv = 3.0; // ml O2 / kg Körpermasse / mM Blutlaktatänderung

            // Simulation parameters
            const vo2UpTimeConstant = appState.vo2_up_time_constant;
            const laMax = appState.la_max;
            const laBase = appState.la_base;
            const vo2_delay_steps = Math.max(0, appState.vo2_delay); // Delay in integer steps (seconds)
            const vlass_delay_steps = Math.max(0, appState.vlass_delay); // Delay in integer steps (seconds)


            // Calculate VO2 target values with curvilinear option
            // This loop now calculates vo2Demand_power_only and initial vo2Target
            const vo2Demand_power_only = new Array(timePoints.length); // I.1. V̇O₂ Demand for Power Only
            const vo2Target = new Array(timePoints.length); // Will be updated iteratively for slow component

            let aOpt = null;

            // Calculate a coefficient if curvilinear is used
            if (isCurvilinear) {
                // Use potentially cadence-dependent Base/Max for the *first* time step for aOpt calculation
                const baseVO2_for_aOpt = effectiveVO2Base[0];
                const maxVO2_for_aOpt = effectiveVO2max[0];
                aOpt = findOptimalA(CE_range[0], CE_range[1], maxVO2_for_aOpt, baseVO2_for_aOpt);
            }

            for (let i = 0; i < timePoints.length; i++) {
                let vo2ss_power_only;
                const currentPower = powerValues[i] !== undefined ? powerValues[i] : 0; // Ensure power value exists
                const currentEffBase = effectiveVO2Base[i];
                const currentEffCE = effectiveCEVO2[i];
                const currentEffMax = effectiveVO2max[i];

                if (isCurvilinear && aOpt !== null) {
                    vo2ss_power_only = aOpt * Math.pow(currentPower, 2) + CE_range[0] * currentPower + currentEffBase;
                } else {
                    vo2ss_power_only = currentEffCE * currentPower + currentEffBase;
                }
                vo2Demand_power_only[i] = vo2ss_power_only; // Store unlimited demand for power only
                vo2Target[i] = Math.min(vo2ss_power_only, currentEffMax); // Initial target, will be updated by slow comp.
            }

            // Initialize main simulation arrays
            const vo2Actual = [appState.vo2_start];
            // Array to store the V̇O₂ cost of the slow component for each step
            const excess_lactic_o2_cost_ml_min_for_slow_comp = new Array(timePoints.length).fill(0); // I.3
            // Array to store the total V̇O₂ demand including the slow component
            let previous_actual_o2_cost_slow_comp_ml_min = 0;
            const TAU_SLOW_COMP_O2_COST_ON = 120;  // Example: 90s for "on" kinetics
            const TAU_SLOW_COMP_O2_COST_OFF = 120; // Example: 120s for "off" kinetics (can be same as old or different)
            const LACTATE_TO_SLOW_COMPONENT_VO2_FACTOR_PER_KG_ACTIVE_MUSCLE = 2.01; // ml O2/min PER KG ACTIVE MUSCLE per mmol/l La above base - 1.21 - Startwert!
            const LACTATE_CLEARANCE_VO2_FACTOR_PER_KG_ACTIVE_MUSCLE = 2.01; // ml O2/min PER KG ACTIVE MUSCLE pro mmol/l La für Clearance - 1.00 - Startwert!
    
            const totalVo2DemandWithSlowComp = [...vo2Demand_power_only]; 
            // I.4. Initialize with power_only demand
            // This will be updated iteratively.
            const total_excess_energy_o2_eq_ml_min_array = new Array(timePoints.length).fill(0); // III. New plot trace

            const vLassActual = [0]; // Actual lactate production rate (mmol/L muscle water/s) after all caps
            // Target for vLass kinetics (mmol/L/s), after boost, before delay, before pH cap.
            // Stored in an array to handle the vlass_delay correctly for the 'on' phase.
            const vLassTarget_for_kinetics_after_boost = [0];
            const vLaoxActual_s = [(CELaO2 * vo2Actual[0]) / (VolLa * 60)]; // Initial vLaox (mmol/l/s)
            const LaConc = [laBase]; // Lactate concentration in muscle (mmol/l)
            const LaConc_b = [laBase]; // Array for blood lactate concentration (mmol/l)
            const hrActual = [HR_Base]; // Start HR at HR_Base
            const pcrStore = []; // PCr concentration (mmol/kg ww)
            const pcrResynthesisFactor = 1.00;
            const accumulatedO2Deficit = []; // Accumulated O2 deficit (ml) - based on power_only_demand
            const glycogenStore = []; // Glycogen store (g)
            const carbGramMin = []; // Store CHO usage rate (g/min)
            const fatGramMin = []; // Store FAT usage rate (g/min)
            const pHm = []; // Array for muscle pH
            const vLass_uninhibited_by_pH_max_cap_s = [0]; // NEW: vLass after kinetics but before final pH-max-cap (mmol/L/s)
            const vLass_reduction_due_to_pH_s = [0]; // NEW: Reduction in vLass due to pH-max-cap (mmol/L/s)
            const Pi_est = []; // Array for estimated Pi (mmol/kg ww)
            const pCO2_est = []; // Array for estimated pCO2 (mmHg)
            const rqActual = []; // Array for kinetically smoothed RQ
            const dynamic_ATP_yield_kJ_mol_values = []; // Array to store dynamic ATP yield
            let totalAlacticEnergy_kJ_from_loop = 0;
            let totalLacticEnergy_kJ_from_loop = 0;
            const rqPredictedScaled = [];
            const net_pcr_change_mmol_kg_array = [];
            const o2_equiv_gross_lactate_ml_array = [];
            const net_lactic_energy_kj_interval_array = []; // Stores kJ from net muscle lactate accumulation per interval

            // pH calculation constants
            const dbuff = 0.0185; // Buffer coefficient (mmol/l/pH)
            const Pi_min = 3.0;   // Resting Pi (mmol/kg ww)
            const Pi_max = 25.0;  // Max Pi near exhaustion (mmol/kg ww)
            const PCr_max_for_ph_calc = appState.pcr_init; // User-set initial PCr (use a distinct name to avoid conflict if appState.pcr_init changes)
            const PCr_min_for_ph_calc = 2.0;  // Assumed minimum PCr near exhaustion

            // PFK activity factor constants
            const pH_base_pfk = 7.05; // Reference pH for ~100% PFK activity
            const pH_50_pfk = 6.75;   // Approx. pH for 50% PFK inhibition
            const Hill_n_pH_pfk = 3.5;  // Hill coefficient for pH inhibition

            // Initialize values for the first time point (t=0) 
            pcrStore[0] = appState.pcr_init;
            accumulatedO2Deficit[0] = Math.max(0, vo2Demand_power_only[0] - vo2Actual[0]) * ( (timePoints.length > 0 && timePoints[0] !== undefined) ? (timePoints[0] / 60) : 0 ); // Initial deficit

            // Initial pHm calculation
            let initial_Pi_for_ph = Pi_min;
            const initial_pcr_range_for_ph = PCr_max_for_ph_calc - PCr_min_for_ph_calc;
            if (initial_pcr_range_for_ph > 0) {
                initial_Pi_for_ph = Pi_min + (Pi_max - Pi_min) * Math.max(0, PCr_max_for_ph_calc - pcrStore[0]) / initial_pcr_range_for_ph;
                initial_Pi_for_ph = Math.min(Pi_max, Math.max(Pi_min, initial_Pi_for_ph));
            }
            Pi_est[0] = initial_Pi_for_ph;

            let initial_Lam_for_ph = laBase;
            let initial_VO2_for_ph = vo2Actual[0];
            let initial_effVO2max_for_ph = effectiveVO2max[0];
            let initial_vo2Ratio_for_ph = initial_effVO2max_for_ph > 0 ? initial_VO2_for_ph / initial_effVO2max_for_ph : 0;
            let initial_pCO2_for_ph = Math.max(40, Math.min(80, 40 + 55 * initial_vo2Ratio_for_ph));
            pCO2_est[0] = initial_pCO2_for_ph;

            let initial_logArg_for_ph = Math.max(1e-9, initial_pCO2_for_ph);
            let initial_pH_calc = 7.85 + dbuff * (0.8 * initial_Pi_for_ph - initial_Lam_for_ph) - 0.55 * Math.log10(initial_logArg_for_ph);
            pHm[0] = Math.max(6.0, Math.min(7.4, initial_pH_calc));

            glycogenStore[0] = appState.glycogen_init;
            carbGramMin[0] = 0;
            fatGramMin[0] = 0;
            const initialCarbPerc_for_RQ = 0;
            const initialRQ = calculateRQ(initialCarbPerc_for_RQ);
            rqActual[0] = initialRQ;
            rqPredictedScaled[0] = initialRQ * 10;

            // Initial dynamic_ATP_yield_kJ_mol_values[0] calculation
            let initial_ATP_YIELD_MAX_effective_t0;
            let initial_ATP_YIELD_MIN_effective_t0;
            const initial_pHm_for_yield_t0 = pHm[0];

            if (initial_pHm_for_yield_t0 >= PH_REF_OPTIMAL) {
                if (initial_pHm_for_yield_t0 >= PH_REF_VERY_HIGH) {
                    initial_ATP_YIELD_MAX_effective_t0 = ATP_YIELD_MAX_pH74;
                    initial_ATP_YIELD_MIN_effective_t0 = ATP_YIELD_MIN_pH74;
                } else {
                    const pH_fraction_t0 = (initial_pHm_for_yield_t0 - PH_REF_OPTIMAL) / (PH_REF_VERY_HIGH - PH_REF_OPTIMAL);
                    initial_ATP_YIELD_MAX_effective_t0 = ATP_YIELD_MAX_pH70 + pH_fraction_t0 * (ATP_YIELD_MAX_pH74 - ATP_YIELD_MAX_pH70);
                    initial_ATP_YIELD_MIN_effective_t0 = ATP_YIELD_MIN_pH70 + pH_fraction_t0 * (ATP_YIELD_MIN_pH74 - ATP_YIELD_MIN_pH70);
                }
            } else {
                if (initial_pHm_for_yield_t0 <= PH_REF_ACIDIC) {
                    initial_ATP_YIELD_MAX_effective_t0 = ATP_YIELD_MAX_pH60;
                    initial_ATP_YIELD_MIN_effective_t0 = ATP_YIELD_MIN_pH60;
                } else {
                    const pH_fraction_t0 = (initial_pHm_for_yield_t0 - PH_REF_ACIDIC) / (PH_REF_OPTIMAL - PH_REF_ACIDIC);
                    initial_ATP_YIELD_MAX_effective_t0 = ATP_YIELD_MAX_pH60 + pH_fraction_t0 * (ATP_YIELD_MAX_pH70 - ATP_YIELD_MAX_pH60);
                    initial_ATP_YIELD_MIN_effective_t0 = ATP_YIELD_MIN_pH60 + pH_fraction_t0 * (ATP_YIELD_MIN_pH70 - ATP_YIELD_MIN_pH60);
                }
            }
            const initial_pcr_fraction_t0 = Math.max(0, Math.min(1, pcrStore[0] / appState.pcr_init));
            dynamic_ATP_yield_kJ_mol_values[0] = initial_ATP_YIELD_MIN_effective_t0 + initial_pcr_fraction_t0 * (initial_ATP_YIELD_MAX_effective_t0 - initial_ATP_YIELD_MIN_effective_t0);

            // New/modified t=0 initializations
            excess_lactic_o2_cost_ml_min_for_slow_comp[0] = 0;
            // totalVo2DemandWithSlowComp[0] is already initialized from vo2Demand_power_only[0]
            vo2Target[0] = Math.min(totalVo2DemandWithSlowComp[0], effectiveVO2max[0]); // Update vo2Target for t=0
            total_excess_energy_o2_eq_ml_min_array[0] = 0;
            net_pcr_change_mmol_kg_array[0] = 0;
            o2_equiv_gross_lactate_ml_array[0] = 0;

            // Abort tracking variables
            let endIdx = timePoints.length;
            let abortIdx = null;
            let abortPower = null;
            let abortTime = null;
            let abortReason = null;

            // Initialize W' Balance related calculations
            const cp = appState.critical_power;
            const wprime = appState.w_prime;
            const wprimeBalance = [wprime * 1000]; // Start with full W' in Joules
            const mpaValues = [appState.pmax]; // Start with Pmax
            const strainRates = [0];
            const strainRatesCP = [0];
            const strainRatesWprime = [0];
            const strainRatesPmax = [0];
            const cumulativeStrainScore = [0];

            // Main Simulation Loop
            for (let i = 1; i < timePoints.length; i++) {
                const deltaT = timePoints[i] - timePoints[i - 1];
                // Dynamic ATP Yield Calculation for current interval i ---
                let current_ATP_YIELD_MAX_effective;
                let current_ATP_YIELD_MIN_effective;
                const current_pHm_for_yield = pHm[i-1]; // pH at the start of the interval

                if (current_pHm_for_yield >= PH_REF_OPTIMAL) { // pH >= 7.0
                    if (current_pHm_for_yield >= PH_REF_VERY_HIGH) { // pH >= 7.4
                        current_ATP_YIELD_MAX_effective = ATP_YIELD_MAX_pH74;
                        current_ATP_YIELD_MIN_effective = ATP_YIELD_MIN_pH74;
                    } else { // 7.0 <= pH < 7.4
                        const pH_fraction = (current_pHm_for_yield - PH_REF_OPTIMAL) / (PH_REF_VERY_HIGH - PH_REF_OPTIMAL);
                        current_ATP_YIELD_MAX_effective = ATP_YIELD_MAX_pH70 + pH_fraction * (ATP_YIELD_MAX_pH74 - ATP_YIELD_MAX_pH70);
                        current_ATP_YIELD_MIN_effective = ATP_YIELD_MIN_pH70 + pH_fraction * (ATP_YIELD_MIN_pH74 - ATP_YIELD_MIN_pH70);
                    }
                } else { // pH < 7.0
                    if (current_pHm_for_yield <= PH_REF_ACIDIC) { // pH <= 6.0
                        current_ATP_YIELD_MAX_effective = ATP_YIELD_MAX_pH60;
                        current_ATP_YIELD_MIN_effective = ATP_YIELD_MIN_pH60;
                    } else { // 6.0 < pH < 7.0
                        const pH_fraction = (current_pHm_for_yield - PH_REF_ACIDIC) / (PH_REF_OPTIMAL - PH_REF_ACIDIC);
                        current_ATP_YIELD_MAX_effective = ATP_YIELD_MAX_pH60 + pH_fraction * (ATP_YIELD_MAX_pH70 - ATP_YIELD_MAX_pH60);
                        current_ATP_YIELD_MIN_effective = ATP_YIELD_MIN_pH60 + pH_fraction * (ATP_YIELD_MIN_pH70 - ATP_YIELD_MIN_pH60);
                    }
                }

                const pcr_at_interval_start = (i > 0 && pcrStore[i-1] !== undefined) ? pcrStore[i-1] : appState.pcr_init;
                const pcr_fraction = Math.max(0, Math.min(1, pcr_at_interval_start / appState.pcr_init));
                dynamic_ATP_yield_kJ_mol_values[i] = current_ATP_YIELD_MIN_effective + pcr_fraction * (current_ATP_YIELD_MAX_effective - current_ATP_YIELD_MIN_effective);
                // --- END: Dynamic ATP Yield Calculation ---

                if (deltaT <= 0) { // Handle duplicate or non-increasing time points
                    vo2Actual.push(vo2Actual[i - 1]);
                    vLassActual.push(vLassActual[i - 1]);
                    vLassTarget_effective.push(vLassTarget_effective[i - 1]);
                    vLaoxActual_s.push(vLaoxActual_s[i - 1]);
                    LaConc.push(LaConc[i - 1]);
                    hrActual.push(hrActual[i-1]); // START: Carry over HR
                    pcrStore.push(pcrStore[i - 1]); // <<< Carry over
                    net_pcr_change_mmol_kg_array.push(pcrStore[i-1] - pcrStore[i]); // Verbrauch ist positiv, Resynthese negativ
                    accumulatedO2Deficit.push(accumulatedO2Deficit[i - 1]); // <<< Carry over
                    pHm.push(pHm[i - 1]);       // <<< Carry over pH
                    Pi_est.push(Pi_est[i - 1]);   // <<< Carry over Pi
                    pCO2_est.push(pCO2_est[i - 1]); // <<< Carry over pCO2
                    glycogenStore.push(glycogenStore[i - 1]);
                    carbGramMin.push(carbGramMin[i - 1]);
                    fatGramMin.push(fatGramMin[i - 1]);
                    wprimeBalance.push(wprimeBalance[i-1]);
                    mpaValues.push(mpaValues[i-1]);
                    strainRates.push(0);
                    strainRatesCP.push(0);
                    strainRatesWprime.push(0);
                    strainRatesPmax.push(0);
                    cumulativeStrainScore.push(cumulativeStrainScore[i-1]);
                    tau_off_values.push(tau_off_values[i-1] !== undefined ? tau_off_values[i-1] : tau_off_slider_value);
                    continue;
                }

                            // --- START: Determine current Tau_On and Tau_Off ---
                        let current_tau_on;
                        let current_tau_off;

                        // --- Tau_On Calculation ---
                        if (!use_dynamic_tau_on) {
                            current_tau_on = tau_on_slider_value; // Fester Wert vom Slider
                        } else {
                            let intensity_percent_prev = 0;
                            if (i > 0 && vo2Actual[i-1] !== undefined && effectiveVO2max[i-1] !== undefined) {
                                const prevEffVO2max_for_tau = effectiveVO2max[i-1] > 0 ? effectiveVO2max[i-1] : 1; // Division durch Null vermeiden
                                intensity_percent_prev = Math.max(0, Math.min(100, (vo2Actual[i-1] / prevEffVO2max_for_tau) * 100));
                            }

                            let tau_on_from_formula;

                            if (intensity_percent_prev <= 33.33333333) {
                                current_tau_on = 15; // Bleibt bei 15s bis zu einem Drittel der Intensität
                            } else if (intensity_percent_prev <= 75) {
                                // Linearer Anstieg von 15s (bei 33.33%) auf 30s (bei 75%)
                                tau_on_from_formula = 0.36 * intensity_percent_prev + 3.00;
                                current_tau_on = Math.round(Math.max(6, tau_on_from_formula + tau_on_adjustment));
                            } else {
                                // Linearer Anstieg von 30s (bei 75%) auf 50s (bei 100%)
                                tau_on_from_formula = 0.6 * intensity_percent_prev - 30.00; // 0.6 für 45s und 0.8 für 50s bei 100% und 1.0 / 1.2 für 55 / 60 Sekunden
                                current_tau_on = Math.round(Math.max(6, tau_on_from_formula + tau_on_adjustment));
                            }
                        }

                        // --- Tau_Off Calculation ---
                        if (!use_dynamic_tau_off) {
                            current_tau_off = tau_off_slider_value; // Fixed value from slider
                        } else {
                            // Dynamic calculation based on max intensity in lookback window
                            const tau_off_prev = (i > 1 && tau_off_values.length > i-1 && tau_off_values[i-1] !== undefined) ? tau_off_values[i-1] : tau_off_slider_value;
                            const lookback_duration = 2 * tau_off_prev; // Use previous tau_off for window size
                            const lookback_start_time = Math.max(timePoints[0], timePoints[i-1] - lookback_duration);
                            const lookback_end_time = timePoints[i-1];

                            let max_vo2_in_window = 0;
                            let intensity_percent_off = 0;
                            let found_max_off = false;

                            for (let j = i - 1; j >= 0; j--) {
                                if (timePoints[j] < lookback_start_time) break;
                                if (timePoints[j] <= lookback_end_time) {
                                    if (vo2Actual[j] !== undefined) {
                                        max_vo2_in_window = Math.max(max_vo2_in_window, vo2Actual[j]);
                                        found_max_off = true;
                                    }
                                }
                            }

                            if (found_max_off) {
                                const currentEffVO2max_for_tau_off = effectiveVO2max[i] > 0 ? effectiveVO2max[i] : 1;
                                intensity_percent_off = Math.max(0, Math.min(100, (max_vo2_in_window / currentEffVO2max_for_tau_off) * 100));
                            } else if (i > 0 && vo2Actual[i-1] !== undefined) {
                                const currentEffVO2max_for_tau_off = effectiveVO2max[i] > 0 ? effectiveVO2max[i] : 1;
                                intensity_percent_off = Math.max(0, Math.min(100, (vo2Actual[i-1] / currentEffVO2max_for_tau_off) * 100));
                            }

                            const tau_off_from_formula = 0.45 * intensity_percent_off + 10;
                            current_tau_off = Math.round(Math.max(10, tau_off_from_formula + tau_off_adjustment));
                        }
                        tau_off_values.push(current_tau_off); // Store calculated tau_off for next iteration's lookback
                        // --- END: Determine current Tau_On and Tau_Off ---


                        // --- VO2 Kinetics ---
                        const currentVo2_total = vo2Actual[i - 1];
                        const baseVO2_current = effectiveVO2Base[i];
                        const maxVO2_current = effectiveVO2max[i];
                        const delay_idx_vo2 = Math.max(0, i - vo2_delay_steps);

                        // -- Modifikation des Ziel-V̇O₂ für Laktat-Clearance --
                        // effective_target_vo2 ist das Ziel, auf das die Exponentialfunktion hinarbeitet.
                        // Starte mit dem V̇O₂-Ziel, das rein auf der aktuellen Leistung basiert.
                        let effective_target_vo2 = vo2Target[delay_idx_vo2]; 

                        const lactate_current = LaConc[i - 1]; // Laktat zu Beginn des aktuellen Intervalls
                        const lactate_above_base = Math.max(0, lactate_current - laBase); // Laktat über Base (mind. 0)
                        
                        // Bestimme, ob eine "OFF-Phase" für die Anwendung des Bonus vorliegt.
                        // Dies ist der Fall, wenn das reine Leistungs-V̇O₂-Ziel unter dem aktuellen tatsächlichen V̇O₂ liegt.
                        const is_off_phase_for_bonus = (vo2Target[delay_idx_vo2] < currentVo2_total);

                                                // Apply the bonus ONLY if it's an "off-phase" AND lactate is elevated AND power is relatively low
                        // Determine a "recovery intensity" threshold, e.g., 70% of MLSS power.
                        // MLSS power (pdZeroPos) is from Tab 1 calculations, so make sure it's available.
                        // If mlss_value is not available (e.g., Tab 1 not run or error), use a fallback or skip this condition.
                        let recovery_power_threshold = appState.mlss_value ? (appState.mlss_value * 0.70) : 100; // Fallback to 100W if MLSS unknown

                        if (is_off_phase_for_bonus && lactate_above_base > 0 && powerValues[i] < recovery_power_threshold) {
                            // Calculate potential bonus directly proportional to lactate difference
                             const current_active_muscle_mass_for_bonus = appState.active_muscle_mass; // Use the same as for slow component
                            let potential_vo2_bonus = 0;
                            if (current_active_muscle_mass_for_bonus > 0) {
                                potential_vo2_bonus = lactate_above_base * 
                                                    LACTATE_CLEARANCE_VO2_FACTOR_PER_KG_ACTIVE_MUSCLE * 
                                                    current_active_muscle_mass_for_bonus;
                            }

                            // Limit the bonus to a percentage of the *current* effective resting V̇O₂ (can still be useful as an overall cap)
                            const current_effective_base_vo2 = effectiveVO2Base[i]; 
                            const bonus_limit_from_base = current_effective_base_vo2 * maxLactateBonusVo2PercentOfBase; 
                            
                            // Limit the bonus also to a fraction of VO2max to prevent unrealistic values, e.g., max 20% of VO2max
                            const bonus_limit_from_vo2max = effectiveVO2max[i] * 0.20; 

                            const actual_bonus = Math.min(potential_vo2_bonus, bonus_limit_from_base, bonus_limit_from_vo2max);
                            
                            effective_target_vo2 = vo2Target[delay_idx_vo2] + actual_bonus;
                        }
                        // ELSE: If conditions for bonus are not met (e.g., power is too high),
                        // effective_target_vo2 remains as vo2Target[delay_idx_vo2] (which is based on totalVo2DemandWithSlowComp)

                        // Sicherstellen, dass das (ggf. modifizierte) Ziel die physiologischen Grenzen nicht sprengt
                        effective_target_vo2 = Math.min(effective_target_vo2, effectiveVO2max[i]); // Nicht über aktuellem V̇O₂max
                        effective_target_vo2 = Math.max(effective_target_vo2, effectiveVO2Base[i]); // Nicht unter aktuellem V̇O₂base
                        
                        // Berechne overall_target_diff mit dem (potenziell für Bonus modifizierten) Ziel-V̇O₂
                        const overall_target_diff = effective_target_vo2 - currentVo2_total;  

                        // Use calculated tau_on or tau_off based on direction of change
                        const timeConstant = (overall_target_diff >= 0) ? current_tau_on : current_tau_off;
                        const effectiveTimeConstant = Math.max(1, timeConstant); // Ensure time constant is at least 1s
                        // NEUE LOGIK für V̇O₂-Änderung:
                        let nextVo2;
                        if (overall_target_diff >= 0) { // ON-Kinetics (oder kein Unterschied)
                            const timeConstant = current_tau_on; // current_tau_on wird bereits korrekt oben berechnet
                            const effectiveTimeConstant = Math.max(1, timeConstant);
                            const vo2Change = overall_target_diff * (1 - Math.exp(-deltaT / effectiveTimeConstant));
                            nextVo2 = currentVo2_total + vo2Change;
                        } else { // OFF-Kinetics (overall_target_diff < 0)
                        // Die Zeitkonstante wird normal bestimmt (Slider oder dynamisch)
                        const timeConstant = current_tau_off; // current_tau_off wird korrekt oben berechnet
                        const effectiveTimeConstant = Math.max(1, timeConstant);

                        // Berechne die Änderung basierend auf dem (ggf. Laktat-modifizierten) Ziel
                        const vo2Change = overall_target_diff * (1 - Math.exp(-deltaT / effectiveTimeConstant)); // overall_target_diff ist negativ

                        nextVo2 = currentVo2_total + vo2Change;
                    }
                        const vo2_constrained = Math.min(maxVO2_current, Math.max(baseVO2_current * 0.8, nextVo2));
                        vo2Actual.push(vo2_constrained);

                // HR Kinetics ---
                const hrTargetSteadyState = CE_HR * powerValues[i] + HR_Base; // Target HR for current power
                const hrTargetLimited = Math.min(hrTargetSteadyState, HR_max); // Cap at HR_max
                
                const hrDiff = hrTargetLimited - hrActual[i-1];
                const tau_hr = hrDiff >= 0 ? TAU_HR_ON : TAU_HR_OFF;
                
                const hrChange = hrDiff * (1 - Math.exp(-deltaT / Math.max(1, tau_hr))); // Ensure tau_hr is at least 1
                let nextHr = hrActual[i-1] + hrChange;
                nextHr = Math.min(HR_max, Math.max(HR_Base * 0.8, nextHr)); // Constrain HR
                hrActual.push(nextHr);       

                // --- vLass Kinetics (pH dependent) and Capping ---
                const last_pHm_for_vLass = pHm[i-1]; // pH from previous step to determine PFK activity for current step

                // I.2.a. Determine vLamax_uninhibited_for_step_i (base vLamax from tab/settings, possibly cadence-adjusted)
                const vLamax_uninhibited_for_step_i = effectiveVLamax_input[i];

                // I.2.a. Calculate pH-dependent PFK activity factor
                const H_plus_current_pfk_vLass = Math.pow(10, -last_pHm_for_vLass);
                const H_plus_50_pfk_vLass = Math.pow(10, -pH_50_pfk); // pH_50_pfk is a global constant from initialization
                let pfk_inhibition_factor_vLass = 1.0;
                if (H_plus_50_pfk_vLass > 1e-9) { // Avoid division by zero
                    pfk_inhibition_factor_vLass = 1 / (1 + Math.pow(H_plus_current_pfk_vLass / H_plus_50_pfk_vLass, Hill_n_pH_pfk)); // Hill_n_pH_pfk is global
                }
                const pfk_activity_factor_for_vLass = Math.max(0.01, Math.min(1.1, pfk_inhibition_factor_vLass));

                // I.2.a. Determine pH-inhibited vLa_max_eff_current_step_for_i
                const vLa_max_eff_current_step_for_i = vLamax_uninhibited_for_step_i * pfk_activity_factor_for_vLass;
                // This vLa_max_eff_current_step_for_i is the ultimate ceiling for vLassActual[i] due to pH.

                // I.2.b.i. Target for vLassActual Kinetics (Mader model part)
                // Based on vo2Actual[i] (actual uptake of current step) and UNINHIBITED vLamax for current step (i).
                const vo2_input_for_vLass_target_mader = vo2Actual[i]; // Use current actual V̇O₂
                const maxVO2_for_vLass_target_mader = effectiveVO2max[i]; // Max VO2 for current step
                let vLass_target_mader_model_part = 0;
                if (vo2_input_for_vLass_target_mader > 0 && ks1 > 0) { // ks1 is a global constant
                    const vo2_term_vLass_target = Math.max(0, (maxVO2_for_vLass_target_mader - vo2_input_for_vLass_target_mader) / (ks1 * vo2_input_for_vLass_target_mader));
                    const power_base_vLass_target = Math.max(0, vo2_term_vLass_target);
                    vLass_target_mader_model_part = vLamax_uninhibited_for_step_i / (1 + ks2 * Math.pow(power_base_vLass_target, 3/2)); // ks2 is global
                }
                let target_vLass_for_kinetics_pre_delay = vLass_target_mader_model_part;

                // I.2.b.ii. Apply "Boost vLaSS by V̇O₂ Deficit" if active
                if (appState.boost_vlass_by_deficit) {
                    // O2 deficit for boost is based on power-only demand vs actual uptake for the *current* step i
                    const o2_deficit_rate_ml_min_for_boost = Math.max(0, vo2Demand_power_only[i] - vo2Actual[i]);

                    if (o2_deficit_rate_ml_min_for_boost > 0) {
                        const o2_deficit_ml_per_sec_for_boost = o2_deficit_rate_ml_min_for_boost / 60.0;
                        const kJ_per_L_O2_aerobic_CHO_boost = getKalorischesEquivalent(1.0).kJ_lO2;
                        const energy_deficit_kJ_per_sec_boost = (o2_deficit_ml_per_sec_for_boost / 1000.0) * kJ_per_L_O2_aerobic_CHO_boost;
                        
                        // dynamic_ATP_yield_kJ_mol_values[i] uses pHm[i-1] and pcrStore[i-1] via its calculation at start of loop i
                        const ATP_needed_to_cover_deficit_mmol_per_sec_boost = (energy_deficit_kJ_per_sec_boost / (dynamic_ATP_yield_kJ_mol_values[i] / 1000.0));
                        const lactate_to_produce_for_ATP_mmol_per_sec_boost = ATP_needed_to_cover_deficit_mmol_per_sec_boost / ATP_PER_LACTATE_FROM_GLYCOGEN;
                        
                        let additional_vLass_target_s_boost = 0;
                        if (Vm > 1e-6) { // Vm is muscle water volume
                            additional_vLass_target_s_boost = lactate_to_produce_for_ATP_mmol_per_sec_boost / Vm;
                        }
                        
                        target_vLass_for_kinetics_pre_delay += (appState.vlass_boost_factor * additional_vLass_target_s_boost);
                        // Cap boosted target at the uninhibited vLamax for the step
                        target_vLass_for_kinetics_pre_delay = Math.min(target_vLass_for_kinetics_pre_delay, vLamax_uninhibited_for_step_i);
                    }
                }
                vLassTarget_for_kinetics_after_boost.push(target_vLass_for_kinetics_pre_delay); // Store this target

                // I.2.b.iii. Apply delay to the target for kinetics calculation
                const current_unDelayed_target_for_vLass_kinetics = vLassTarget_for_kinetics_after_boost[i]; // Target for current step i
                const delayed_target_for_vLass_onset = vLassTarget_for_kinetics_after_boost[Math.max(0, i - vlass_delay_steps)];
                let driving_target_vLass_for_kinetics;
                if (current_unDelayed_target_for_vLass_kinetics > vLassActual[i-1]) { // If target is to increase
                    driving_target_vLass_for_kinetics = delayed_target_for_vLass_onset;
                } else { // If target is to decrease or stay same
                    driving_target_vLass_for_kinetics = current_unDelayed_target_for_vLass_kinetics;
                }

                // I.2.c. Apply exponential kinetics
                const vLass_target_diff_for_kinetics = driving_target_vLass_for_kinetics - vLassActual[i-1];
                const timeConstant_vLass_kinetics = (vLass_target_diff_for_kinetics >= 0) ? Math.max(1, appState.vLass_on_tau) : Math.max(1, appState.vLass_off_tau);
                const vLass_change_from_kinetics = vLass_target_diff_for_kinetics * (1 - Math.exp(-deltaT / timeConstant_vLass_kinetics));
                let vLass_provisional_after_kinetics = vLassActual[i-1] + vLass_change_from_kinetics;
                vLass_provisional_after_kinetics = Math.max(0, vLass_provisional_after_kinetics);

                // I.2.c. Strictly cap by pH-inhibited vLa_max_eff_current_step_for_i
                const vLass_after_ph_cap_and_kinetics = Math.min(vLass_provisional_after_kinetics, vLa_max_eff_current_step_for_i);

                // NEW: Calculate and store vLass before the pH-max-cap and the reduction amount
                // vLass_provisional_after_kinetics is the vLass determined by kinetics,
                // based on a target that uses uninhibited vLamax.
                vLass_uninhibited_by_pH_max_cap_s.push(vLass_provisional_after_kinetics);

                // The reduction is the difference if vLass_provisional_after_kinetics exceeded the pH-imposed max rate.
                const vLass_reduction_this_step_s = Math.max(0, vLass_provisional_after_kinetics - vLass_after_ph_cap_and_kinetics);
                vLass_reduction_due_to_pH_s.push(vLass_reduction_this_step_s);

                // I.2.e. vLaoxActual_s[i] Calculation (based on vo2Actual[i]) - MODIFIED (Cap removed)
                let vLaox_current_s_for_step_i = (CELaO2 * vo2Actual[i]) / (VolLa * 60); 

                // Adjust vLaox_current_s_for_step_i if vLass was reduced by pH inhibition in this step
                // vLass_reduction_this_step_s was calculated earlier for the current step i.
                if (vLass_reduction_this_step_s > 0) {
                    vLaox_current_s_for_step_i = vLaox_current_s_for_step_i - vLass_reduction_this_step_s;
                }
                // Ensure vLaox is not negative after all adjustments
                vLaox_current_s_for_step_i = Math.max(0, vLaox_current_s_for_step_i); // Explicitly ensure non-negative before push
                vLaoxActual_s.push(vLaox_current_s_for_step_i);


                // I.2.d. Refined "Cap vLaSS by V̇O₂ Deficit" Option - MODIFIED
                let vLass_kinetics_and_pH_capped = vLass_after_ph_cap_and_kinetics; // This is vLass after kinetics and the primary pH cap from vLa_max_eff
                let final_vLassActual_for_step_i = vLass_kinetics_and_pH_capped; // Default to this value

                if (appState.cap_vlass_by_o2_deficit) {
                    const current_o2_deficit_ml_min_for_cap = Math.max(0, vo2Demand_power_only[i] - vo2Actual[i]);

                    if (current_o2_deficit_ml_min_for_cap > 0) { 
                        const kJ_per_L_O2_aerobic_CHO_cap = getKalorischesEquivalent(1.0).kJ_lO2;
                        const current_o2_deficit_kJ_per_sec_for_cap = (current_o2_deficit_ml_min_for_cap / 60.0 / 1000.0) * kJ_per_L_O2_aerobic_CHO_cap;
                        
                        let max_net_lactic_rate_allowed_by_deficit_s = 0;
                        const energy_conversion_factor_for_cap = Vm * ATP_PER_LACTATE_FROM_GLYCOGEN * (dynamic_ATP_yield_kJ_mol_values[i] / 1000.0);
                        if (energy_conversion_factor_for_cap > 1e-9) { 
                             max_net_lactic_rate_allowed_by_deficit_s = current_o2_deficit_kJ_per_sec_for_cap / energy_conversion_factor_for_cap;
                        }
                        max_net_lactic_rate_allowed_by_deficit_s = Math.max(0, max_net_lactic_rate_allowed_by_deficit_s);

                        const vLass_limit_imposed_by_deficit = vLaox_current_s_for_step_i + max_net_lactic_rate_allowed_by_deficit_s;

                        if (vLass_kinetics_and_pH_capped > vLass_limit_imposed_by_deficit) {
                            final_vLassActual_for_step_i = vLass_limit_imposed_by_deficit;
                        } else {
                            final_vLassActual_for_step_i = vLass_kinetics_and_pH_capped;
                        }
                    }
                }
                final_vLassActual_for_step_i = Math.max(0, final_vLassActual_for_step_i); // Ensure final vLass is not negative
                vLassActual.push(final_vLassActual_for_step_i);

                // --- NEW: Calculate Net Lactic Energy for Summary ---
                const net_muscle_lactate_production_rate_s_current_step = final_vLassActual_for_step_i - vLaox_current_s_for_step_i;
                let current_net_lactic_energy_kj_this_interval = 0;

                if (net_muscle_lactate_production_rate_s_current_step > 0) {
                    const net_lactate_produced_mmol_per_sec_muscle = net_muscle_lactate_production_rate_s_current_step * Vm;
                    const ATP_from_net_lactate_mmol_per_sec = net_lactate_produced_mmol_per_sec_muscle * ATP_PER_LACTATE_FROM_GLYCOGEN;
                    const energy_from_net_lactate_kJ_per_sec = ATP_from_net_lactate_mmol_per_sec * (dynamic_ATP_yield_kJ_mol_values[i] / 1000.0);
                    current_net_lactic_energy_kj_this_interval = energy_from_net_lactate_kJ_per_sec * deltaT;
                }
                net_lactic_energy_kj_interval_array.push(current_net_lactic_energy_kj_this_interval);
                // --- END NEW: Calculate Net Lactic Energy for Summary ---

            // I.3. Calculate Excess Lactic O₂ Cost (Slow Component Driver) for step i
    
            // 1. Calculate the vLass that would be expected if glycolysis was perfectly coupled
            //    to the V̇O₂ demand for power only, respecting the current pH-inhibited vLa_max.
            let vLass_expected_at_power_only_demand_s = 0;
            const denominator_vo2_power_only_demand = Math.max(1, vo2Demand_power_only[i]);
            if (denominator_vo2_power_only_demand > 0 && ks1 > 0) {
                const vo2_term_power_only = Math.max(0, (effectiveVO2max[i] - denominator_vo2_power_only_demand) / (ks1 * denominator_vo2_power_only_demand));
                const power_base_power_only = Math.max(0, vo2_term_power_only);
                // Start with uninhibited vLamax for this theoretical coupling
                vLass_expected_at_power_only_demand_s = vLamax_uninhibited_for_step_i / (1 + ks2 * Math.pow(power_base_power_only, 3/2));
            }
            // This expected rate is then capped by the actual pH-limited maximum glycolytic rate for the current step.
            const vLass_baseline_for_slow_comp_s = Math.min(vLass_expected_at_power_only_demand_s, vLa_max_eff_current_step_for_i);

            // 2. Calculate "truly excess" lactate production rate for step i.
            // This is the amount by which the actual (kinetically determined and capped) vLassActual[i]
            // exceeds this baseline rate (which is what's expected for the power demand under current pH conditions).
            const truly_excess_vLass_s_for_slow_comp = Math.max(0, vLassActual[i] - vLass_baseline_for_slow_comp_s);

            // 3. Convert truly_excess_vLass_s to O₂ equivalent (ml/min)
            let current_excess_lactic_o2_cost_ml_min = 0;
            if (truly_excess_vLass_s_for_slow_comp > 0) {
                const excess_lactate_produced_mmol_per_sec_slow_comp = truly_excess_vLass_s_for_slow_comp * Vm; // Vm is muscle water volume
                const ATP_from_excess_lactate_mmol_per_sec_slow_comp = excess_lactate_produced_mmol_per_sec_slow_comp * ATP_PER_LACTATE_FROM_GLYCOGEN;
                // dynamic_ATP_yield_kJ_mol_values[i] is based on pHm[i-1] and pcrStore[i-1]
                const energy_from_excess_lactate_kJ_per_sec_slow_comp = ATP_from_excess_lactate_mmol_per_sec_slow_comp * (dynamic_ATP_yield_kJ_mol_values[i] / 1000.0);
                
                const kJ_per_L_O2_aerobic_CHO_slow_comp_cost = getKalorischesEquivalent(1.0).kJ_lO2; // Assume CHO (RQ=1.0) for this cost
                if (kJ_per_L_O2_aerobic_CHO_slow_comp_cost > 0) {
                    const o2_equiv_L_per_sec_slow_comp_cost = energy_from_excess_lactate_kJ_per_sec_slow_comp / kJ_per_L_O2_aerobic_CHO_slow_comp_cost;
                    current_excess_lactic_o2_cost_ml_min = o2_equiv_L_per_sec_slow_comp_cost * 1000.0 * 60.0; // Convert L/s to ml/min
                }
            }
            excess_lactic_o2_cost_ml_min_for_slow_comp[i] = current_excess_lactic_o2_cost_ml_min;

            // I.4. Calculate Total V̇O₂ Demand for Step i and Update vo2Target[i]
            // --- V̇O₂ Slow Component driven by absolute muscle lactate concentration, scaled by active muscle mass ---
            if (i === 0) {
                totalVo2DemandWithSlowComp[i] = vo2Demand_power_only[i];
                excess_lactic_o2_cost_ml_min_for_slow_comp[i] = 0;
            } else {
                let target_o2_cost_from_absolute_lactate_ml_min = 0;
                const lactate_conc_previous_step = LaConc[i-1]; // Muscle lactate from end of previous step
                
                // Use active_muscle_mass from appState (this is set in Tab 2 controls)
                const current_active_muscle_mass_for_slow_comp = appState.active_muscle_mass; // Ensure this is correctly representing the exercising mass

                if (lactate_conc_previous_step > laBase && current_active_muscle_mass_for_slow_comp > 0) {
                    target_o2_cost_from_absolute_lactate_ml_min = 
                        (lactate_conc_previous_step - laBase) * 
                        LACTATE_TO_SLOW_COMPONENT_VO2_FACTOR_PER_KG_ACTIVE_MUSCLE * 
                        current_active_muscle_mass_for_slow_comp;
                }
                target_o2_cost_from_absolute_lactate_ml_min = Math.max(0, target_o2_cost_from_absolute_lactate_ml_min);

                // Kinetically adjust the actual O2 cost of the slow component for the current step
                const o2_cost_diff = target_o2_cost_from_absolute_lactate_ml_min - previous_actual_o2_cost_slow_comp_ml_min;

                // Determine which time constant to use based on the direction of change
                let current_tau_slow_comp;
                if (o2_cost_diff >= 0) {
                    // Slow component is increasing or stable, use "on" kinetics
                    current_tau_slow_comp = TAU_SLOW_COMP_O2_COST_ON;
                } else {
                    // Slow component is decreasing, use "off" kinetics
                    current_tau_slow_comp = TAU_SLOW_COMP_O2_COST_OFF;
                }
                // Ensure the time constant is at least 1 second to avoid division by zero or extreme values
                const effective_tau_slow_comp = Math.max(1, current_tau_slow_comp);

                const o2_cost_change = o2_cost_diff * (1 - Math.exp(-deltaT / effective_tau_slow_comp));
                let current_actual_o2_cost_slow_comp = previous_actual_o2_cost_slow_comp_ml_min + o2_cost_change;
                current_actual_o2_cost_slow_comp = Math.max(0, current_actual_o2_cost_slow_comp); // Ensure it doesn't go below zero

                excess_lactic_o2_cost_ml_min_for_slow_comp[i] = current_actual_o2_cost_slow_comp;
                previous_actual_o2_cost_slow_comp_ml_min = current_actual_o2_cost_slow_comp; // Update for the next iteration

                totalVo2DemandWithSlowComp[i] = vo2Demand_power_only[i] + current_actual_o2_cost_slow_comp;
            }
            
            vo2Target[i] = Math.min(totalVo2DemandWithSlowComp[i], effectiveVO2max[i]);
                    // --- 2-Compartment Lactate Dynamics ---
                    const la_m_prev = LaConc[i - 1]; // Muscle lactate from previous step
                    const la_b_prev = LaConc_b[i - 1]; // Blood lactate from previous step

                    // Net flux Muscle -> Blood (mmol/L(Muscle)/s)
                    const flux_term_s = Kdiff_s * (la_m_prev - la_b_prev); // Kdiff_s is a global constant

                    // Rate of change in Muscle (Production - Oxidation - Outflow)
                    // Use the final vLassActual[i] and vLaox_current_s_for_step_i for this step
                    const dLam_dt = (vLassActual[i] - vLaox_current_s_for_step_i) - flux_term_s; // CORRECTED VARIABLE HERE

                    // Blood Clearance Rate (mmol/L(Blood)/s)
                    const blood_clearance_rate_s = k_clearance_b * la_b_prev; // k_clearance_b is a global constant

                    // Rate of change in Blood (Inflow scaled by volume ratio - Clearance)
                    const dLab_dt = (flux_term_s * Vrel) - blood_clearance_rate_s; // Vrel is a global constant or calculated at start

                    // Calculate concentrations for the next step
                    const nextLa_m = la_m_prev + dLam_dt * deltaT;
                    const nextLa_b = la_b_prev + dLab_dt * deltaT;

                    // --- Updated storage of concentrations ---
                    LaConc.push(Math.max(laBase * 0.8, nextLa_m)); // Update for muscle concentration
                    LaConc_b.push(Math.max(laBase * 0.8, nextLa_b)); // Add for blood concentration

                      
                // --- PCr, O2 Deficit --- (Calculated ALWAYS now)
                const deltaTMin = deltaT / 60;     
                const current_dynamic_yield_kJ_mol = dynamic_ATP_yield_kJ_mol_values[i]; // Use yield for current interval
                const mechanicalCouplingEfficiencyAlactic = 1.0; // Set to 1.0 (100%) initially, no efficiency loss here
                const o2MolarVolume = 22414; // ml/mol STPD
                const current_active_muscle_mass = appState.active_muscle_mass;

                // II. PCr Dynamics
                // PCr consumption/resynthesis is based on the difference between actual V̇O₂ uptake (vo2Actual[i])
                // and the total V̇O₂ demand (totalVo2DemandWithSlowComp[i]) for the current step i.
                const current_o2Deficit_rate_for_pcr = Math.max(0, totalVo2DemandWithSlowComp[i] - vo2Actual[i]);
                const current_o2Surplus_rate_for_pcr = Math.max(0, vo2Actual[i] - totalVo2DemandWithSlowComp[i]);

                // Subsequent calculations (deficitMl_interval, surplusMl_interval, etc.) will use these _for_pcr rates.
                const deficitMl_interval = current_o2Deficit_rate_for_pcr * deltaTMin; 
                const surplusMl_interval = current_o2Surplus_rate_for_pcr * deltaTMin; 

        // Anaerob-Laktazider Beitrag zum O2-Defizit
            let o2_equiv_lactic_ml_per_interval = 0;
            const brutto_vLass_rate_muscle_s_current = vLassActual[i]; // Brutto-Laktatproduktionsrate im Muskel (mmol/L/s)

            if (brutto_vLass_rate_muscle_s_current > 0 && current_active_muscle_mass > 0 && deficitMl_interval > 0) { // Nur wenn Defizit vorhanden
                const Vm_L = current_active_muscle_mass * Vm_water_fraction; // Muskelwasser-Volumen in L
                // Brutto im Muskel produziertes Laktat in diesem Intervall (mmol)
                const brutto_lactate_produced_muscle_mmol_per_interval = brutto_vLass_rate_muscle_s_current * Vm_L * deltaT;

                const ATP_produced_glycolysis_mmol_per_interval = brutto_lactate_produced_muscle_mmol_per_interval * ATP_PER_LACTATE_FROM_GLYCOGEN;
                
            // Calculate the metabolic energy (kJ) from this gross lactate production
            // using the dynamic ATP yield for the current interval.
            const energy_from_glycolysis_kJ_per_interval = ATP_produced_glycolysis_mmol_per_interval * (current_dynamic_yield_kJ_mol / 1000.0);

            // Convert this metabolic energy (kJ) into its OXYGEN EQUIVALENT (ml O2).
            // Assume that if this energy were produced aerobically, it would primarily come from CHO (RQ=1.0).
            const kJ_per_L_O2_aerobic_CHO_for_lactic_equiv = getKalorischesEquivalent(1.0).kJ_lO2; // Approx. 21.1 kJ/L O2 for CHO

            let o2_equivalent_of_lactic_energy_ml_per_interval = 0;
            if (kJ_per_L_O2_aerobic_CHO_for_lactic_equiv > 0) {
                o2_equivalent_of_lactic_energy_ml_per_interval = (energy_from_glycolysis_kJ_per_interval / kJ_per_L_O2_aerobic_CHO_for_lactic_equiv) * 1000.0; // Convert L to ml
            }

            // CRITICAL: The lactic system's contribution to covering the O2 deficit
            // cannot exceed the actual O2 deficit of the current interval.
            o2_equiv_lactic_ml_per_interval = Math.min(o2_equivalent_of_lactic_energy_ml_per_interval, deficitMl_interval);
            }
            o2_equiv_gross_lactate_ml_array.push(o2_equiv_lactic_ml_per_interval); // Speichere den tatsächlichen Beitrag zum Defizit

            // Verbleibendes Defizit für PCr
            const deficitMl_for_pcr = Math.max(0, deficitMl_interval - o2_equiv_lactic_ml_per_interval);

            // PCr Verbrauch (Berechnung bleibt gleich, verwendet aber jetzt deficitMl_for_pcr)
            let pcrConsumption = 0;
            if (deficitMl_for_pcr > 0 && current_active_muscle_mass > 0) {
            const rq_for_deficit_calc = (i > 1 && rqActual[i-1]) ? rqActual[i-1] : rqActual[0]; // RQ vom vorherigen Schritt
            const kJ_per_L_O2_aerobic = getKalorischesEquivalent(rq_for_deficit_calc).kJ_lO2;
            const energy_gap_to_cover_kJ = (deficitMl_for_pcr / 1000.0) * kJ_per_L_O2_aerobic;
            const net_energy_yield_per_mmol_PCr_for_work_kJ = (current_dynamic_yield_kJ_mol / 1000.0) * mechanicalCouplingEfficiencyAlactic; // mechanicalCouplingEfficiencyAlactic ist 1.0
            if (net_energy_yield_per_mmol_PCr_for_work_kJ > 0) {
                    const total_pcr_needed_mmol = energy_gap_to_cover_kJ / net_energy_yield_per_mmol_PCr_for_work_kJ;
                    pcrConsumption = total_pcr_needed_mmol / current_active_muscle_mass;
                }
            }

            // PCr Resynthesis with dynamic factor based on intensity and O2 surplus
            let pcrResynthesis = 0;
            if (current_active_muscle_mass > 0 && surplusMl_interval > 0) { // Only if there's an O2 surplus

                let dynamicPcrResynthesisFactor = 0.0; // Default to no resynthesis if conditions below aren't met
                const currentPowerAtI = powerValues[i] !== undefined ? powerValues[i] : 0; // Power at current step i

                // Check if MLSS-related parameters are valid for the logic
                if (mlss_power_for_pcr_logic === null || mlss_power_for_pcr_logic === undefined || max_vo2_diff_for_recovery_span <= 0) {
                    // Fallback: If MLSS is not defined or recovery span is not positive,
                    // use a fixed, potentially conservative resynthesis factor when surplus exists.
                    // This prevents errors and allows some resynthesis, but without the nuanced logic.
                    // You might want to adjust this fallback behavior.
                    dynamicPcrResynthesisFactor = 0.00; // Example: Allow 25% of potential resynthesis as a fallback.
                                                       // Or set to 0.0 if you want no resynthesis without valid MLSS data.
                } else if (currentPowerAtI >= mlss_power_for_pcr_logic) {
                    // Condition 1: Current power is at or above MLSS power.
                    // No PCr resynthesis in this case.
                    dynamicPcrResynthesisFactor = 0.0;
                } else {
                    // Condition 2: Current power is below MLSS power.
                    // Calculate the "depth" of recovery based on VO2 demand for the current power.
                    // vo2Demand_power_only[i] is the O2 demand for current powerValues[i] (without slow component effects).
                    const current_vo2_demand_for_power_at_i = vo2Demand_power_only[i];

                    // How far is the current V̇O₂ demand (for power) below the V̇O₂ at MLSS?
                    const recovery_depth_absolute_vo2 = vo2_at_mlss_for_pcr_logic - current_vo2_demand_for_power_at_i;

                    // Normalize this depth relative to the maximum possible recovery span (VO2_at_MLSS - VO2_base)
                    // Ensure recovery_depth_relative is between 0 and 1.
                    const recovery_depth_relative = Math.max(0, Math.min(1, recovery_depth_absolute_vo2 / max_vo2_diff_for_recovery_span));

                    // Define min and max resynthesis efficiency factors
                    const min_resynthesis_factor = 0.10; // Factor when power is just below MLSS (recovery_depth_relative is near 0)
                    const max_resynthesis_factor = 0.75; // Factor when power is near resting (recovery_depth_relative is near 1)

                    // Linear interpolation for the factor based on recovery depth
                    dynamicPcrResynthesisFactor = min_resynthesis_factor + (recovery_depth_relative * (max_resynthesis_factor - min_resynthesis_factor));
                }

                // Final check to ensure the factor is within [0, 1]
                dynamicPcrResynthesisFactor = Math.max(0.0, Math.min(1.0, dynamicPcrResynthesisFactor));

                const denominator_pcr_resynth = current_active_muscle_mass * o2MolarVolume;
                if (denominator_pcr_resynth > 0) {
                    // Use the calculated dynamicPcrResynthesisFactor in the formula
                    pcrResynthesis = (surplusMl_interval * dynamicPcrResynthesisFactor * appState.p_o_ratio * 1000) / denominator_pcr_resynth;
                }
            }

            const nextPcr = pcrStore[i-1] - pcrConsumption + pcrResynthesis;
            pcrStore.push(Math.min(appState.pcr_init, Math.max(0, nextPcr)));
            const netPcrChange_this_interval_mmol_kg = pcrStore[i-1] - pcrStore[i]; // Verbrauch ist positiv
            net_pcr_change_mmol_kg_array.push(netPcrChange_this_interval_mmol_kg);

            // Accumulate anaerobic energy contributions using dynamic yield ---
            if (o2_equiv_lactic_ml_per_interval > 0) {
                const kJ_per_L_O2_aerobic_CHO = getKalorischesEquivalent(1.0).kJ_lO2; // For pure CHO
                totalLacticEnergy_kJ_from_loop += (o2_equiv_lactic_ml_per_interval / 1000.0) * kJ_per_L_O2_aerobic_CHO;
            }
            if (netPcrChange_this_interval_mmol_kg > 0) { // Only count PCr breakdown as energy contribution
                // kJ_per_mmol_PCr is effectively current_dynamic_yield_kJ_mol / 1000.0
                totalAlacticEnergy_kJ_from_loop += netPcrChange_this_interval_mmol_kg * appState.active_muscle_mass * (current_dynamic_yield_kJ_mol / 1000.0);
            }
    
            // accumulatedO2Deficit sollte jetzt das *nicht* durch anaerobe Quellen gedeckte Defizit sein,
            // aber für die Anzeige des *gesamten* O2-Defizits ist `deficitMl_interval` relevanter.
            // Für die Anzeige des "Accumulated O2 Deficit" im Plot, ist es vielleicht besser,
            // das kumulative *ursprüngliche* Defizit zu zeigen, bevor es durch anaerobe Prozesse gedeckt wird.
            // Oder, die aktuelle Berechnung von accumulatedO2Deficit ist korrekt, wenn es das *noch offene* Defizit sein soll.
            // Für die Energiebeitragsberechnung ist `o2_equiv_lactic_ml_per_interval` und `deficitMl_for_pcr` entscheidend.
            accumulatedO2Deficit.push(Math.max(0, accumulatedO2Deficit[i - 1] + deficitMl_interval - surplusMl_interval));

            // III. Calculate "Total Excess Energy (O₂ Eq.)" for step i
            let o2_eq_net_alactic_ml_min_current_step = 0;
            const netPcrChange_mmol_kg_current_interval = net_pcr_change_mmol_kg_array[i]; // Value for current step i, already stored
            if (netPcrChange_mmol_kg_current_interval > 0) { // Only PCr breakdown contributes to this "excess" concept here
                // dynamic_ATP_yield_kJ_mol_values[i] is based on pHm[i-1] and pcrStore[i-1]
                const energy_from_pcr_kJ_current_interval = netPcrChange_mmol_kg_current_interval * current_active_muscle_mass * (dynamic_ATP_yield_kJ_mol_values[i] / 1000.0);
                const kJ_per_L_O2_aerobic_alactic_equiv = getKalorischesEquivalent(0.85).kJ_lO2; // Approx RQ for mixed/PCr
                if (kJ_per_L_O2_aerobic_alactic_equiv > 0 && deltaTMin > 0) { // deltaTMin is (deltaT / 60)
                    const o2_equiv_L_alactic_current_interval = energy_from_pcr_kJ_current_interval / kJ_per_L_O2_aerobic_alactic_equiv;
                    o2_eq_net_alactic_ml_min_current_step = (o2_equiv_L_alactic_current_interval / deltaTMin) * 1000.0; // Convert L to ml, and rate per min
                } else if (kJ_per_L_O2_aerobic_alactic_equiv > 0 && deltaTMin === 0 && timePoints.length === 1) { // Handle single point duration
                    const o2_equiv_L_alactic_current_interval = energy_from_pcr_kJ_current_interval / kJ_per_L_O2_aerobic_alactic_equiv;
                    // For a single point, this is more like an instantaneous potential rate if it were sustained for a minute
                    o2_eq_net_alactic_ml_min_current_step = o2_equiv_L_alactic_current_interval * 1000.0 * 60.0;
                }
            }

            let o2_eq_net_lactic_ml_min_current_step = 0;
            // vLassActual[i] and vLaox_current_s_for_step_i are rates for current step i
            const net_lactic_rate_s_current_interval = vLassActual[i] - vLaox_current_s_for_step_i; // USE THE CORRECT VARIABLE
            if (net_lactic_rate_s_current_interval > 0) { // Only net production contributes to this "excess" concept here
                const net_lactate_produced_mmol_per_sec_current_interval = net_lactic_rate_s_current_interval * Vm; // Vm is muscle water volume
                // dynamic_ATP_yield_kJ_mol_values[i] is based on pHm[i-1] and pcrStore[i-1]
                const energy_from_net_lactate_kJ_per_sec_current_interval = net_lactate_produced_mmol_per_sec_current_interval * ATP_PER_LACTATE_FROM_GLYCOGEN * (dynamic_ATP_yield_kJ_mol_values[i] / 1000.0);
                const kJ_per_L_O2_aerobic_lactic_equiv = getKalorischesEquivalent(1.0).kJ_lO2; // RQ=1.0 for CHO
                if (kJ_per_L_O2_aerobic_lactic_equiv > 0) {
                    const o2_equiv_L_per_sec_lactic_current_interval = energy_from_net_lactate_kJ_per_sec_current_interval / kJ_per_L_O2_aerobic_lactic_equiv;
                    o2_eq_net_lactic_ml_min_current_step = o2_equiv_L_per_sec_lactic_current_interval * 1000.0 * 60.0; // Convert L/s to ml/min
                }
            }
                    
            total_excess_energy_o2_eq_ml_min_array[i] = (vo2Actual[i] + o2_eq_net_alactic_ml_min_current_step + o2_eq_net_lactic_ml_min_current_step) - vo2Demand_power_only[i];

             // --- Calculate pHm for the *current* step i ---
            // 1. Estimate Pi_raw based on *current* PCr store (pcrStore[i])
            let currentPi_raw = Pi_min; // Raw Pi based on current PCr value for this step
            const pcr_val_current_step = pcrStore[i];
            const pcr_range_for_ph = PCr_max_for_ph_calc - PCr_min_for_ph_calc;
            if (pcr_range_for_ph > 0) {
                currentPi_raw = Pi_min + (Pi_max - Pi_min) * Math.max(0, PCr_max_for_ph_calc - pcr_val_current_step) / pcr_range_for_ph;
                currentPi_raw = Math.min(Pi_max, Math.max(Pi_min, currentPi_raw));
            }

            let effectivePi_for_pH_calculation;

            if (i > 0) { // Ensure we have a previous state (Pi_est[i-1])
                // Check if vLassActual FOR THE CURRENT STEP (i) was capped by pH.
                // vLass_reduction_due_to_pH_s[i] holds this information (calculated earlier in this loop iteration).
                // A small threshold is used to make sure the reduction is significant.
                const is_vLass_pH_capped_this_step = (vLass_reduction_due_to_pH_s[i] > 0.001);

                if (is_vLass_pH_capped_this_step) {
                    // --- vLass IS currently pH-inhibited ---
                    // The pH-raising effect of PCr breakdown (via Pi reduction) should be NULLIFIED.
                    // We achieve this by using the Pi value that was used for the pH calculation of the PREVIOUS step.
                    // This effectively means that any change in PCr in the current interval does not alter the Pi component of the pH equation.
                    effectivePi_for_pH_calculation = Pi_est[i-1]; 
                } else {
                    // --- vLass is NOT currently pH-inhibited (or not significantly) ---
                    // PCr breakdown (and thus Pi changes) affects pH normally.
                    // Use the Pi calculated from the current PCr store.
                    effectivePi_for_pH_calculation = currentPi_raw;
                }
            } else {
                // For the very first step (i=0), there's no previous Pi_est, so use currentPi_raw.
                effectivePi_for_pH_calculation = currentPi_raw;
            }
            Pi_est.push(effectivePi_for_pH_calculation); // Store the Pi value actually used for pH calculation this step

            // 2. Get Lam (Muscle Lactate) for *current* step i
            const currentLam = LaConc[i];

            // 3. Estimate pCO2 based on *current* relative VO2 intensity
            const currentVO2 = vo2Actual[i];
            const currentEffVO2max = effectiveVO2max[i];
            let vo2Ratio = currentEffVO2max > 0 ? (currentVO2 / currentEffVO2max) : 0;
            let currentPCO2 = 40 + 55 * vo2Ratio;
            currentPCO2 = Math.max(40, Math.min(80, currentPCO2));
            pCO2_est.push(currentPCO2);

            // 4. Calculate pHm for *current* step i using the determined effectivePi_for_pH_calculation
            const logArg_pH = Math.max(1e-9, currentPCO2);
            const pH_val_current = 7.85 + dbuff * (0.8 * effectivePi_for_pH_calculation - currentLam) - 0.55 * Math.log10(logArg_pH); 
            pHm.push(Math.max(6.0, Math.min(7.4, pH_val_current)));
            // --- END pH Calculation ---

                            // Predicted RQ für aktuellen Zeitschritt berechnen (Steady-State Logik aus Tab 1 anwenden) ***
            const currentPowerPredRQ = powerValues[i];
            const effVO2BasePredRQ = effectiveVO2Base[i];
            const effVO2maxPredRQ = effectiveVO2max[i];
            // CORRECTED: Use the pH-adjusted vLamax calculated earlier in this loop iteration
            // vLa_max_eff_current_step_for_i was calculated based on pHm[i-1]
            const effVLamaxPredRQ = vLa_max_eff_current_step_for_i; 
            const effCEPredRQ = effectiveCEVO2[i];
            let vo2ss_unlimited_at_p;

            // 1. Berechne VO2ss_unlimited für die aktuelle Leistung
            if (isCurvilinear && aOpt !== null) {
                vo2ss_unlimited_at_p = aOpt * Math.pow(currentPowerPredRQ, 2) + CE_range[0] * currentPowerPredRQ + effVO2BasePredRQ;
            } else {
                vo2ss_unlimited_at_p = effCEPredRQ * currentPowerPredRQ + effVO2BasePredRQ;
            }

            // 2. Berechne VO2ss (limitiert)
            const vo2ss_at_p = Math.min(vo2ss_unlimited_at_p, effVO2maxPredRQ);

            // 3. Berechne Steady-State vLass (mmol/l/s)
            let vLass_at_p = 0;
            const denominator_vo2_predRQ = Math.max(1, vo2ss_at_p); // Verwende limitiertes VO2ss hier
            if (denominator_vo2_predRQ > 0 && ks1 > 0) { // Zusätzliche Sicherheitsprüfung
                const vo2_term_predRQ = Math.max(0, (effVO2maxPredRQ - denominator_vo2_predRQ) / (ks1 * denominator_vo2_predRQ));
                const power_base_predRQ = Math.max(0, vo2_term_predRQ);
                vLass_at_p = effVLamaxPredRQ / (1 + ks2 * Math.pow(power_base_predRQ, 3/2));
            }

            // 4. Berechne Steady-State vLaox (mmol/l/s) - Verwende unlimitiertes VO2ss
            const vLaox_at_p = (CELaO2 * vo2ss_unlimited_at_p) / (VolLa * 60);

            // 5. Konvertiere zu Raten pro Minute
            const vLass_min_at_p = vLass_at_p * 60;
            const vLaox_min_at_p = vLaox_at_p * 60;

            // 6. Berechne PD
            const PD_min_at_p = vLaox_min_at_p - vLass_min_at_p;

            // 7. Berechne Carb Percentage
            let carbPerc_at_p = 0;
            if (vLaox_min_at_p > 1e-6) { // Division durch Null vermeiden
                carbPerc_at_p = Math.min(100, Math.max(0, (vLass_min_at_p / vLaox_min_at_p) * 100));
            }
            if (PD_min_at_p <= 0) { // Oberhalb MLSS -> 100%
                carbPerc_at_p = 100;
            }
            // HINWEIS: Die Ruhewert-Anpassung (show_kh_adjust) wird hier bewusst *nicht* angewendet,
            // da sie eine Kurvenanpassung ist und nicht sinnvoll auf Einzelpunkte angewendet werden kann.
            // Der predicted RQ basiert also rein auf dem vLass/vLaox Verhältnis für die Leistung P.

            // 8. Berechne RQ (dies ist der Ziel-RQ für den aktuellen Schritt)
            const rq_demand_current_step = calculateRQ(carbPerc_at_p);

            // --- NEU: Kinetische Anpassung für RQ ---
            const rq_previous_actual = rqActual[i-1];
            const rq_target_diff = rq_demand_current_step - rq_previous_actual;

            // Verwende die gleichen Tau-Werte wie für VO2 (current_tau_on, current_tau_off)
            // Diese werden bereits weiter oben in der Schleife für die VO2-Kinetik bestimmt.
            const timeConstant_rq = (rq_target_diff >= 0) ? current_tau_on : current_tau_off;
            const effectiveTimeConstant_rq = Math.max(1, timeConstant_rq); // Sicherstellen, dass Tau >= 1s

            const rq_change = rq_target_diff * (1 - Math.exp(-deltaT / effectiveTimeConstant_rq));
            let next_rq_actual = rq_previous_actual + rq_change;

            // RQ auf physiologische Grenzen beschränken (z.B. 0.7 bis 1.05, um leichtes Überschwingen/Rauschen zu erlauben)
            next_rq_actual = Math.max(0.7, Math.min(1.05, next_rq_actual));
            rqActual.push(next_rq_actual);
            // --- ENDE NEU ---

            // 9. Skaliere und speichere den *tatsächlichen kinetischen* RQ für das Plotting
            rqPredictedScaled.push(next_rq_actual * 10); // Speichere den skalierten *tatsächlichen* RQ
            // RQ_predicted ENDE ***

                // --- Glycogen and Substrate Calculation ---
                const vLassMin_current = vLassActual[i] * 60;
                const vLaoxMin_current = vLaoxActual_s[i] * 60;
                const PD_current = vLaoxMin_current - vLassMin_current;

                let carbPerc_current = 0;
                if (vLaoxMin_current > 1e-6) { // Avoid division by zero
                    carbPerc_current = Math.min(100, Math.max(0, (vLassMin_current / vLaoxMin_current) * 100));
                }
                if (PD_current <= 0) { // Above MLSS approx.
                    carbPerc_current = 100;
                }

                const vo2L_min_current = vo2Actual[i] / 1000;
                // Use RQ-dependent caloric equivalent for better accuracy
                const currentRQ = calculateRQ(carbPerc_current);
                const currentKcalPerO2L = getKalorischesEquivalent(currentRQ).kcal_lO2;
                const totalKcalMin_current = vo2L_min_current * currentKcalPerO2L;

                const kcalPerGramCarb = 4.1;
                const carbKcalMin_current = totalKcalMin_current * (carbPerc_current / 100);
                const carbGramMin_current = carbKcalMin_current / kcalPerGramCarb;
                carbGramMin.push(carbGramMin_current);

                // Glycogen store update
                const glycogenConsumption = carbGramMin_current * deltaTMin;
                const carbIntakeGMin = appState.carb_intake_rate / 60;
                const glycogenIntake = carbIntakeGMin * deltaTMin;
                const nextGlycogen = glycogenStore[i-1] - glycogenConsumption + glycogenIntake;
                glycogenStore.push(Math.min(appState.glycogen_max, Math.max(0, nextGlycogen)));

                // Fat calculation
                const fatPerc_current = 100 - carbPerc_current;
                const fatKcalMin_current = totalKcalMin_current * (fatPerc_current / 100);
                const kcalPerGramFat = 9.45;
                const fatGramMin_current = fatKcalMin_current / kcalPerGramFat;
                fatGramMin.push(fatGramMin_current);


                // --- W' Balance, MPA, Strain Score ---
                const powerPrev = powerValues[i-1];
                const wPrimePrev = wprimeBalance[i-1];
                let wPrimeNext = wPrimePrev;

                if (powerPrev > cp) {
                    const wprimeExp = (powerPrev - cp) * deltaT;
                    wPrimeNext = wPrimePrev - wprimeExp;
                } else {
                    const dcp = cp - powerPrev; // Difference Critical Power (CP - Power_recovery)
                    const wPrimeInitialJoules = wprime * 1000; // W₀ (initial W') in Joules

                    // Implement Skiba et al. (2015) Appendix 1 recovery model
                    if (dcp > 0 && wPrimeInitialJoules > 0) { // Only recover if power is below CP and W' > 0
                        const recoveryRateFactor = dcp / wPrimeInitialJoules; // This is the term DCP/W₀ (Unit: 1/s)
                        // Formula: W'(t) = W₀ - (W₀ - W'(u)) * e^(-(DCP/W₀) * deltaT)
                        wPrimeNext = wPrimeInitialJoules - (wPrimeInitialJoules - wPrimePrev) * Math.exp(-recoveryRateFactor * deltaT);
                    } else {
                        // No recovery if power is >= CP or initial W' is zero
                        wPrimeNext = wPrimePrev; // W' balance remains the same in this step
                    }
                }
                wPrimeNext = Math.min(wPrimeNext, wprime * 1000); // Cap at max W'
                wprimeBalance.push(wPrimeNext);

                // MPA calculation for the current step
                const wPrimeExpCurrent = wprime * 1000 - wPrimeNext; // W' expended up to *end* of step i
                // Ensure wprime denominator is not zero
                const wPrimeTotalJoules = wprime * 1000;
                let wPrimeRatioSquared = 0;
                if (wPrimeTotalJoules > 0) {
                    wPrimeRatioSquared = Math.pow((wPrimeExpCurrent / wPrimeTotalJoules), 2);
                }
                const mpa_current = appState.pmax - (appState.pmax - cp) * wPrimeRatioSquared;
                mpaValues.push(Math.max(cp, mpa_current)); // MPA cannot drop below CP

                // Strain Score calculation based on power in *previous* interval
                const mpaPrev = mpaValues[i-1]; // MPA at the beginning of the interval
                const sysStrainRates = calculateSystemStrainRates(powerPrev, mpaPrev, cp, appState.pmax);
                strainRates.push(sysStrainRates.total);
                strainRatesCP.push(sysStrainRates.CP);
                strainRatesWprime.push(sysStrainRates.Wprime);
                strainRatesPmax.push(sysStrainRates.Pmax);

                // Calculate current interval strain score contribution
                let intervalSS = 0;
                if (cp > 0) { // Avoid division by zero if CP is zero
                    const normalizationFactorSS = (appState.pmax / Math.pow(cp, 2)) * (100 / 3600);
                    intervalSS = sysStrainRates.total * deltaT * normalizationFactorSS;
                }
                cumulativeStrainScore.push(cumulativeStrainScore[i-1] + intervalSS);


                // --- Check Abort Conditions ---
                // Check only if simulation hasn't already been marked for abortion
                if (abortIdx === null) {
                    if (appState.use_lactate_abort && LaConc[i] >= laMax) {
                        abortIdx = i; abortPower = powerValues[i]; abortTime = timePoints[i]; abortReason = "lactate";
                    } else if (pcrStore[i] <= 0.1) { // Check PCr depletion *after* calculation for step i
                        abortIdx = i; abortPower = powerValues[i]; abortTime = timePoints[i]; abortReason = "pcr";
                    } else if (appState.use_w_prime_balance_abort && wprimeBalance[i] <= (appState.w_prime_balance_min * 1000)) { // Compare W' in Joules
                        abortIdx = i; abortPower = powerValues[i]; abortTime = timePoints[i]; abortReason = "wbalance";
                    } else if (glycogenStore[i] <= 0) {
                        abortIdx = i; abortPower = powerValues[i]; abortTime = timePoints[i]; abortReason = "glycogen";
                    }
                }

            } // End of main simulation loop

            // --- Prepare Results ---
            const finalVLassMin = vLassActual.map(v => v * 60);
            const finalVLaoxMin = vLaoxActual_s.map(v => v * 60);
            const finalPD = finalVLaoxMin.map((ox, idx) => ox - finalVLassMin[idx]);
            const finalWPrimeBalanceKJ = wprimeBalance.map(w => w / 1000); // Convert Joules to kJ

            // Trim arrays if simulation was aborted
            if (abortIdx !== null) {
                endIdx = abortIdx + 1; // Include the point where abortion occurred
                const trim = (arr) => arr ? arr.slice(0, endIdx) : null; // Helper to handle potentially null arrays

                // Create final cadence array based on settings
                let trimmedCadence = null;
                if (cadenceValues && appState.cadence_dependent_step && appState.use_file_cadence) {
                    trimmedCadence = trim(cadenceValues);
                } else if (appState.cadence_dependent_step) {
                    trimmedCadence = new Array(endIdx).fill(appState.cadence_step);
                }

                return {
                time_sec: trim(timePoints),
                power: trim(powerValues),
                VO2: trim(vo2Actual),
                vo2_demand: trim(totalVo2DemandWithSlowComp), // Use the new total demand for plotting deficit area
                vo2_demand_power_only: trim(vo2Demand_power_only), // Keep for reference or new plots
                excess_lactic_o2_cost_ml_min_for_slow_comp: trim(excess_lactic_o2_cost_ml_min_for_slow_comp), // New
                total_excess_energy_o2_eq_ml_min: trim(total_excess_energy_o2_eq_ml_min_array), // New for plot
                vLass_min: trim(finalVLassMin),
                vLaox_min: trim(finalVLaoxMin),
                PD: trim(finalPD),
                La_conc: trim(LaConc),
                La_conc_b: trim(LaConc_b), 
                w_prime_bal: trim(finalWPrimeBalanceKJ), 
                glycogen_store: trim(glycogenStore),
                carb_gram_min: trim(carbGramMin),
                fat_gram_min: trim(fatGramMin),
                abort_power: abortPower, 
                abort_time: abortTime,   
                abort_reason: abortReason,
                cadence: trimmedCadence,
                is_curvilinear: isCurvilinear,
                a_opt: aOpt,
                ce_range: CE_range,
                pcr_store: trim(pcrStore), 
                accumulated_o2_deficit: trim(accumulatedO2Deficit), 
                pHm: trim(pHm), 
                HR_actual: trim(hrActual),
                mpa: trim(mpaValues), 
                strain_rates: trim(strainRates),
                strain_rates_cp: trim(strainRatesCP),
                strain_rates_wprime: trim(strainRatesWprime),
                strain_rates_pmax: trim(strainRatesPmax),
                cumulative_strain_score: trim(cumulativeStrainScore),
                pmax: appState.pmax,
                net_pcr_change_mmol_kg: trim(net_pcr_change_mmol_kg_array),
                o2_equiv_gross_lactate_ml: trim(o2_equiv_gross_lactate_ml_array),
                rqPredictedScaled: trim(rqPredictedScaled),
                dynamic_ATP_yield_kJ_mol_values: trim(dynamic_ATP_yield_kJ_mol_values),
                total_alactic_energy_kj_loop: totalAlacticEnergy_kJ_from_loop,
                total_lactic_energy_kj_loop: totalLacticEnergy_kJ_from_loop,
                vLass_uninhibited_by_pH_max_cap_s: trim(vLass_uninhibited_by_pH_max_cap_s), // NEW
                vLass_reduction_due_to_pH_s: trim(vLass_reduction_due_to_pH_s),
                net_lactic_energy_kj_intervals: trim(net_lactic_energy_kj_interval_array), // NEW for summary
                }; 
            } 
            
            // If not aborted, return full arrays
            // Create final cadence array based on settings
            let finalCadence = null;
            if (cadenceValues && appState.cadence_dependent_step && appState.use_file_cadence) {
                finalCadence = cadenceValues;
            } else if (appState.cadence_dependent_step) {
                finalCadence = new Array(timePoints.length).fill(appState.cadence_step);
            }

            return { 
            time_sec: timePoints,
            power: powerValues,
            VO2: vo2Actual,
            vo2_demand: totalVo2DemandWithSlowComp, // Use the new total demand
            vo2_demand_power_only: vo2Demand_power_only,
            excess_lactic_o2_cost_ml_min_for_slow_comp: excess_lactic_o2_cost_ml_min_for_slow_comp,
            total_excess_energy_o2_eq_ml_min: total_excess_energy_o2_eq_ml_min_array,
            vLass_min: finalVLassMin,
            vLaox_min: finalVLaoxMin,
            PD: finalPD,
            La_conc: LaConc,
            La_conc_b: LaConc_b, 
            w_prime_bal: finalWPrimeBalanceKJ, 
            glycogen_store: glycogenStore,
            carb_gram_min: carbGramMin,
            fat_gram_min: fatGramMin,
            abort_power: abortPower, 
            abort_time: abortTime,   
            abort_reason: abortReason,
            cadence: finalCadence,
            is_curvilinear: isCurvilinear,
            a_opt: aOpt,
            ce_range: CE_range,
            pcr_store: pcrStore, 
            accumulated_o2_deficit: accumulatedO2Deficit, 
            pHm: pHm, 
            HR_actual: hrActual,
            mpa: mpaValues,
            strain_rates: strainRates,
            strain_rates_cp: strainRatesCP,
            strain_rates_wprime: strainRatesWprime,
            strain_rates_pmax: strainRatesPmax,
            cumulative_strain_score: cumulativeStrainScore,
            pmax: appState.pmax,
            net_pcr_change_mmol_kg: net_pcr_change_mmol_kg_array,
            o2_equiv_gross_lactate_ml: o2_equiv_gross_lactate_ml_array,
            rqPredictedScaled: rqPredictedScaled,
            dynamic_ATP_yield_kJ_mol_values: dynamic_ATP_yield_kJ_mol_values,
            total_alactic_energy_kj_loop: totalAlacticEnergy_kJ_from_loop,
            total_lactic_energy_kj_loop: totalLacticEnergy_kJ_from_loop,
            vLass_uninhibited_by_pH_max_cap_s: vLass_uninhibited_by_pH_max_cap_s, // NEW
            vLass_reduction_due_to_pH_s: vLass_reduction_due_to_pH_s, // NEW
            net_lactic_energy_kj_intervals: net_lactic_energy_kj_interval_array // NEW for summary
        };
        } 
       
        function calculateAndUpdateMaxLacticPower() {
        let current_vLamax, current_active_muscle_mass_kg_for_calc, targetElementId;

        const activeTabElement = document.querySelector('.tab.active');
        const activeTabName = activeTabElement ? activeTabElement.getAttribute('data-tab') : 'leistungsdiagramm';

        let dataSourceTab;

        if (activeTabName === 'leistungsdiagramm') {
            dataSourceTab = 1;
            targetElementId = 'maxLacticPowerTab1';
            if (document.getElementById('maxLacticPowerTab2')) {
                document.getElementById('maxLacticPowerTab2').textContent = '-- W | -- W';
            }
        } else if (activeTabName === 'belastungssimulation') {
            if (appState.use_tab1_params) {
                dataSourceTab = 1;
            } else {
                dataSourceTab = 2;
            }
            targetElementId = 'maxLacticPowerTab2';
            if (document.getElementById('maxLacticPowerTab1')) {
                document.getElementById('maxLacticPowerTab1').textContent = '-- W | -- W';
            }
        } else {
            if (document.getElementById('maxLacticPowerTab1')) document.getElementById('maxLacticPowerTab1').textContent = '-- W | -- W';
            if (document.getElementById('maxLacticPowerTab2')) document.getElementById('maxLacticPowerTab2').textContent = '-- W | -- W';
            return;
        }

        if (dataSourceTab === 1) {
            current_vLamax = appState.vLamax;
            const musclePercentageTab1 = appState.gender === 'Male' ? 0.27 : 0.22;
            current_active_muscle_mass_kg_for_calc = appState.body_mass * musclePercentageTab1;
        } else { // dataSourceTab === 2
            current_vLamax = appState.vLamax_step;
            current_active_muscle_mass_kg_for_calc = appState.active_muscle_mass;
        }

        if (isNaN(current_vLamax) || isNaN(current_active_muscle_mass_kg_for_calc) || current_active_muscle_mass_kg_for_calc <= 0) {
            if (document.getElementById(targetElementId)) {
                document.getElementById(targetElementId).textContent = '-- W | -- W';
            }
            return;
        }

        const Vm_water_fraction = 0.75;
        const muscleWater_L = current_active_muscle_mass_kg_for_calc * Vm_water_fraction;

        if (isNaN(muscleWater_L) || muscleWater_L <= 0) {
            if (document.getElementById(targetElementId)) {
                document.getElementById(targetElementId).textContent = '-- W | -- W';
            }
            return;
        }

        // For theoretical MAX Lactic Power, use a fixed high ATP yield (e.g., at optimal pH)
        const fixed_yield_for_max_lactic_power_kJ_mol = ATP_YIELD_MAX_pH70; // Example: 65 kJ/mol
        const maxMetabolicLacticPower_W = current_vLamax * muscleWater_L * ATP_PER_LACTATE_FROM_GLYCOGEN * (fixed_yield_for_max_lactic_power_kJ_mol / 1000.0) * 1000.0;
        const maxMechanicalLacticPower_W = maxMetabolicLacticPower_W * 0.25;

        const displayElement = document.getElementById(targetElementId);
        if (displayElement) {
            if (!isNaN(maxMetabolicLacticPower_W) && !isNaN(maxMechanicalLacticPower_W)) {
                displayElement.textContent = `${maxMetabolicLacticPower_W.toFixed(0)} W | ${maxMechanicalLacticPower_W.toFixed(0)} W`;
            } else {
                displayElement.textContent = '-- W | -- W';
            }
        }
    }

            // Function to calculate and update exercise summary statistics
    function updateExerciseSummary(stepData) {
        if (!stepData || !stepData.power || stepData.power.length === 0 || !stepData.time_sec || stepData.time_sec.length < 2) {
            // Clear previous values if data is insufficient
            elements.avg_power.textContent = '--';
            elements.norm_power.textContent = '--';
            elements.total_energy.textContent = '--';
            elements.total_work.textContent = '--';
            elements.total_metabolic_work.textContent = '--';
            elements.aerobic_contribution.textContent = '-- kJ | --%';
            elements.lactic_contribution.textContent = '-- kJ | --%';
            elements.alactic_contribution.textContent = '-- kJ | --%';
            elements.work_above_cp.textContent = '--';
            elements.cho_utilization.textContent = '--';
            elements.fat_utilization.textContent = '--';
            elements.tss_value.textContent = '--';
            elements.total_ss.textContent = '--';
            elements.ss_cp.textContent = '--';
            elements.ss_wprime.textContent = '--';
            elements.ss_pmax.textContent = '--';
            elements.eta_gross.textContent = '--%';
            elements.eta_net.textContent = '--%';
            elements.eta_total.textContent = '--%';
            if (elements.net_oxygen_utilized) elements.net_oxygen_utilized.textContent = '-- L';
            if (elements.net_lactate_accumulated_muscle) elements.net_lactate_accumulated_muscle.textContent = '-- mmol·l⁻¹';
            if (elements.net_pcr_utilized_muscle) elements.net_pcr_utilized_muscle.textContent = '-- mmol·kg⁻¹';
            return;
        }

        let effectiveTimeSec = stepData.time_sec;
        let effectivePowerValues = stepData.power;
        let effectiveVo2Values = stepData.VO2;
        let effectiveVo2Demand = stepData.vo2_demand;
        let effectiveWprimeBalance = stepData.w_prime_bal;
        let effectiveRqPredictedValues = stepData.rqPredictedScaled ? stepData.rqPredictedScaled.map(rqs => rqs / 10) : [];
        let effectiveCarbGramMin = stepData.carb_gram_min;
        let effectiveFatGramMin = stepData.fat_gram_min;
        let effectiveStrainRatesCp = stepData.strain_rates_cp;
        let effectiveStrainRatesWprime = stepData.strain_rates_wprime;
        let effectiveStrainRatesPmax = stepData.strain_rates_pmax;
        let effectiveCumulativeStrainScore = stepData.cumulative_strain_score;
        let effectiveNetPcrChange_mmol_kg = stepData.net_pcr_change_mmol_kg;
        let effectiveO2EquivGrossLactate_ml = stepData.o2_equiv_gross_lactate_ml;
        let effectiveLaConcMuscle = stepData.La_conc;
        let effectiveDynamicATPYield = stepData.dynamic_ATP_yield_kJ_mol_values;

        let startIndex = 0;
        let endIndex = stepData.time_sec.length;

        if (appState.calculateSummaryForWindow && appState.customize_time_window) {
            const startTime = appState.view_time_start;
            const endTime = appState.view_time_end;
            startIndex = stepData.time_sec.findIndex(t => t >= startTime);
            let tempEndIndex = stepData.time_sec.findIndex(t => t > endTime);
            if (tempEndIndex === -1 && startTime <= stepData.time_sec[stepData.time_sec.length -1]) {
                endIndex = stepData.time_sec.length;
            } else if (tempEndIndex !== -1) {
                endIndex = tempEndIndex;
            }

            if (startIndex === -1 || (endIndex !== -1 && startIndex >= endIndex) || startIndex >= stepData.time_sec.length) {
                elements.avg_power.textContent = '-- (No data in window)';
                // ... (set all other summary elements to '-- (No data in window)')
                elements.norm_power.textContent = '-- (No data in window)';
                elements.total_energy.textContent = '-- (No data in window)';
                elements.total_work.textContent = '-- (No data in window)';
                elements.total_metabolic_work.textContent = '-- (No data in window)';
                elements.aerobic_contribution.textContent = '-- kJ | --% (No data in window)';
                elements.lactic_contribution.textContent = '-- kJ | --% (No data in window)';
                elements.alactic_contribution.textContent = '-- kJ | --% (No data in window)';
                elements.work_above_cp.textContent = '-- (No data in window)';
                elements.cho_utilization.textContent = '-- (No data in window)';
                elements.fat_utilization.textContent = '-- (No data in window)';
                elements.tss_value.textContent = '-- (No data in window)';
                elements.total_ss.textContent = '-- (No data in window)';
                elements.ss_cp.textContent = '-- (No data in window)';
                elements.ss_wprime.textContent = '-- (No data in window)';
                elements.ss_pmax.textContent = '-- (No data in window)';
                elements.eta_gross.textContent = '--% (No data in window)';
                elements.eta_net.textContent = '--% (No data in window)';
                elements.eta_total.textContent = '--% (No data in window)';
                if (elements.net_oxygen_utilized) elements.net_oxygen_utilized.textContent = '-- (No data in window)';
                if (elements.net_lactate_accumulated_muscle) elements.net_lactate_accumulated_muscle.textContent = '-- (No data in window)';
                if (elements.net_pcr_utilized_muscle) elements.net_pcr_utilized_muscle.textContent = '-- (No data in window)';
                return;
            }

            effectiveTimeSec = stepData.time_sec.slice(startIndex, endIndex);
            effectivePowerValues = stepData.power.slice(startIndex, endIndex);
            effectiveVo2Values = stepData.VO2.slice(startIndex, endIndex);
            effectiveVo2Demand = stepData.vo2_demand ? stepData.vo2_demand.slice(startIndex, endIndex) : [];
            effectiveWprimeBalance = stepData.w_prime_bal ? stepData.w_prime_bal.slice(startIndex, endIndex) : [];
            effectiveRqPredictedValues = stepData.rqPredictedScaled ? stepData.rqPredictedScaled.slice(startIndex, endIndex).map(rqs => rqs / 10) : [];
            effectiveCarbGramMin = stepData.carb_gram_min ? stepData.carb_gram_min.slice(startIndex, endIndex) : [];
            effectiveFatGramMin = stepData.fat_gram_min ? stepData.fat_gram_min.slice(startIndex, endIndex) : [];
            effectiveStrainRatesCp = stepData.strain_rates_cp ? stepData.strain_rates_cp.slice(startIndex, endIndex) : [];
            effectiveStrainRatesWprime = stepData.strain_rates_wprime ? stepData.strain_rates_wprime.slice(startIndex, endIndex) : [];
            effectiveStrainRatesPmax = stepData.strain_rates_pmax ? stepData.strain_rates_pmax.slice(startIndex, endIndex) : [];
            effectiveNetPcrChange_mmol_kg = stepData.net_pcr_change_mmol_kg ? stepData.net_pcr_change_mmol_kg.slice(startIndex, endIndex) : [];
            effectiveO2EquivGrossLactate_ml = stepData.o2_equiv_gross_lactate_ml ? stepData.o2_equiv_gross_lactate_ml.slice(startIndex, endIndex) : [];
            effectiveLaConcMuscle = stepData.La_conc ? stepData.La_conc.slice(startIndex, endIndex) : [];
            effectiveDynamicATPYield = stepData.dynamic_ATP_yield_kJ_mol_values ? stepData.dynamic_ATP_yield_kJ_mol_values.slice(startIndex, endIndex) : [];

            if (effectiveTimeSec.length < 2 && !(effectiveTimeSec.length === 1 && effectiveTimeSec[0] === stepData.time_sec[stepData.time_sec.length-1] && startIndex === stepData.time_sec.length -1) ) {
                elements.avg_power.textContent = '-- (Window too short)';
                // ... (set all other summary elements to '-- (Window too short)')
                elements.norm_power.textContent = '-- (Window too short)';
                elements.total_energy.textContent = '-- (Window too short)';
                elements.total_work.textContent = '-- (Window too short)';
                elements.total_metabolic_work.textContent = '-- (Window too short)';
                elements.aerobic_contribution.textContent = '-- kJ | --% (Window too short)';
                elements.lactic_contribution.textContent = '-- kJ | --% (Window too short)';
                elements.alactic_contribution.textContent = '-- kJ | --% (Window too short)';
                elements.work_above_cp.textContent = '-- (Window too short)';
                elements.cho_utilization.textContent = '-- (Window too short)';
                elements.fat_utilization.textContent = '-- (Window too short)';
                elements.tss_value.textContent = '-- (Window too short)';
                elements.total_ss.textContent = '-- (Window too short)';
                elements.ss_cp.textContent = '-- (Window too short)';
                elements.ss_wprime.textContent = '-- (Window too short)';
                elements.ss_pmax.textContent = '-- (Window too short)';
                elements.eta_gross.textContent = '--% (Window too short)';
                elements.eta_net.textContent = '--% (Window too short)';
                elements.eta_total.textContent = '--% (Window too short)';
                if (elements.net_oxygen_utilized) elements.net_oxygen_utilized.textContent = '-- (Window too short)';
                if (elements.net_lactate_accumulated_muscle) elements.net_lactate_accumulated_muscle.textContent = '-- (Window too short)';
                if (elements.net_pcr_utilized_muscle) elements.net_pcr_utilized_muscle.textContent = '-- (Window too short)';
                return;
            }
             if (stepData.cumulative_strain_score && stepData.cumulative_strain_score.length > 0) {
                const scoreAtStart = startIndex > 0 && stepData.cumulative_strain_score.length > startIndex -1 ? stepData.cumulative_strain_score[startIndex - 1] : 0;
                const scoreAtEnd = stepData.cumulative_strain_score.length > endIndex -1 && endIndex > 0 ? stepData.cumulative_strain_score[endIndex - 1] : (stepData.cumulative_strain_score.length > 0 ? stepData.cumulative_strain_score[stepData.cumulative_strain_score.length -1] : 0) ;
                effectiveCumulativeStrainScore = [scoreAtEnd - scoreAtStart]; // Store as an array with one element for consistency
            } else {
                 effectiveCumulativeStrainScore = [0];
            }
        } else {
             effectiveCumulativeStrainScore = stepData.cumulative_strain_score; // Use the full array
        }


        const vo2Base = appState.use_tab1_params ? appState.VO2Base : appState.VO2Base_step;
        const cp = appState.critical_power;
        const pmax_model = stepData.pmax;

        const timeSec = effectiveTimeSec;
        const powerValues = effectivePowerValues;
        const vo2Values = effectiveVo2Values;
        // WprimeBalance, RqPredictedValues are already 'effective'
        const netPcrChange_mmol_kg_for_summary = effectiveNetPcrChange_mmol_kg;
        const o2EquivGrossLactate_ml_for_summary = effectiveO2EquivGrossLactate_ml;
        const laConcMuscleValues = effectiveLaConcMuscle;
        const dynamicATPYieldValues_for_summary = effectiveDynamicATPYield;
        const carbGramMinValues = effectiveCarbGramMin;
        const fatGramMinValues = effectiveFatGramMin;
        const strainRatesCpValues = effectiveStrainRatesCp;
        const strainRatesWprimeValues = effectiveStrainRatesWprime;
        const strainRatesPmaxValues = effectiveStrainRatesPmax;


        const deltaT = [];
        if (timeSec.length === 1) {
            deltaT.push(timeSec[0] - (startIndex > 0 ? stepData.time_sec[startIndex-1] : 0)  || 1); // Duration of single point interval, fallback to 1s
        } else if (timeSec.length > 1) {
            for (let i = 1; i < timeSec.length; i++) {
                deltaT.push(timeSec[i] - timeSec[i-1]);
            }
        } else { // timeSec.length is 0
            deltaT.push(0);
        }


        const durationSec = timeSec.length > 0 ? timeSec[timeSec.length - 1] - timeSec[0] : 0;


        let totalPowerTimeProduct = 0;
        for (let i = 0; i < deltaT.length; i++) { // Iterate up to deltaT.length
            if (powerValues.length > i) { // Ensure powerValues has an element at index i
                totalPowerTimeProduct += powerValues[i] * deltaT[i];
            }
        }
        const avgMechanicalPower = durationSec > 0 ? totalPowerTimeProduct / durationSec : (powerValues.length > 0 ? powerValues[0] : 0);

        const rollingWindowSize = 30;
        const rollingAvgPower = [];
        if (powerValues.length > 0 && durationSec > 0) {
             for (let i = 0; i < powerValues.length; i++) {
                let sumPowerInWindow = 0;
                let timeInWindow = 0;
                for (let j = i; j >= 0; j--) {
                    const segmentDuration = (j > 0 && timeSec.length > j && timeSec.length > (j-1)) ? (timeSec[j] - timeSec[j-1]) : (timeSec.length > 0 && timeSec[0] !== undefined ? timeSec[0] - 0 : 0);
                    const timeElapsedInWindow = (timeSec.length > i && timeSec[i] !== undefined && timeSec.length > (j-1) && timeSec[j-1] !== undefined) ? timeSec[i] - (j > 0 ? timeSec[j-1] : 0) : 0 ;

                    if (timeElapsedInWindow <= rollingWindowSize) {
                        if(powerValues.length > j) sumPowerInWindow += powerValues[j] * segmentDuration;
                        timeInWindow += segmentDuration;
                         if (j === 0) break;
                    } else {
                        const partialSegmentDuration = segmentDuration - (timeElapsedInWindow - rollingWindowSize);
                        if (partialSegmentDuration > 0 && powerValues.length > j) {
                            sumPowerInWindow += powerValues[j] * partialSegmentDuration;
                            timeInWindow += partialSegmentDuration;
                        }
                        break;
                    }
                }
                rollingAvgPower.push(timeInWindow > 0 ? sumPowerInWindow / timeInWindow : (powerValues.length > i ? powerValues[i] : 0));
            }
        } else if (powerValues.length > 0) {
             powerValues.forEach(p => rollingAvgPower.push(p));
        }


        let sumFourthPower = 0;
        for (let i = 0; i < deltaT.length; i++) { // Iterate up to deltaT.length
             if (rollingAvgPower.length > i) { // Ensure rollingAvgPower has an element
                sumFourthPower += Math.pow(rollingAvgPower[i], 4) * deltaT[i];
            }
        }
        const normMechanicalPower = durationSec > 0 ? Math.pow(sumFourthPower / durationSec, 0.25) : (rollingAvgPower.length > 0 ? rollingAvgPower[0] : 0);

        let totalMechanicalWork_kJ = 0;
        for (let i = 0; i < deltaT.length; i++) { // Iterate up to deltaT.length
            if (powerValues.length > i) { // Ensure powerValues has an element
                totalMechanicalWork_kJ += powerValues[i] * deltaT[i] / 1000;
            }
        }

        let workAboveCP_kJ = 0;
        for (let i = 0; i < deltaT.length; i++) { // Iterate up to deltaT.length
            if (powerValues.length > i && powerValues[i] > cp) { // Ensure powerValues has an element
                workAboveCP_kJ += (powerValues[i] - cp) * deltaT[i] / 1000;
            }
        }

        // Initialize energy accumulators
        let totalAerobicEnergy_kJ = 0;
        let totalAlacticEnergy_kJ = 0;
        let totalLacticEnergy_kJ = 0;
        let totalGrossAerobicEnergy_kJ = 0;
        let totalNetOxygenUtilized_L_for_summary = 0;
        let totalNetLactateAccumulated_mmol_L_for_summary = 0;
        let totalNetPcrUtilized_mmol_kg_for_summary = 0;

        // Calculate Aerobic Energy
        for (let i = 0; i < deltaT.length; i++) { // Iterate up to deltaT.length
            if (vo2Values.length <= i) continue; // Skip if vo2Values is too short

            const dt_sec = deltaT[i];
            const dt_min = dt_sec / 60;
            const vo2_actual_ml_min = vo2Values[i];
            const vo2_netto_ml_min = Math.max(0, vo2_actual_ml_min - vo2Base);
            totalNetOxygenUtilized_L_for_summary += (vo2_netto_ml_min / 1000.0) * dt_min;

            const current_rq = (effectiveRqPredictedValues && effectiveRqPredictedValues.length > i) ? effectiveRqPredictedValues[i] : 0.85;
            const kAE_kJ_L_current = getKalorischesEquivalent(current_rq).kJ_lO2;
            totalAerobicEnergy_kJ += (vo2_netto_ml_min / 1000) * kAE_kJ_L_current * dt_min;
            totalGrossAerobicEnergy_kJ += (vo2_actual_ml_min / 1000) * kAE_kJ_L_current * dt_min;
        }

        // Calculate Alactic and Lactic Energy
        totalAlacticEnergy_kJ = 0; // Reset for current calculation window
        if (effectiveNetPcrChange_mmol_kg && effectiveDynamicATPYield) { // Use effective arrays
            for (let k = 0; k < effectiveNetPcrChange_mmol_kg.length; k++) {
                if (effectiveNetPcrChange_mmol_kg[k] > 0 && effectiveDynamicATPYield.length > k) {
                    // Ensure current_active_muscle_mass is correctly sourced for Tab 2
                    const current_active_muscle_mass_summary = appState.active_muscle_mass; 
                    totalAlacticEnergy_kJ += effectiveNetPcrChange_mmol_kg[k] * current_active_muscle_mass_summary * (effectiveDynamicATPYield[k] / 1000.0);
                }
            }
        }

        totalLacticEnergy_kJ = 0; // Reset for current calculation window
        // Use the new array 'net_lactic_energy_kj_intervals' from stepData
        let effectiveNetLacticEnergyKJIntervals = stepData.net_lactic_energy_kj_intervals;
        if (appState.calculateSummaryForWindow && appState.customize_time_window && stepData.net_lactic_energy_kj_intervals) {
            // If a window is selected, slice this new array as well
            effectiveNetLacticEnergyKJIntervals = stepData.net_lactic_energy_kj_intervals.slice(startIndex, endIndex);
        }

        if (effectiveNetLacticEnergyKJIntervals) {
            for (let k = 0; k < effectiveNetLacticEnergyKJIntervals.length; k++) {
                totalLacticEnergy_kJ += effectiveNetLacticEnergyKJIntervals[k];
            }
        }
        
        // Calculate Net Lactate Accumulated
        if (laConcMuscleValues && laConcMuscleValues.length > 1) {
            for (let k = 1; k < laConcMuscleValues.length; k++) {
                const lactateChange = laConcMuscleValues[k] - laConcMuscleValues[k-1];
                if (lactateChange > 0) {
                    totalNetLactateAccumulated_mmol_L_for_summary += lactateChange;
                }
            }
        } else if (laConcMuscleValues && laConcMuscleValues.length === 1) {
             totalNetLactateAccumulated_mmol_L_for_summary = Math.max(0, laConcMuscleValues[0] - appState.la_base);
        }

        // Calculate Net PCr Utilized
        if (netPcrChange_mmol_kg_for_summary) {
            for (let k = 0; k < netPcrChange_mmol_kg_for_summary.length; k++) {
                if (netPcrChange_mmol_kg_for_summary[k] > 0) {
                     totalNetPcrUtilized_mmol_kg_for_summary += netPcrChange_mmol_kg_for_summary[k];
                }
            }
        }

        const totalMetabolicWork_kJ = totalAerobicEnergy_kJ + totalAlacticEnergy_kJ + totalLacticEnergy_kJ;
        const percentAerobic = totalMetabolicWork_kJ > 0 ? (totalAerobicEnergy_kJ / totalMetabolicWork_kJ) * 100 : 0;
        const percentAlactic = totalMetabolicWork_kJ > 0 ? (totalAlacticEnergy_kJ / totalMetabolicWork_kJ) * 100 : 0;
        const percentLactic = totalMetabolicWork_kJ > 0 ? (totalLacticEnergy_kJ / totalMetabolicWork_kJ) * 100 : 0;

        // Total CHO and Fat grams
        let totalCHOGrams = 0;
        let totalFatGrams = 0;
        if (carbGramMinValues && fatGramMinValues) {
            for (let i = 0; i < deltaT.length; i++) { // Iterate up to deltaT.length
                if (carbGramMinValues.length <=i || fatGramMinValues.length <=i) continue; // Skip if arrays are too short
                const dt_min = deltaT[i] / 60;
                totalCHOGrams += carbGramMinValues[i] * dt_min;
                totalFatGrams += fatGramMinValues[i] * dt_min;
            }
        }

        // Strain Score and TSS
        const totalStrainScore = (effectiveCumulativeStrainScore && effectiveCumulativeStrainScore.length > 0) ?
                                 effectiveCumulativeStrainScore[effectiveCumulativeStrainScore.length -1] : 0;
        let ssCP = 0, ssWprime = 0, ssPmax = 0;
        if (strainRatesCpValues && strainRatesWprimeValues && strainRatesPmaxValues && cp > 0 && pmax_model > 0) {
            const normalizationFactorSS = (pmax_model / Math.pow(cp, 2)) * (100 / 3600);
            for (let i = 0; i < deltaT.length; i++) { // Iterate up to deltaT.length
                if (strainRatesCpValues.length <= i || strainRatesWprimeValues.length <= i || strainRatesPmaxValues.length <= i) continue;
                const dt_sec = deltaT[i];
                ssCP += strainRatesCpValues[i] * dt_sec * normalizationFactorSS;
                ssWprime += strainRatesWprimeValues[i] * dt_sec * normalizationFactorSS;
                ssPmax += strainRatesPmaxValues[i] * dt_sec * normalizationFactorSS;
            }
        }
        let tss = 0;
        const ftp_for_tss = appState.critical_power;
        const duration_hours = durationSec / 3600;
        if (ftp_for_tss > 0 && durationSec > 0 && normMechanicalPower > 0) { // Ensure normMechanicalPower is also > 0
            const intensityFactor = normMechanicalPower / ftp_for_tss;
            tss = Math.pow(intensityFactor, 2) * duration_hours * 100;
        }

        // Efficiencies
        const eta_gross_val = (totalGrossAerobicEnergy_kJ > 0) ? (totalMechanicalWork_kJ / totalGrossAerobicEnergy_kJ) * 100 : 0;
        const eta_net_val = (totalAerobicEnergy_kJ > 0) ? (totalMechanicalWork_kJ / totalAerobicEnergy_kJ) * 100 : 0;
        const eta_total_val = (totalMetabolicWork_kJ > 0) ? (totalMechanicalWork_kJ / totalMetabolicWork_kJ) * 100 : 0;

        // Update DOM elements
        elements.avg_power.textContent = `${Math.round(avgMechanicalPower)} W`;
        elements.norm_power.textContent = `${Math.round(normMechanicalPower)} W`;
        elements.total_energy.textContent = `${Math.round(totalGrossAerobicEnergy_kJ * 0.239006)} kcal`; // kJ to kcal
        elements.total_work.textContent = `${Math.round(totalMechanicalWork_kJ)} kJ`;
        elements.total_metabolic_work.textContent = `${totalMetabolicWork_kJ.toFixed(1)} kJ | 100%`;
        elements.aerobic_contribution.textContent = `${totalAerobicEnergy_kJ.toFixed(1)} kJ | ${percentAerobic.toFixed(1)}%`;
        if (elements.net_oxygen_utilized) {
            elements.net_oxygen_utilized.textContent = `${totalNetOxygenUtilized_L_for_summary.toFixed(2)} L`;
        }
        elements.lactic_contribution.textContent = `${totalLacticEnergy_kJ.toFixed(1)} kJ | ${percentLactic.toFixed(1)}%`;
        if (elements.net_lactate_accumulated_muscle) {
            elements.net_lactate_accumulated_muscle.textContent = `${totalNetLactateAccumulated_mmol_L_for_summary.toFixed(2)} mmol·l⁻¹`;
        }
        elements.alactic_contribution.textContent = `${totalAlacticEnergy_kJ.toFixed(1)} kJ | ${percentAlactic.toFixed(1)}%`;
        if (elements.net_pcr_utilized_muscle) {
            elements.net_pcr_utilized_muscle.textContent = `${totalNetPcrUtilized_mmol_kg_for_summary.toFixed(1)} mmol·kg⁻¹`;
        }
        elements.work_above_cp.textContent = `${Math.round(workAboveCP_kJ)} kJ`;
        elements.cho_utilization.textContent = `${Math.round(totalCHOGrams)} g`;
        elements.fat_utilization.textContent = `${Math.round(totalFatGrams)} g`;
        elements.tss_value.textContent = `${Math.round(tss)}`;
        elements.total_ss.textContent = `${Math.round(totalStrainScore)}`;
        elements.ss_cp.textContent = `${Math.round(ssCP)}`;
        elements.ss_wprime.textContent = `${Math.round(ssWprime)}`;
        elements.ss_pmax.textContent = `${Math.round(ssPmax)}`;
        elements.eta_gross.textContent = `${eta_gross_val.toFixed(1)}%`;
        elements.eta_net.textContent = `${eta_net_val.toFixed(1)}%`;
        elements.eta_total.textContent = `${eta_total_val.toFixed(1)}%`;
    }
    
        
    
       // Function to update the step test plot in Tab 2
       function updateStepTestPlot() {
        // Speichere den aktuellen Sichtbarkeitsstatus aller Kurven, wenn ein Plot existiert
        const plotContainer = document.getElementById('steptest-plot-container');
        if (plotContainer && plotContainer._fullData) {
            const existingTraces = plotContainer._fullData || [];

            for (let i = 0; i < existingTraces.length; i++) {
                if (existingTraces[i].name) {
                    appState.traceVisibility[existingTraces[i].name] = existingTraces[i].visible !== 'legendonly';
                }
            }
        }

        const stepData = calculateStepTest();

        // Use time directly in seconds
        // Add checks for potentially undefined stepData or time_sec
        const timeSec = (stepData && stepData.time_sec) ? stepData.time_sec : [0];
        if (timeSec.length === 0) {
            console.warn("No time data available for step test plot.");
             // Optionally clear the plot or show a message
             Plotly.purge('steptest-plot-container');
             // Maybe display a message in the plot container
             document.getElementById('steptest-plot-container').innerHTML = '<p style="text-align:center; padding-top:50px;">No data to display. Load data or adjust parameters.</p>';
            return; // Exit if no time data
        }


        // Determine max time for X-Axis (110% of last valid time)
        const maxTimeValue = Math.max(...timeSec) * 1.10;

        // Calculate max power value for Y-Axis - use the greater of pmax or actual max power
        const maxPowerInData = (stepData.power && stepData.power.length > 0) ? Math.max(...stepData.power.filter(p => !isNaN(p))) : 0;
        const maxMPAInData = (stepData.mpa && stepData.mpa.length > 0) ? Math.max(...stepData.mpa.filter(p => !isNaN(p))) : 0;
        const maxPowerValue = Math.max(maxPowerInData, maxMPAInData, appState.pmax) * 1.05;


        // Set lactate Y-Axis max value (initial estimate for y2)
        const maxLaktatValue = appState.la_max + 5;

        // Find the minimum W' balance value (initial estimate for y2)
        const minWprimeValue = (stepData.w_prime_bal && stepData.w_prime_bal.length > 0) ? Math.min(...stepData.w_prime_bal.filter(w => !isNaN(w))) : 0;

        // Calculate min and max PD value for Y-Axis (initial estimate for y2)
        const minPDValue = (stepData.PD && stepData.PD.length > 0) ? Math.min(...stepData.PD.filter(pd => !isNaN(pd))) : 0;
        const maxPDValue = (stepData.PD && stepData.PD.length > 0) ? Math.max(...stepData.PD.filter(pd => !isNaN(pd))) : 0;

        // Calculate min/max of SCALED HR for yaxis2 range
        const scaledHrValues = (stepData.HR_actual && stepData.HR_actual.length > 0)
            ? stepData.HR_actual.map(hr => hr / 10).filter(hr => !isNaN(hr))
            : [(appState.use_tab1_params ? appState.HR_Base : appState.HR_Base_step) / 10]; // Default scaled base HR if no data

        const minScaledHRValue = scaledHrValues.length > 0 ? Math.min(...scaledHrValues) : 3; // Default min scaled HR (e.g., 30/10)
        const maxScaledHRValue = scaledHrValues.length > 0 ? Math.max(...scaledHrValues) : 23; // Default max scaled HR (e.g., 230/10)

        // Calculate max values for glycogen Y-Axis
        // const maxGlycogenValue = Math.max(appState.glycogen_max, appState.glycogen_init) * 1.1; // Not used for y2 range directly

            // Calculate min and max HR for yaxis2 range adjustment
            const minHRValue = (stepData.HR_actual && stepData.HR_actual.length > 0) ? Math.min(...stepData.HR_actual.filter(hr => !isNaN(hr))) : (appState.use_tab1_params ? appState.HR_Base : appState.HR_Base_step);
            const maxHRValue = (stepData.HR_actual && stepData.HR_actual.length > 0) ? Math.max(...stepData.HR_actual.filter(hr => !isNaN(hr))) : (appState.use_tab1_params ? appState.HR_max : appState.HR_max_step);

        // Set Y-Axis limits for W' balance / Lactate / PCr / pHm / RQ / HR axis (y2)
        let wprimeYmin = Math.max(-10, Math.min(minWprimeValue, minPDValue)); // Start range estimation
        let wprimeYmax = Math.max(maxLaktatValue, appState.w_prime, maxPDValue); // Start estimate

        // Include PCr range if applicable
        if (stepData.pcr_store) { // Check if pcr_store exists
            const maxPcr = stepData.pcr_store.length > 0 ? Math.max(...stepData.pcr_store.filter(pcr => !isNaN(pcr))) : appState.pcr_init;
            wprimeYmax = Math.max(wprimeYmax, maxPcr); // Don't scale max PCR yet
            const minPcr = stepData.pcr_store.length > 0 ? Math.min(...stepData.pcr_store.filter(pcr => !isNaN(pcr))) : 0;
            wprimeYmin = Math.min(wprimeYmin, minPcr);
        }

        // Include scaled RQ range
        let rqMinScaled = 7; // Default min scaled RQ
        let rqMaxScaled = 10; // Default max scaled RQ
        if (stepData.rqPredictedScaled && stepData.rqPredictedScaled.length > 0) {
            const validRQs = stepData.rqPredictedScaled.filter(rq => !isNaN(rq));
            if (validRQs.length > 0) {
                rqMinScaled = Math.min(...validRQs);
                rqMaxScaled = Math.max(...validRQs);
            }
        }
        wprimeYmin = Math.min(wprimeYmin, rqMinScaled); // Use scaled RQ min
        wprimeYmax = Math.max(wprimeYmax, rqMaxScaled); // Use scaled RQ max

        // Include scaled HR range
        wprimeYmin = Math.min(wprimeYmin, minScaledHRValue); // Use scaled HR min
        wprimeYmax = Math.max(wprimeYmax, maxScaledHRValue); // Use scaled HR max

        // Apply final padding/floor *after* considering all variables
        wprimeYmin = Math.max(-10, wprimeYmin * 0.95); // Apply floor and slight padding
        wprimeYmax = wprimeYmax * 1.05; // Apply padding

        // Use custom Y-Axis values if set, otherwise use calculated defaults
        const usePowerMax = appState.customize_y_axis ? appState.view_power_max : maxPowerValue;
        const useVO2Max = appState.customize_y_axis ? appState.view_vo2_max : (appState.use_tab1_params ? appState.VO2max * 1.05 : appState.VO2max_step * 1.05);

        // THESE VALUES ARE USED FOR THE Y2 AXIS RANGE IN THE LAYOUT BELOW
        const useLactateMin = appState.customize_y_axis ? appState.view_lactate_min : wprimeYmin;
        const useLactateMax = appState.customize_y_axis ? appState.view_lactate_max : wprimeYmax;

        // Create traces for the plot
        const traces = [];

                // --- Dynamic ATP Yield (-ΔG_ATP,cyt) Trace ---
                // Values are in kJ/mol. We will scale them by 100 for plotting on yaxis3.
                // The original kJ/mol values will be stored in customdata for hover.
                if (stepData.dynamic_ATP_yield_kJ_mol_values && stepData.dynamic_ATP_yield_kJ_mol_values.length > 0) {
                    const deltaG_kJ_mol_original = stepData.dynamic_ATP_yield_kJ_mol_values;
                    const deltaG_scaled_for_plot = deltaG_kJ_mol_original.map(kj => kj * 100); // Scale by 100

                    traces.push({
                        x: timeSec,
                        y: deltaG_scaled_for_plot, // Plot scaled values
                        customdata: deltaG_kJ_mol_original, // Store original values for hover
                        name: "-ΔG<sub>ATP</sub> ⋅ 100", // Update name to reflect scaling
                        type: 'scatter',
                        mode: 'lines',
                        yaxis: "y3", // On V̇O₂ / O₂ Deficit axis
                        line: {color: '#F39B7F', width: 1.5, dash: 'longdash', opacity: 0.9},
                        showlegend: true,
                        hovertemplate: '<b>-ΔG<sub>ATP</sub></b><br>' +
                                    'Time: %{x} s<br>' +
                                    'Value: %{customdata:.1f} kJ·mol<sup>-1</sup><extra></extra>' // Show original kJ/mol on hover
                    });
                }

            // --- pHm Trace ---
            if (stepData.pHm) {
            traces.push({
                x: timeSec,
                y: stepData.pHm,
                name: "pH<sub>m</sub>",
                type: 'scatter',
                mode: 'lines',
                yaxis: "y2",
                line: {color: '#FF7F00', width: 1.5, dash: 'dash', opacity: 0.8},
                showlegend: true,
                // Added hovertemplate
                hovertemplate: '<b>pH<sub>m</sub></b><br>' +
                               'Time: %{x} s<br>' +
                               'Value: %{y:.2f}<extra></extra>' // Format pH to 2 decimal places
            });
        }

        // --- RQ Predicted Trace ---
        if (stepData.rqPredictedScaled) {
                traces.push({
                    x: timeSec,
                    y: stepData.rqPredictedScaled, // Plot scaled data (Value * 10)
                    // Add customdata with the actual (unscaled) RQ values
                    customdata: stepData.rqPredictedScaled.map(rqs => rqs / 10),
                    name: "RQ<sub>predicted</sub> ⋅ 10",
                    type: 'scatter',
                    mode: 'lines',
                    yaxis: "y2",
                    line: {color: '#FFC34C', width: 1.5, dash: 'dash'},
                    showlegend: true,
                    // Added hovertemplate using customdata for actual RQ
                    hovertemplate: '<b>RQ Predicted</b><br>' +
                                   'Time: %{x} s<br>' +
                                   'Value: %{customdata:.3f}<extra></extra>' // Show actual RQ with 3 decimal places
            });
        }

        // --- Power curve ---
        if (stepData.power) {
            traces.push({
                x: timeSec,
                y: stepData.power,
                name: "Power",
                type: 'scatter',
                mode: 'lines',
                yaxis: "y",
                line: {color: 'darkgrey', width: 1.5, opacity: 0.8},
                showlegend: true,
                // Added hovertemplate
                hovertemplate: '<b>Power</b><br>' +
                               'Time: %{x} s<br>' +
                               'Value: %{y:.0f} W<extra></extra>' // Format Power to 0 decimal places
            });
        }

        // --- Cadence data ---
        if (stepData.cadence && appState.cadence_dependent_step) {
            traces.push({
                x: timeSec,
                y: stepData.cadence,
                name: "Cadence",
                type: 'scatter',
                mode: 'lines',
                yaxis: "y",
                line: {color: 'lightgray', dash: 'dash', width: 1.5, opacity: 0.8},
                showlegend: true,
                // Added hovertemplate
                hovertemplate: '<b>Cadence</b><br>' +
                               'Time: %{x} s<br>' +
                               'Value: %{y:.0f} rpm<extra></extra>' // Format Cadence to 0 decimal places
            });
        }

        // --- W' Balance curve ---
        if (stepData.w_prime_bal) {
            traces.push({
                x: timeSec,
                y: stepData.w_prime_bal,
                name: "W' Balance",
                type: 'scatter',
                mode: 'lines',
                yaxis: "y2",
                line: {color: '#42BA97', width: 2, opacity: 0.8},
                showlegend: true,
                // Added hovertemplate
                hovertemplate: '<b>W\' Balance</b><br>' +
                               'Time: %{x} s<br>' +
                               'Value: %{y:.1f} kJ<extra></extra>' // Format W' Balance to 1 decimal place
            });
        }

        // --- MPA (Maximum Power Available) curve ---
        if (stepData.mpa) {
            traces.push({
                x: timeSec,
                y: stepData.mpa,
                name: "MPA",
                type: 'scatter',
                mode: 'lines',
                yaxis: "y",
                line: {color: '#607D8B', width: 1.5, dash: 'dot', opacity: 0.8},
                showlegend: true,
                // Added hovertemplate
                hovertemplate: '<b>MPA</b><br>' +
                               'Time: %{x} s<br>' +
                               'Value: %{y:.0f} W<extra></extra>' // Format MPA to 0 decimal places
            });
        }

        // --- Cumulative Strain Score ---
        if (stepData.cumulative_strain_score) {
            traces.push({
                x: timeSec,
                y: stepData.cumulative_strain_score,
                name: "Strain Score",
                type: 'scatter',
                mode: 'lines',
                yaxis: "y", // Still on primary Y axis
                line: {color: '#F06292', width: 1.5, opacity: 0.8,  dash: 'dash'},
                showlegend: true,
                // Added hovertemplate
                hovertemplate: '<b>Strain Score</b><br>' +
                               'Time: %{x} s<br>' +
                               'Value: %{y:.1f}<extra></extra>' // Format Strain Score to 1 decimal place
            });
        }

        // --- VO2 curve ---
        if (stepData.VO2) {
            traces.push({
                x: timeSec,
                y: stepData.VO2,
                name: "V̇O<sub>2</sub>",
                type: 'scatter',
                mode: 'lines',
                yaxis: "y3",
                line: {color: '#2683C6', width: 1.5, opacity: 0.8},
                showlegend: true,
                // Added hovertemplate
                hovertemplate: '<b>V̇O<sub>2</sub></b><br>' +
                               'Time: %{x} s<br>' +
                               'Value: %{y:.0f} ml·min<sup>-1</sup><extra></extra>' // Format VO2 to 0 decimal places
            });
        }

            // V̇O₂ Demand curve (now includes slow component if stepData.vo2_demand is totalVo2DemandWithSlowComp)
            traces.push({
                x: timeSec,
                y: stepData.vo2_demand, // This should now be totalVo2DemandWithSlowComp
                name: "Total V̇O<sub>2</sub> Demand", // Updated name
                type: 'scatter',
                mode: 'lines',
                yaxis: "y3",
                line: {color: '#2683C6', dash: 'dot', width: 1.5},
                showlegend: true,
                hovertemplate: '<b>Total V̇O<sub>2</sub> Demand</b><br>' +
                            'Time: %{x} s<br>' +
                            'Value: %{y:.0f} ml·min<sup>-1</sup><extra></extra>'
            });

            // O2 Deficit Area (hover info might not be ideal for area fill)
            // Ensure stepData.vo2_demand (which is now totalVo2DemandWithSlowComp) and stepData.VO2 are valid
            if (stepData.vo2_demand && stepData.VO2 && stepData.vo2_demand.length === timeSec.length && stepData.VO2.length === timeSec.length) {
                traces.push({
                    x: [...timeSec, ...timeSec.slice().reverse()],
                    y: [...stepData.vo2_demand, ...stepData.VO2.slice().reverse()], // stepData.vo2_demand is now totalVo2DemandWithSlowComp
                    name: "O<sub>2</sub> Deficit Area",
                    type: 'scatter',
                    mode: 'none',
                    yaxis: "y3",
                    fill: 'toself',
                    fillcolor: 'rgba(38, 131, 198, 0.2)',
                    line: {width: 0},
                    showlegend: true,
                    hoverinfo: 'skip' // Skip hover info for the fill area
                });
            }

        // --- HR Trace --- (Already adjusted in previous step)
        if (stepData.HR_actual) {
            traces.push({
                x: timeSec,
                y: stepData.HR_actual.map(hr => hr / 10),
                customdata: stepData.HR_actual,
                name: "Heart Rate ⋅ 10⁻¹",
                type: 'scatter',
                mode: 'lines',
                yaxis: "y2",
                line: {color: '#388E3C', dash: 'dash', width: 1.5, opacity: 0.8},
                showlegend: true,
                hovertemplate: '<b>Heart Rate</b><br>' +
                               'Time: %{x} s<br>' +
                               'Value: %{customdata:.0f} bpm<extra></extra>'
            });
        }

        // --- Lactate (Muscle) ---
        if (stepData.La_conc) {
            traces.push({
                x: timeSec,
                y: stepData.La_conc,
                name: "Lactate (Muscle)",
                type: 'scatter',
                mode: 'lines',
                yaxis: "y2",
                line: {color: '#C8133B', width: 2, opacity: 0.8},
                showlegend: true,
                // Added hovertemplate
                hovertemplate: '<b>Lactate (Muscle)</b><br>' +
                               'Time: %{x} s<br>' +
                               'Value: %{y:.1f} mM<extra></extra>' // Format Lactate to 1 decimal place
            });
        }

        // --- Lactate (Blood) ---
        if (stepData.La_conc_b) {
            traces.push({
                x: timeSec,
                y: stepData.La_conc_b,
                name: "Lactate (Blood)",
                type: 'scatter',
                mode: 'lines',
                yaxis: "y2",
                line: {color: '#7F0000', width: 2, dash: 'dash'},
                showlegend: true,
                // Added hovertemplate
                hovertemplate: '<b>Lactate (Blood)</b><br>' +
                               'Time: %{x} s<br>' +
                               'Value: %{y:.1f} mM<extra></extra>' // Format Lactate to 1 decimal place
            });
        }

        // --- vLass curve ---
        if (stepData.vLass_min) {
            traces.push({
                x: timeSec,
                y: stepData.vLass_min,
                name: "vLa<sub>SS</sub>",
                type: 'scatter',
                mode: 'lines',
                yaxis: "y2",
                line: {color: '#EF5350', dash: 'dot', width: 1.5, opacity: 0.8},
                showlegend: true,
                // Added hovertemplate
                hovertemplate: '<b>vLa<sub>SS</sub></b><br>' +
                               'Time: %{x} s<br>' +
                               'Value: %{y:.3f} mM/min<extra></extra>' // Format rate to 3 decimal places
            });
        }

        // --- vLaox curve ---
        if (stepData.vLaox_min) {
            traces.push({
                x: timeSec,
                y: stepData.vLaox_min,
                name: "vLa<sub>ox</sub>",
                type: 'scatter',
                mode: 'lines',
                yaxis: "y2",
                line: {color: '#1CADE4', dash: 'dot', width: 1.5, opacity: 0.8},
                showlegend: true,
                // Added hovertemplate
                hovertemplate: '<b>vLa<sub>ox</sub></b><br>' +
                               'Time: %{x} s<br>' +
                               'Value: %{y:.3f} mM/min<extra></extra>' // Format rate to 3 decimal places
            });
        }

        // --- Pyruvate deficit (PD) curve ---
        if (stepData.PD) {
            traces.push({
                x: timeSec,
                y: stepData.PD,
                name: "PD",
                type: 'scatter',
                mode: 'lines',
                yaxis: "y2",
                line: {color: '#9C85C0', width: 1.5, opacity: 0.8},
                showlegend: true,
                // Added hovertemplate
                hovertemplate: '<b>PD</b><br>' +
                               'Time: %{x} s<br>' +
                               'Value: %{y:.3f} mM/min<extra></extra>' // Format rate to 3 decimal places
            });
        }

        // --- Glycogen Store Curve ---
        if (stepData.glycogen_store) {
            traces.push({
                x: timeSec,
                y: stepData.glycogen_store,
                name: "Glycogen Stores",
                type: 'scatter',
                mode: 'lines',
                yaxis: "y", // Back to primary Y axis
                line: {color: '#AD1457', dash: 'dash', width: 2, opacity: 0.8},
                showlegend: true,
                // Added hovertemplate
                hovertemplate: '<b>Glycogen</b><br>' +
                               'Time: %{x} s<br>' +
                               'Value: %{y:.1f} g<extra></extra>' // Format Glycogen to 1 decimal place
            });
        }

        // --- PCr Store & Accumulated O2 Deficit ---
        if (stepData.pcr_store && stepData.accumulated_o2_deficit) {
            // PCr store curve
            traces.push({
                x: timeSec,
                y: stepData.pcr_store,
                name: "PCr Store",
                type: 'scatter',
                mode: 'lines',
                yaxis: "y2",
                line: {color: '#FFEB3B', dash: 'dot', width: 2, opacity: 0.8},
                showlegend: true,
                // Added hovertemplate
                hovertemplate: '<b>PCr Store</b><br>' +
                               'Time: %{x} s<br>' +
                               'Value: %{y:.1f} mM/kg<extra></extra>' // Format PCr to 1 decimal place
            });

            // Accumulated O2 deficit curve
            traces.push({
                x: timeSec,
                y: stepData.accumulated_o2_deficit,
                name: "Acc. O<sub>2</sub> Deficit",
                type: 'scatter',
                mode: 'lines',
                yaxis: "y3",
                line: {color: '#0097A7', dash: 'dash', width: 1.5, opacity: 0.8},
                showlegend: true,
                // Added hovertemplate
                hovertemplate: '<b>Acc. O<sub>2</sub> Deficit</b><br>' +
                               'Time: %{x} s<br>' +
                               'Value: %{y:.0f} ml<extra></extra>' // Format O2 Deficit to 0 decimal places
            });
        }

        // --- Total Excess Energy (O₂ Eq.) ---
        if (stepData.total_excess_energy_o2_eq_ml_min && stepData.total_excess_energy_o2_eq_ml_min.length > 0) {
            traces.push({
                x: timeSec,
                y: stepData.total_excess_energy_o2_eq_ml_min,
                name: "Total Excess Energy (O₂ Eq.)",
                type: 'scatter',
                mode: 'lines',
                yaxis: "y3", // On V̇O₂ / O₂ Deficit axis
                line: {color: '#BF360C', width: 1.5, dash: 'solid', opacity: 0.7}, // Choose a distinct color
                showlegend: true,
                hovertemplate: '<b>Total Excess Energy (O₂ Eq.)</b><br>' +
                            'Time: %{x} s<br>' +
                            'Value: %{y:.0f} ml·min<sup>-1</sup> O₂ Eq.<extra></extra>'
            });
        }

        // --- Zero line ---
        if (timeSec.length > 0) {
            traces.push({
                x: [Math.min(...timeSec), Math.max(...timeSec)],
                y: [0, 0],
                name: "Zero Line",
                type: 'scatter',
                mode: 'lines',
                yaxis: "y2",
                line: {color: '#666666', dash: 'dot', width: 1, opacity: 0.4},
                showlegend: false,
                hoverinfo: 'skip' // Skip hover for the zero line
            });
        }

        // Annotations for abort criteria if reached
        const annotations = [];
        if (stepData.abort_power !== null) {
            let reasonText = ""; // Variable für den spezifischen Grund
            let yValueForReasonAnnotation = stepData.abort_power; // Standard Y-Wert für die Haupt-Annotation
            let yRefForReasonAnnotation = "y"; // Standard Y-Achsenreferenz

            // Detaillierteren Grund basierend auf stepData.abort_reason hinzufügen
            switch(stepData.abort_reason) {
                case "lactate":
                    reasonText = ": Lactate too high";
                    // Annotation für Laktat-Grenze (bleibt wie gehabt oder leicht angepasst)
                    annotations.push({
                        x: stepData.abort_time,
                        y: appState.la_max, // Der tatsächliche Grenzwert
                        yref: "y2",
                        text: `Limit: La ${appState.la_max.toFixed(1)} mM`,
                        showarrow: true, arrowhead: 7, arrowsize: 1, arrowwidth: 1.5, arrowcolor: '#C8133B',
                        ax: 40, ay: -15, bgcolor: 'rgba(255,255,255,0.7)', bordercolor: '#C8133B', borderwidth:1, font: {size: 9}
                    });
                    break;
                case "wbalance":
                    reasonText = ": W' Balance too low";
                    // Annotation für W'Balance-Grenze
                    annotations.push({
                        x: stepData.abort_time,
                        y: appState.w_prime_balance_min, // Der tatsächliche Grenzwert
                        yref: "y2",
                        text: `Limit: W'Bal ${appState.w_prime_balance_min.toFixed(1)} kJ`,
                        showarrow: true, arrowhead: 7, arrowsize: 1, arrowwidth: 1.5, arrowcolor: '#42BA97',
                        ax: 40, ay: 15, bgcolor: 'rgba(255,255,255,0.7)', bordercolor: '#42BA97', borderwidth:1, font: {size: 9}
                    });
                    break;
                case "glycogen":
                    reasonText = ": Glycogen depleted";
                    // Annotation für Glykogen-Grenze
                    annotations.push({
                        x: stepData.abort_time,
                        y: 0, // Glykogen ist auf der primären y-Achse
                        yref: "y",
                        text: `Limit: Glycogen 0g`,
                        showarrow: true, arrowhead: 7, arrowsize: 1, arrowwidth: 1.5, arrowcolor: '#AD1457',
                        ax: 40, ay: -30, bgcolor: 'rgba(255,255,255,0.7)', bordercolor: '#AD1457', borderwidth:1, font: {size: 9}
                    });
                    break;
                case "pcr": // Neuer Fall für PCr
                    reasonText = ": PCr depleted";
                    // Annotation für PCr-Grenze (PCr ist auf y2-Achse)
                    annotations.push({
                        x: stepData.abort_time,
                        y: 2.0, // Der Abbruchwert für PCr
                        yref: "y2",
                        text: `Limit: PCr ≤ 2.0 mM/kg`,
                        showarrow: true, arrowhead: 7, arrowsize: 1, arrowwidth: 1.5, arrowcolor: '#FFEB3B', // Farbe anpassen, falls gewünscht
                        ax: 40, ay: 0, bgcolor: 'rgba(255,255,255,0.7)', bordercolor: '#FFEB3B', borderwidth:1, font: {size: 9}
                    });
                    break;
                default:
                    reasonText = ""; // Falls kein spezifischer Grund bekannt
            }

            // Haupt-Abbruchnachricht erstellen, die den Grund beinhaltet
            let abortText = `<b>Abort</b> at ${Math.round(stepData.abort_power)} W, ${Math.floor(stepData.abort_time/60)}:${(stepData.abort_time % 60).toString().padStart(2, '0')} min:s${reasonText}`;

            annotations.push({
                x: stepData.abort_time,
                y: stepData.abort_power, // Y-Position bezogen auf die Power-Achse
                yref: "y",
                text: abortText,
                showarrow: true,
                arrowhead: 2,
                arrowsize: 1.2,
                arrowwidth: 2,
                arrowcolor: '#EF5350', // Accent color für Haupt-Abbruchnachricht
                ax: 0,
                ay: -40, // Leicht weiter oben positionieren, um Platz für spezifische Annotationen zu lassen
                font: {
                    color: '#EF5350',
                    size: 11,
                    family: 'Roboto, sans-serif'
                },
                bgcolor: 'rgba(255,255,255,0.8)',
                bordercolor: '#EF5350',
                borderwidth: 1,
                borderpad: 4,
                align: 'center'
            });
        }

        // Formula text for CE relationship
        let formulaText = '';
        const effectiveVO2Base = appState.use_tab1_params ? appState.VO2Base : appState.VO2Base_step;

        if (stepData.is_curvilinear) {
            formulaText = `V̇O<sub>2,SS</sub> (P) = ${stepData.a_opt ? stepData.a_opt.toFixed(4) : 'N/A'} · P² + ${stepData.ce_range[0].toFixed(1)} · P + ${Math.round(effectiveVO2Base)}`;
        } else {
            const effectiveCE = appState.use_tab1_params ? appState.CEVO2 : appState.CEVO2_step;
            formulaText = `V̇O<sub>2,SS</sub> (P) = ${effectiveCE.toFixed(1)} · P + ${Math.round(effectiveVO2Base)}`;
        }

        // Add cadence info if cadence dependency is enabled
        if (appState.cadence_dependent_step) {
            // Determine which cadence to display (fixed or file-based)
            const cadenceSource = appState.use_file_cadence ? "file" : `${appState.cadence_step} rpm`;
             formulaText += `<br>(at cadence: ${cadenceSource})`;
        }

        // Add formula annotation only if data exists
        if (timeSec.length > 0) {
            annotations.push({
                x: (timeSec.length > 1 ? timeSec[Math.floor(timeSec.length * 0.1)] : timeSec[0]), // Position near start
                y: (appState.use_tab1_params ? appState.VO2max * 0.90 : appState.VO2max_step * 0.90), // Position high on VO2 axis
                text: formulaText,
                showarrow: false,
                font: {
                    family: "Arial",
                    size: 10, // Slightly smaller for potentially longer text
                    color: "#666666"
                },
                xanchor: "left",
                yanchor: "top",
                yref: "y3" // Referencing VO2 axis
            });
        }

        // Create layout for the plot
        let layout = {
            title: {
                text: "Exercise Simulation",
                font: {
                    size: 18,
                    color: '#2683C6'
                }
            },
            margin: {l: 80, r: 80, t: 90, b: 80},
            xaxis: {
                title: {
                    text: "Time (s)",
                    font: {
                        size: 14
                    }
                },
                range: [appState.customize_time_window ? appState.view_time_start : Math.min(...timeSec),
                        appState.customize_time_window ? appState.view_time_end : maxTimeValue],
                showgrid: true,
                gridcolor: 'rgba(200,200,200,0.2)'
            },
            yaxis: {
                title: {
                    text: "Power (W) / Cadence (rpm) / Glycogen (g) / MPA / SS", // Original Title
                    font: {
                        size: 12 // Original size or adjust if needed
                    }
                },
                range: [0, usePowerMax],
                showgrid: true,
                gridcolor: 'rgba(200,200,200,0.2)',
                side: 'left'
            },
            yaxis2: {
                title: {
                    text: "Lactate / Rates / PCr / W' / pH<sub>m</sub> / RQ<sub>predicted</sub> ⋅ 10, HR ⋅ 10⁻¹",
                    font: {
                         size: 12 // Ggf. Schriftgröße anpassen
                    }
                },
                overlaying: "y",
                side: "right",
                range: [useLactateMin, useLactateMax], // Originale Range-Berechnung beibehalten
                showgrid: false,
                 zeroline: true, // NEU: Explizite Nulllinie für y2
                 zerolinecolor: '#cccccc',
                 zerolinewidth: 1
            },
            yaxis3: {
                title: {
                    text: "V̇O<sub>2</sub> (ml·min⁻¹) / O<sub>2</sub> Deficit (ml) / -ΔG (kJ·mol<sup>-1</sup> ⋅ 100)",
                    font: {
                        size: 12
                    }
                },
                overlaying: "y",
                side: "right",
                anchor: "free",
                position: 0.95, // Positioned slightly left of yaxis2
                range: [0, useVO2Max],
                showgrid: false
            },
            showlegend: true,
                legend: {
                x: 0.5,
                y: 1.10,
                xanchor: 'center',
                yanchor: 'top',
                orientation: 'h',
                bgcolor: 'rgba(255, 255, 255, 0)',
                bordercolor: 'rgba(0,0,0,0)',
                borderwidth: 0
            },
            annotations: annotations,
            paper_bgcolor: 'rgba(255,255,255,0)',
            plot_bgcolor: 'rgba(255,255,255,0.5)',
            hovermode: 'closest'
        };

        // Wende den gespeicherten Sichtbarkeitsstatus auf die neuen Traces an
        for (let i = 0; i < traces.length; i++) {
            if (traces[i].name && appState.traceVisibility[traces[i].name] === false) {
                traces[i].visible = 'legendonly';
            }
        }

        // Standardmäßig bestimmte Kurven ausblenden, wenn keine gespeicherten Einstellungen vorhanden sind
        if (Object.keys(appState.traceVisibility).length === 0) {
            // Liste der Kurven, die standardmäßig ausgeblendet sein sollen
            // NEU: pHm zur Liste hinzugefügt
            const hiddenTraces = ["PD", "Acc. O<sub>2</sub> Deficit", "Strain Score","RQ<sub>predicted</sub> ⋅ 10", "Glycogen Stores", "W' Balance", "MPA", "-ΔG<sub>ATP</sub> ⋅ 100", "Heart Rate ⋅ 10⁻¹"]; //  "vLa<sub>SS</sub>", "vLa<sub>ox</sub>"
        
            for (let i = 0; i < traces.length; i++) {
                if (traces[i].name && hiddenTraces.includes(traces[i].name)) {
                    traces[i].visible = 'legendonly';
                    appState.traceVisibility[traces[i].name] = false; // Store initial hidden state
                } else if (traces[i].name && !(traces[i].name in appState.traceVisibility)) {
                     appState.traceVisibility[traces[i].name] = true; // Store initial visible state
                }
            }
        }

        // Erstelle den Plot mit den aktualisierten Traces
        Plotly.newPlot('steptest-plot-container', traces, layout, {
            displayModeBar: true,
            responsive: true
        });

        // Update exercise summary statistics
        updateExerciseSummary(stepData);
    }
    

    // Function to show notification
    function showNotification(message, type = 'info') {
        elements.notification.innerHTML = message;
        elements.notification.className = `notification ${type}`;
        elements.notification.style.display = 'block';
        
        // Hide after 3 seconds
        setTimeout(() => {
            elements.notification.style.display = 'none';
        }, 3000);
    }
    
    // Function to update Critical Power from MLSS
    function updateCriticalPowerFromMlss() {
        if (appState.use_mlss_as_cp && appState.mlss_value) {
            appState.critical_power = appState.mlss_value;
            elements.critical_power.value = appState.mlss_value;
            elements.critical_powerValue.textContent = appState.mlss_value;
            
            // Disable the slider if the checkbox is checked
            elements.critical_power.disabled = true;
        }
    }
    
    // Function to calculate delta efficiency (Δη) from CE value
    function calculateDeltaEfficiency(ceValue, rq = null) {
        if (rq !== null) {
            // If RQ is provided, use specific caloric equivalent
            const kalorischesEquivalent = getKalorischesEquivalent(rq);
            const eta = 1 / ((ceValue * kalorischesEquivalent.kJ_lO2) / 60);
            return {
                min: eta * 100,
                max: eta * 100
            };
        } else {
            // Without RQ, use the range approach
            // Caloric equivalent range based on RQ values
            const calorEquivalentMin = 21.131; // Lower bound
            const calorEquivalentMax = 19.619; // Upper bound
            
            // Calculate efficiency range (expressed as decimal)
            const etaMin = 1 / ((ceValue * calorEquivalentMin) / 60);
            const etaMax = 1 / ((ceValue * calorEquivalentMax) / 60);
            
            // Return range as percentage values
            return {
                min: etaMin * 100,
                max: etaMax * 100
            };
        }
    }

    // Function to calculate RQ based on carbohydrate percentage
    function calculateRQ(carbPercentage) {
        // Linear relationship: 0% CHO = 0.70 RQ, 100% CHO = 1.00 RQ
        return 0.70 + (carbPercentage / 100) * 0.30;
    }

    // Function to get caloric equivalent based on RQ using Stegemann's table
    function getKalorischesEquivalent(rq) {
        // Stegemann data (1990)
        const stegemann = {
            rq: [0.700, 0.710, 0.720, 0.730, 0.740, 0.750, 0.760, 0.770, 0.780, 0.790, 
                0.800, 0.810, 0.820, 0.830, 0.840, 0.850, 0.860, 0.870, 0.880, 0.890, 
                0.900, 0.910, 0.920, 0.930, 0.940, 0.950, 0.960, 0.970, 0.980, 0.990, 1.000],
            kJ_lO2: [19.619, 19.636, 19.686, 19.737, 19.791, 19.841, 19.887, 19.946, 20.009, 20.046, 
                    20.101, 20.151, 20.201, 20.256, 20.306, 20.356, 20.411, 20.461, 20.515, 20.561, 
                    20.616, 20.666, 20.716, 20.771, 20.821, 20.871, 20.926, 20.976, 21.026, 21.081, 21.131],
            kcal_lO2: [4.686, 4.690, 4.702, 4.714, 4.727, 4.739, 4.750, 4.764, 4.779, 4.788, 
                    4.801, 4.813, 4.825, 4.838, 4.850, 4.862, 4.875, 4.887, 4.900, 4.911, 
                    4.924, 4.936, 4.948, 4.961, 4.973, 4.985, 4.998, 5.010, 5.022, 5.035, 5.047]
        };
    
    // Ensure RQ is within valid range
    const boundedRQ = Math.max(0.70, Math.min(1.00, rq));
    
    // Find closest RQ value in table
    let closestIdx = 0;
    let minDiff = Math.abs(boundedRQ - stegemann.rq[0]);
    
    for (let i = 1; i < stegemann.rq.length; i++) {
        const diff = Math.abs(boundedRQ - stegemann.rq[i]);
        if (diff < minDiff) {
            minDiff = diff;
            closestIdx = i;
        }
    }
    
    // Return both kJ and kcal values
    return {
        kJ_lO2: stegemann.kJ_lO2[closestIdx],
        kcal_lO2: stegemann.kcal_lO2[closestIdx]
    };
}

// Function to calculate efficiency values
function calculateEfficiency(power, vo2, rq, vo2base) {
    // Get caloric equivalent based on RQ
    const kalorischesEquivalent = getKalorischesEquivalent(rq);
    
    // Power in watts = J/s
    const powerKJ_min = power * 0.06; // Convert W to kJ/min (W * 60s / 1000)
    
    // VO2 in L/min
    const vo2L_min = vo2 / 1000;
    
    // Energy expenditure in kJ/min
    const energyExpenditure = vo2L_min * kalorischesEquivalent.kJ_lO2;
    
    // Gross efficiency (η_gross): Power output / Total energy expenditure
    const grossEfficiency = (powerKJ_min / energyExpenditure) * 100;
    
    // Net efficiency (η_net): Power output / (Total energy expenditure - Resting energy expenditure)
    const vo2baseL_min = vo2base / 1000;
    const restingEnergy = vo2baseL_min * kalorischesEquivalent.kJ_lO2;
    const netEfficiency = (powerKJ_min / (energyExpenditure - restingEnergy)) * 100;
    
    return {
        gross: grossEfficiency,
        net: netEfficiency,
        delta: 1 / ((vo2L_min / (power / 60)) * kalorischesEquivalent.kJ_lO2 / 60) * 100
    };
}

    
    
    // Event handlers for Tab 1
    elements.CEVO2.addEventListener('input', function() {
        appState.CEVO2 = parseFloat(this.value);
        elements.CEVO2Value.textContent = appState.CEVO2.toFixed(1);
        
        // Calculate and update delta efficiency
        const deltaEta = calculateDeltaEfficiency(appState.CEVO2);
        document.getElementById('delta-eta-value').textContent = 
            `${deltaEta.min.toFixed(1)}-${deltaEta.max.toFixed(1)}%`;
        
        // Synchronize with Tab 2 if parameters are linked
        if (appState.use_tab1_params) {
            appState.CEVO2_step = appState.CEVO2;
            elements.CEVO2_step.value = appState.CEVO2;
            elements.CEVO2_stepValue.textContent = appState.CEVO2.toFixed(1);
        }
        
        // Update plot and critical power
        updatePlot();
        updateStepTestPlot();
    });
    
    elements.CE_range_start.addEventListener('input', function() {
        appState.CE_range[0] = parseFloat(this.value);
        elements.CE_range_startValue.textContent = appState.CE_range[0].toFixed(1);
        updatePlot();
        
        // Synchronize with Tab 2 if parameters are linked
        if (appState.use_tab1_params) {
            appState.CE_range_step[0] = appState.CE_range[0];
            elements.CE_range_start_step.value = appState.CE_range[0];
            elements.CE_range_start_stepValue.textContent = appState.CE_range[0].toFixed(1);
            updateStepTestPlot();
        }
    });
    
    elements.CE_range_end.addEventListener('input', function() {
        appState.CE_range[1] = parseFloat(this.value);
        elements.CE_range_endValue.textContent = appState.CE_range[1].toFixed(1);
        updatePlot();
        
        // Synchronize with Tab 2 if parameters are linked
        if (appState.use_tab1_params) {
            appState.CE_range_step[1] = appState.CE_range[1];
            elements.CE_range_end_step.value = appState.CE_range[1];
            elements.CE_range_end_stepValue.textContent = appState.CE_range[1].toFixed(1);
            updateStepTestPlot();
        }
    });
    
    elements.VO2max.addEventListener('input', function() {
        appState.VO2max = parseFloat(this.value);
        elements.VO2maxValue.textContent = appState.VO2max.toFixed(0);
        // Update relative VO2max
        appState.VO2max_kg = appState.VO2max / appState.body_mass;
        elements.VO2max_kgValue.textContent = appState.VO2max_kg.toFixed(2);
        
        // Synchronize with Tab 2 if parameters are linked
        if (appState.use_tab1_params) {
            appState.VO2max_step = appState.VO2max;
            elements.VO2max_step.value = appState.VO2max;
            elements.VO2max_stepValue.textContent = appState.VO2max.toFixed(0);
        }
        initializeVo2StartSlider();
        updatePlot();
        updateStepTestPlot();
    });
    
    elements.VO2max_kg.addEventListener('input', function() {
        appState.VO2max_kg = parseFloat(this.value);
        elements.VO2max_kgValue.textContent = appState.VO2max_kg.toFixed(2);
        // Update absolute VO2max
        appState.VO2max = appState.VO2max_kg * appState.body_mass;
        elements.VO2max.value = appState.VO2max;
        elements.VO2maxValue.textContent = appState.VO2max.toFixed(0);
        
        // Synchronize with Tab 2 if parameters are linked
        if (appState.use_tab1_params) {
            appState.VO2max_step = appState.VO2max;
            elements.VO2max_step.value = appState.VO2max;
            elements.VO2max_stepValue.textContent = appState.VO2max.toFixed(0);
        }
        initializeVo2StartSlider();
        updatePlot();
        updateStepTestPlot();
    });
    
    elements.VO2Base.addEventListener('input', function() {
        appState.VO2Base = parseFloat(this.value);
        elements.VO2BaseValue.textContent = appState.VO2Base.toFixed(0);
        
        // Synchronize with Tab 2 if parameters are linked
        if (appState.use_tab1_params) {
                    appState.VO2Base_step = appState.VO2Base;
                    elements.VO2Base_step.value = appState.VO2Base;
                    elements.VO2Base_stepValue.textContent = appState.VO2Base.toFixed(0);

                    // *** NEU START ***
                    // Update vo2_start slider constraints and clamp value
                    const base = appState.VO2Base;
                    const maxVal = appState.VO2max;
                    elements.vo2_start.min = base;
                    elements.vo2_start.max = maxVal; // Max bleibt gleich, nur Base ändert sich hier
                    if (appState.vo2_start < base) {
                        appState.vo2_start = base;
                        elements.vo2_start.value = appState.vo2_start;
                        elements.vo2_startValue.textContent = appState.vo2_start;
                    }
                    // *** NEU ENDE ***
                }

            initializeVo2StartSlider(); 
            updatePlot();
            updateStepTestPlot();
            });
    
    elements.vLamax.addEventListener('input', function() {
        appState.vLamax = parseFloat(this.value);
        elements.vLamaxValue.textContent = appState.vLamax.toFixed(2);
        calculateAndUpdateMaxLacticPower();
        
        // Synchronize with Tab 2 if parameters are linked
        if (appState.use_tab1_params) {
            appState.vLamax_step = appState.vLamax;
            elements.vLamax_step.value = appState.vLamax;
            elements.vLamax_stepValue.textContent = appState.vLamax.toFixed(2);
        }
        
        updatePlot();
        updateStepTestPlot();
    });

    // Added Event Listeners for Tab 1 HR Sliders
    elements.HR_max.addEventListener('input', function() {
            appState.HR_max = parseInt(this.value);
            elements.HR_maxValue.textContent = appState.HR_max;
            updatePlot(); // <--- HINZUFÜGEN: Plot für Tab 1 aktualisieren
            if (appState.use_tab1_params) {
                appState.HR_max_step = appState.HR_max;
                elements.HR_max_step.value = appState.HR_max;
                elements.HR_max_stepValue.textContent = appState.HR_max;
                updateStepTestPlot();
            }
        });

        elements.HR_Base.addEventListener('input', function() {
            appState.HR_Base = parseInt(this.value);
            elements.HR_BaseValue.textContent = appState.HR_Base;
            updatePlot(); // <--- HINZUFÜGEN: Plot für Tab 1 aktualisieren
            if (appState.use_tab1_params) {
                appState.HR_Base_step = appState.HR_Base;
                elements.HR_Base_step.value = appState.HR_Base;
                elements.HR_Base_stepValue.textContent = appState.HR_Base;
                updateStepTestPlot();
            }
        });

        elements.CE_HR.addEventListener('input', function() {
            appState.CE_HR = parseFloat(this.value);
            elements.CE_HRValue.textContent = appState.CE_HR.toFixed(2);
            updatePlot(); // <--- HINZUFÜGEN: Plot für Tab 1 aktualisieren
            if (appState.use_tab1_params) {
                appState.CE_HR_step = appState.CE_HR;
                elements.CE_HR_step.value = appState.CE_HR;
                elements.CE_HR_stepValue.textContent = appState.CE_HR.toFixed(2);
                updateStepTestPlot();
            }
        });

    
    elements.body_mass.addEventListener('input', function() {
        appState.body_mass = parseFloat(this.value);
        elements.body_massValue.textContent = appState.body_mass.toFixed(1);
        calculateAndUpdateMaxLacticPower();
        
        // Update relative VO2max if weight changes
        appState.VO2max_kg = appState.VO2max / appState.body_mass;
        elements.VO2max_kg.value = appState.VO2max_kg;
        elements.VO2max_kgValue.textContent = appState.VO2max_kg.toFixed(2);
        
        // Synchronize with Tab 2 if parameters are linked
        if (appState.use_tab1_params) {
            appState.body_mass_step = appState.body_mass;
            elements.body_mass_step.value = appState.body_mass;
            elements.body_mass_stepValue.textContent = appState.body_mass.toFixed(1);
        }
        
        updatePlot();
        updateStepTestPlot();
    });
    
    elements.age.addEventListener('input', function() {
        appState.age = parseInt(this.value);
        elements.ageValue.textContent = appState.age;
    });
    
    elements.height.addEventListener('input', function() {
        appState.height = parseInt(this.value);
        elements.heightValue.textContent = appState.height;
    });
    
    elements.male.addEventListener('change', function() {
        if (this.checked) {
            appState.gender = 'Male';
        }
    });
    
    elements.female.addEventListener('change', function() {
        if (this.checked) {
            appState.gender = 'Female';
        }
    });
    
    elements.curvilinear.addEventListener('change', function() {
        appState.curvilinear = this.checked;
        
        // Only show/hide CE controls if cadence dependency is not enabled
        if (!appState.cadence_dependent) {
            elements.linearCeControl.style.display = this.checked ? 'none' : 'block';
        } else {
            elements.linearCeControl.style.display = 'none'; // Always hidden when cadence dependency is on
        }
        
        elements.curvilinearCeControl.style.display = this.checked ? 'block' : 'none';
        
        // Synchronize with Tab 2 if parameters are linked
        if (appState.use_tab1_params) {
            appState.curvilinear_step = appState.curvilinear;
            elements.curvilinear_step.checked = appState.curvilinear;
            elements.linearCeControlStep.style.display = appState.curvilinear ? 'none' : 'block';
            elements.curvilinearCeControlStep.style.display = appState.curvilinear ? 'block' : 'none';
        }
        
        updatePlot();
        updateStepTestPlot();
    });
    
    // Substrate Utilization Event Handlers
    elements.show_substrate.addEventListener('change', function() {
        appState.show_substrate = this.checked;
        elements.substrate_plot_container.style.display = this.checked ? 'block' : 'none';
        elements.substrate_controls.style.display = this.checked ? 'block' : 'none';
        elements.substrate_info.style.display = this.checked ? 'block' : 'none';
        updatePlot();
        
        if (this.checked) {
            // Show notification about substrate feature
            showNotification("Substrate utilization visualization enabled. Additional plot shows the percentage breakdown between fat and carbohydrate usage.", 'info');
        }
    });
    
    elements.energy_unit.addEventListener('change', function() {
        appState.energy_unit = this.value;
        updatePlot();
        updateSubstratePlot();
    });
    
    elements.show_kh_adjust.addEventListener('change', function() {
        appState.show_kh_adjust = this.checked;
        elements.kh_adjust_control.style.display = this.checked ? 'block' : 'none';
        updatePlot();
        updateSubstratePlot();
    });
    
    elements.rest_kh_percentage.addEventListener('input', function() {
        appState.rest_kh_percentage = parseFloat(this.value);
        elements.rest_kh_percentageValue.textContent = appState.rest_kh_percentage;
        updatePlot();
        updateSubstratePlot();
    });
    
    // Swap axes event handler removed as per request
    // The functionality still exists in the code but is not accessible from UI
    
    elements.cadence_dependent.addEventListener('change', function() {
        appState.cadence_dependent = this.checked;
        elements.cadenceControls.style.display = appState.cadence_dependent ? 'block' : 'none';
        
        // Show/hide the linear CE control based on both cadence and curvilinear settings
        if (this.checked) {
            elements.linearCeControl.style.display = 'none';
        } else if (!appState.curvilinear) {
            elements.linearCeControl.style.display = 'block';
        }
        
        updatePlot();
        
        if (this.checked) {
            // Show notification about cadence dependency
            showNotification(`Cadence dependency enabled at ${appState.cadence} rpm. Using model from Dunst et al. (2025) with CE = ${calculateCadenceDependentCEVO2(appState.cadence).toFixed(2)} ml·min⁻¹·W⁻¹ and V̇O<sub>2,Base</sub> = ${Math.round(calculateCadenceDependentVO2Base(appState.cadence))} ml·min⁻¹`, 'info');
        }
    });
    
    elements.cadence.addEventListener('input', function() {
        appState.cadence = parseInt(this.value);
        elements.cadenceValue.textContent = appState.cadence;
        
        // Update delta efficiency value based on cadence-dependent CE
        if (appState.cadence_dependent) {
            const effectiveCE = calculateCadenceDependentCEVO2(appState.cadence);
            const deltaEta = calculateDeltaEfficiency(effectiveCE);
            document.getElementById('delta-eta-value').textContent = 
                `${deltaEta.min.toFixed(1)}-${deltaEta.max.toFixed(1)}%`;
        }
        
        updatePlot();
    });
    
    elements.vo2max_dependent.addEventListener('change', function() {
        appState.vo2max_dependent = this.checked;
        updatePlot();
        
        if (this.checked && appState.cadence_dependent) {
            showNotification(`V̇O<sub>2,max</sub> cadence dependency enabled. This feature is based on Fig.4 from Dunst et al. (2025).`, 'info');
        }
    });
    
    elements.vlamax_dependent.addEventListener('change', function() {
        appState.vlamax_dependent = this.checked;
        updatePlot();
        
        if (this.checked && appState.cadence_dependent) {
            showNotification(`vLa<sub>max</sub> cadence dependency enabled. The paper suggests this may reflect testing methodology rather than true physiological changes.`, 'warning');
        }
    });
    
    elements.weight_based.addEventListener('change', function() {
        appState.weight_based = this.checked;
        updatePlot();
        updateStepTestPlot();
    });
    
    elements.lock_y_axis.addEventListener('change', function() {
        appState.lock_y_axis = this.checked;
        updatePlot();
    });
    
    elements.lock_x_axis.addEventListener('change', function() {
        appState.lock_x_axis = this.checked;
        updatePlot();
    });
    
    elements.calculate_vo2base.addEventListener('click', function() {
        // Calculate BMR in kcal/day
        const bmr = calculateBMR(appState.gender, appState.body_mass, appState.height, appState.age);
        
        // Convert to VO2 in ml/min
        const calculatedVO2Base = calculateVO2Base(bmr, appState.gender);
        appState.calculated_vo2base = calculatedVO2Base;
        
        // Update VO2Base value
        appState.VO2Base = Math.round(calculatedVO2Base);
        elements.VO2Base.value = appState.VO2Base;
        elements.VO2BaseValue.textContent = appState.VO2Base.toFixed(0);
        
        // Synchronize with Tab 2 if parameters are linked
        if (appState.use_tab1_params) {
            appState.VO2Base_step = appState.VO2Base;
            elements.VO2Base_step.value = appState.VO2Base;
            elements.VO2Base_stepValue.textContent = appState.VO2Base.toFixed(0);
        }
        
        // Show notification
        showNotification(`V̇O<sub>2,Base</sub> calculated: ${Math.round(calculatedVO2Base)} ml·min⁻¹`, 'info');
        
        // Update plot and critical power
        updatePlot();
        updateStepTestPlot();
    });
    
    // Auto-calculate glycogen values based on muscle mass
    elements.auto_glycogen.addEventListener('change', function() {
        appState.auto_glycogen = this.checked;
        
        if (this.checked) {
            // Calculate recommended glycogen values
            const glycogenValues = calculateGlycogenValues();
            
            // Update glycogen values
            appState.glycogen_init = glycogenValues.initialGlycogen;
            appState.glycogen_max = glycogenValues.maxGlycogen;
            
            // Update UI
            elements.glycogen_init.value = appState.glycogen_init;
            elements.glycogen_initValue.textContent = appState.glycogen_init;
            elements.glycogen_max.value = appState.glycogen_max;
            elements.glycogen_maxValue.textContent = appState.glycogen_max;
            
            showNotification(`Glycogen values calculated: Initial ${glycogenValues.initialGlycogen}g, Max ${glycogenValues.maxGlycogen}g based on ${appState.active_muscle_mass.toFixed(1)}kg muscle mass`, 'info');
            
            updateStepTestPlot();
        }
    });
    
    // Tab 2 Event Handlers - Step Test Simulation
    elements.step_watt.addEventListener('input', function() {
        appState.step_watt = parseFloat(this.value);
        elements.step_wattValue.textContent = appState.step_watt;
        updateStepTestPlot();
    });
    
    elements.step_duration.addEventListener('input', function() {
        appState.step_duration = parseFloat(this.value);
        elements.step_durationValue.textContent = appState.step_duration;
        updateStepTestPlot();
    });
    
    elements.max_power_step.addEventListener('input', function() {
        appState.max_power_step = parseFloat(this.value);
        elements.max_power_stepValue.textContent = appState.max_power_step;
        updateStepTestPlot();
    });
    
    elements.vo2_up_time_constant.addEventListener('input', function() {
        appState.vo2_up_time_constant = parseFloat(this.value);
        elements.vo2_up_time_constantValue.textContent = appState.vo2_up_time_constant;
        // CalculateStepTest handles interpretation (fixed vs. 50% baseline)
        updateStepTestPlot();
    });

    // --- START: Listener for Dynamic Tau_On Checkbox ---
    elements.dynamic_tau_on.addEventListener('change', function() {
        appState.dynamic_tau_on = this.checked;

        if (this.checked) {
            // Set slider to default value for 50% intensity (0.38*50+6 = 25)
            const default_tau_at_50 = 25;
            appState.vo2_up_time_constant = default_tau_at_50;
            elements.vo2_up_time_constant.value = default_tau_at_50;
            elements.vo2_up_time_constantValue.textContent = default_tau_at_50;
            showNotification("Intensity-dependent τ_on enabled. Slider sets τ_on at 75% intensity.", 'info');
        } else {
            showNotification("Intensity-dependent τ_on disabled. Slider sets fixed τ_on.", 'info');
            // Keep the current slider value when disabling
        }
        updateStepTestPlot(); // Recalculate with new mode
    });
    // --- END: Listener for Dynamic Tau_On Checkbox ---
    
    elements.vo2_down_time_constant.addEventListener('input', function() {
        appState.vo2_down_time_constant = parseFloat(this.value);
        elements.vo2_down_time_constantValue.textContent = appState.vo2_down_time_constant;
            updateStepTestPlot();
    });

    elements.vo2_down_time_constant.addEventListener('input', function() {
        appState.vo2_down_time_constant = parseFloat(this.value);
        elements.vo2_down_time_constantValue.textContent = appState.vo2_down_time_constant;
        // No need to change behavior here, calculateStepTest handles the logic
        updateStepTestPlot();
    });

    // --- START: Listener for Dynamic Tau_Off Checkbox ---
    elements.dynamic_tau_off.addEventListener('change', function() {
        appState.dynamic_tau_off = this.checked;

        if (this.checked) {
            // Set slider to default value for 50% intensity (0.45*50+10 = 32.5, rounded to 33)
            const default_tau_at_50 = 33;
            appState.vo2_down_time_constant = default_tau_at_50;
            elements.vo2_down_time_constant.value = default_tau_at_50;
            elements.vo2_down_time_constantValue.textContent = default_tau_at_50;
            showNotification("Intensity-dependent τ_off enabled. Slider sets τ_off at 50% intensity.", 'info');
        } else {
            showNotification("Intensity-dependent τ_off disabled. Slider sets fixed τ_off.", 'info');
            // Keep the current slider value when disabling, no action needed on value itself
        }
        updateStepTestPlot(); // Recalculate with new mode
    });
    
    elements.la_max.addEventListener('input', function() {
        appState.la_max = parseFloat(this.value);
        elements.la_maxValue.textContent = appState.la_max.toFixed(1);
        updateStepTestPlot();
    });
    
    elements.la_base.addEventListener('input', function() {
        appState.la_base = parseFloat(this.value);
        elements.la_baseValue.textContent = appState.la_base.toFixed(1);
        updateStepTestPlot();
    });

    elements.vLass_on_tau.addEventListener('input', function() {
        appState.vLass_on_tau = parseFloat(this.value);
        elements.vLass_on_tauValue.textContent = appState.vLass_on_tau;
        updateStepTestPlot(); // Recalculate simulation
    });

    elements.vLass_off_tau.addEventListener('input', function() {
        appState.vLass_off_tau = parseFloat(this.value);
        elements.vLass_off_tauValue.textContent = appState.vLass_off_tau;
        updateStepTestPlot(); // Recalculate simulation
    });
    
    // Glycogen Storage Event Handlers
    elements.glycogen_init.addEventListener('input', function() {
        appState.glycogen_init = parseFloat(this.value);
        elements.glycogen_initValue.textContent = appState.glycogen_init;
        updateStepTestPlot();
    });
    
    elements.glycogen_max.addEventListener('input', function() {
        appState.glycogen_max = parseFloat(this.value);
        elements.glycogen_maxValue.textContent = appState.glycogen_max;
        updateStepTestPlot();
    });
    
    elements.carb_intake_rate.addEventListener('input', function() {
        appState.carb_intake_rate = parseFloat(this.value);
        elements.carb_intake_rateValue.textContent = appState.carb_intake_rate;
        updateStepTestPlot();
    });

    elements.vo2_start.addEventListener('input', function() {
        let newValue = parseFloat(this.value);
        const base = parseFloat(elements.vo2_start.min);
        const maxVal = parseFloat(elements.vo2_start.max);

        // Sicherstellen, dass der Wert innerhalb der dynamischen Grenzen bleibt
        if (newValue < base) newValue = base;
        if (newValue > maxVal) newValue = maxVal;
        
        appState.vo2_start = newValue;
        this.value = newValue; // Slider anpassen, falls geklemmt
        elements.vo2_startValue.textContent = Math.round(newValue); // Runde für die Anzeige
        updateStepTestPlot();
    });
    
    elements.critical_power.addEventListener('input', function() {
        // Only update if not linked to MLSS
        if (!appState.use_mlss_as_cp) {
            appState.critical_power = parseFloat(this.value);
            elements.critical_powerValue.textContent = appState.critical_power;
            updateStepTestPlot();
        } else {
            // Reset to MLSS value if linked
            this.value = appState.mlss_value;
            showNotification("CP is linked to MLSS. Uncheck option to change manually.", 'info');
        }
    });
    
    elements.w_prime.addEventListener('input', function() {
        appState.w_prime = parseFloat(this.value);
        elements.w_primeValue.textContent = appState.w_prime.toFixed(1);
        updateStepTestPlot();
    });

    elements.pmax.addEventListener('input', function() {
    appState.pmax = parseFloat(this.value);
    elements.pmaxValue.textContent = appState.pmax;
    updateStepTestPlot();
    });
    
    elements.w_prime_balance_min.addEventListener('input', function() {
        appState.w_prime_balance_min = parseFloat(this.value);
        elements.w_prime_balance_minValue.textContent = appState.w_prime_balance_min.toFixed(1);
        updateStepTestPlot();
    });
    
    elements.use_w_prime_balance_abort.addEventListener('change', function() {
        appState.use_w_prime_balance_abort = this.checked;
        updateStepTestPlot();
    });
    
    // PCr Model Event Handlers
    elements.pcr_init.addEventListener('input', function() {
        appState.pcr_init = parseFloat(this.value);
        elements.pcr_initValue.textContent = appState.pcr_init.toFixed(1);
        if (appState.show_pcr_model) {
            updateStepTestPlot();
        }
    });
    
    elements.p_o_ratio.addEventListener('input', function() {
        appState.p_o_ratio = parseFloat(this.value);
        elements.p_o_ratioValue.textContent = appState.p_o_ratio.toFixed(2);
        if (appState.show_pcr_model) {
            updateStepTestPlot();
        }
    });
    
    elements.active_muscle_mass.addEventListener('input', function() {
        appState.active_muscle_mass = parseFloat(this.value);
        elements.active_muscle_massValue.textContent = appState.active_muscle_mass.toFixed(1);
        
        // If auto-calculate glycogen is enabled, update glycogen values
        if (appState.auto_glycogen) {
            const glycogenValues = calculateGlycogenValues();
            appState.glycogen_init = glycogenValues.initialGlycogen;
            appState.glycogen_max = glycogenValues.maxGlycogen;
            elements.glycogen_init.value = appState.glycogen_init;
            elements.glycogen_initValue.textContent = appState.glycogen_init;
            elements.glycogen_max.value = appState.glycogen_max;
            elements.glycogen_maxValue.textContent = appState.glycogen_max;
        }
        
        if (appState.show_pcr_model) { // Bezieht sich auf show_pcr_model, sollte aber generell bei Änderung der AMM updaten
            updateStepTestPlot();
        }
        calculateAndUpdateMaxLacticPower(); // NEU
    });
    
    elements.show_vo2_demand.addEventListener('change', function() {
        appState.show_vo2_demand = this.checked;
        if (appState.show_pcr_model) {
            updateStepTestPlot();
        }
    });
    
    elements.use_lactate_abort.addEventListener('change', function() {
        appState.use_lactate_abort = this.checked;
        updateStepTestPlot();
    });
    
    elements.use_mlss_as_cp.addEventListener('change', function() {
        appState.use_mlss_as_cp = this.checked;
        
        if (this.checked && appState.mlss_value) {
            // Update CP to MLSS value
            appState.critical_power = appState.mlss_value;
            elements.critical_power.value = appState.mlss_value;
            elements.critical_powerValue.textContent = appState.mlss_value;
            
            // Disable the Critical Power slider
            elements.critical_power.disabled = true;
            showNotification("Critical Power linked to MLSS: " + Math.round(appState.mlss_value) + " W", 'info');
        } else {
            // Enable the Critical Power slider
            elements.critical_power.disabled = false;
        }
        
        updateStepTestPlot();
    });
    
    elements.power_scale.addEventListener('input', function() {
        appState.power_scale = parseFloat(this.value);
        elements.power_scaleValue.textContent = appState.power_scale;
        updateStepTestPlot();
    });
    
    // Cadence Dependency Event Handlers for Tab 2
    elements.cadence_dependent_step.addEventListener('change', function() {
        appState.cadence_dependent_step = this.checked;
        elements.cadenceControlsStep.style.display = appState.cadence_dependent_step ? 'block' : 'none';
        updateStepTestPlot();
        
        if (this.checked) {
            // Show notification about cadence dependency
            showNotification(`Exercise simulation cadence dependency enabled at ${appState.cadence_step} rpm. This will modify the metabolic parameters based on cadence.`, 'info');
        }
    });
    
    elements.cadence_step.addEventListener('input', function() {
        appState.cadence_step = parseInt(this.value);
        elements.cadence_stepValue.textContent = appState.cadence_step;
        updateStepTestPlot();
    });
    
    elements.vo2max_dependent_step.addEventListener('change', function() {
        appState.vo2max_dependent_step = this.checked;
        updateStepTestPlot();
    });
    
    elements.vlamax_dependent_step.addEventListener('change', function() {
        appState.vlamax_dependent_step = this.checked;
        updateStepTestPlot();
    });
    
    elements.use_file_cadence.addEventListener('change', function() {
        appState.use_file_cadence = this.checked;
        
        if (this.checked) {
            // Check if we have cadence data in the current file
            const powerData = createPowerData();
            if (powerData.cadence) {
                showNotification("Using cadence data from file for simulation.", 'info');
            } else {
                showNotification("No cadence data available in current file. Fixed cadence will be used.", 'warning');
                this.checked = false;
                appState.use_file_cadence = false;
            }
        }
        
        updateStepTestPlot();
    });
    
    // Event handlers for curvilinear CE relationship in Tab 2
    elements.curvilinear_step.addEventListener('change', function() {
        appState.curvilinear_step = this.checked;
        elements.linearCeControlStep.style.display = this.checked ? 'none' : 'block';
        elements.curvilinearCeControlStep.style.display = this.checked ? 'block' : 'none';
        updateStepTestPlot();
    });
    
    elements.CE_range_start_step.addEventListener('input', function() {
        appState.CE_range_step[0] = parseFloat(this.value);
        elements.CE_range_start_stepValue.textContent = appState.CE_range_step[0].toFixed(1);
        updateStepTestPlot();
    });
    
    elements.CE_range_end_step.addEventListener('input', function() {
        appState.CE_range_step[1] = parseFloat(this.value);
        elements.CE_range_end_stepValue.textContent = appState.CE_range_step[1].toFixed(1);
        updateStepTestPlot();
    });
    
    elements.use_tab1_params.addEventListener('change', function() {
        appState.use_tab1_params = this.checked;
        elements.individual_params.style.display = 'block'; // Always display, regardless of checkbox status
        
        // If parameters are linked, update the parameters accordingly
        if (this.checked) {
            // Synchronize Tab 2 parameters with Tab 1
            appState.CEVO2_step = appState.CEVO2;
            appState.VO2max_step = appState.VO2max;
            appState.VO2Base_step = appState.VO2Base;
            appState.vLamax_step = appState.vLamax;
            appState.body_mass_step = appState.body_mass;
            appState.HR_max_step = appState.HR_max;
            appState.HR_Base_step = appState.HR_Base;
            appState.CE_HR_step = appState.CE_HR;
            
            // Synchronize curvilinear settings
            appState.curvilinear_step = appState.curvilinear;
            appState.CE_range_step = [...appState.CE_range];
            
            // Update displayed values
            elements.CEVO2_step.value = appState.CEVO2;
            elements.CEVO2_stepValue.textContent = appState.CEVO2.toFixed(1);
            elements.VO2max_step.value = appState.VO2max;
            elements.VO2max_stepValue.textContent = appState.VO2max.toFixed(0);
            elements.VO2Base_step.value = appState.VO2Base;
            elements.VO2Base_stepValue.textContent = appState.VO2Base.toFixed(0);
            elements.vLamax_step.value = appState.vLamax;
            elements.vLamax_stepValue.textContent = appState.vLamax.toFixed(2);
            elements.body_mass_step.value = appState.body_mass;
            elements.body_mass_stepValue.textContent = appState.body_mass.toFixed(1);
            elements.HR_max_step.value = appState.HR_max;
            elements.HR_max_stepValue.textContent = appState.HR_max;
            elements.HR_Base_step.value = appState.HR_Base;
            elements.HR_Base_stepValue.textContent = appState.HR_Base;
            elements.CE_HR_step.value = appState.CE_HR;
            elements.CE_HR_stepValue.textContent = appState.CE_HR.toFixed(2);
            
            // Update curvilinear controls
            elements.curvilinear_step.checked = appState.curvilinear;
            elements.CE_range_start_step.value = appState.CE_range[0];
            elements.CE_range_start_stepValue.textContent = appState.CE_range[0].toFixed(1);
            elements.CE_range_end_step.value = appState.CE_range[1];
            elements.CE_range_end_stepValue.textContent = appState.CE_range[1].toFixed(1);
            
            // Display correct CE controls based on curvilinear setting
            elements.linearCeControlStep.style.display = appState.curvilinear ? 'none' : 'block';
            elements.curvilinearCeControlStep.style.display = appState.curvilinear ? 'block' : 'none';
            
            // Synchronize MLSS value if checkbox is active
            updateCriticalPowerFromMlss();
            
            showNotification("Parameters synchronized with Tab 1", 'info');
        }
        initializeVo2StartSlider();
        updateStepTestPlot();
        calculateAndUpdateMaxLacticPower(); // NEU
    });
    
elements.smooth_power.addEventListener('click', function() {
    // Get current power data
    const powerData = createPowerData();
    
    if (powerData && powerData.power && powerData.power.length > 5) {
        // Apply 5-point window smoothing
        appState.power_data.power = smoothData(powerData.power, 5);
        showNotification("Power curve smoothed with 5-point window", 'info');
        updateStepTestPlot();
    } else {
        showNotification("Not enough data points to smooth", 'warning');
    }
});
    
    elements.has_header.addEventListener('change', function() {
        appState.has_header = this.checked;
    });

    elements.gap_handling_last.addEventListener('change', function() {
        if (this.checked) {
            appState.gap_handling = 'last';
        }
    });

    elements.gap_handling_zero.addEventListener('change', function() {
        if (this.checked) {
            appState.gap_handling = 'zero';
        }
    });
    
    elements.CEVO2_step.addEventListener('input', function() {
        appState.CEVO2_step = parseFloat(this.value);
        elements.CEVO2_stepValue.textContent = appState.CEVO2_step.toFixed(1);
        
        // Synchronize with Tab 1 if parameters are linked
        if (appState.use_tab1_params) {
            appState.CEVO2 = appState.CEVO2_step;
            elements.CEVO2.value = appState.CEVO2;
            elements.CEVO2Value.textContent = appState.CEVO2.toFixed(1);
            updatePlot();
            updateCriticalPowerFromMlss();
        }
        
        updateStepTestPlot();
    });
    
    elements.VO2max_step.addEventListener('input', function() {
        appState.VO2max_step = parseFloat(this.value);
        elements.VO2max_stepValue.textContent = appState.VO2max_step.toFixed(0);
        
        // Synchronize with Tab 1 if parameters are linked
        if (appState.use_tab1_params) {
            appState.VO2max = appState.VO2max_step;
            elements.VO2max.value = appState.VO2max;
            elements.VO2maxValue.textContent = appState.VO2max.toFixed(0);
            // Update relative VO2max
            appState.VO2max_kg = appState.VO2max / appState.body_mass;
            elements.VO2max_kg.value = appState.VO2max_kg;
            elements.VO2max_kgValue.textContent = appState.VO2max_kg.toFixed(2);
            updatePlot();
            updateCriticalPowerFromMlss();
        }
        initializeVo2StartSlider();
        updateStepTestPlot();
    });
    
    elements.VO2Base_step.addEventListener('input', function() {
        appState.VO2Base_step = parseFloat(this.value);
        elements.VO2Base_stepValue.textContent = appState.VO2Base_step.toFixed(0);
        
        // Synchronize with Tab 1 if parameters are linked
        if (appState.use_tab1_params) {
            appState.VO2Base = appState.VO2Base_step;
            elements.VO2Base.value = appState.VO2Base;
            elements.VO2BaseValue.textContent = appState.VO2Base.toFixed(0);
            updatePlot();
            updateCriticalPowerFromMlss();
        }
        initializeVo2StartSlider();
        updateStepTestPlot();
    });
    
    elements.vLamax_step.addEventListener('input', function() {
        appState.vLamax_step = parseFloat(this.value);
        elements.vLamax_stepValue.textContent = appState.vLamax_step.toFixed(2);
        calculateAndUpdateMaxLacticPower();
        
        // Synchronize with Tab 1 if parameters are linked
        if (appState.use_tab1_params) {
            appState.vLamax = appState.vLamax_step;
            elements.vLamax.value = appState.vLamax;
            elements.vLamaxValue.textContent = appState.vLamax.toFixed(2);
            updatePlot();
            updateCriticalPowerFromMlss();
        }
        
        updateStepTestPlot();
    });
    
    elements.body_mass_step.addEventListener('input', function() {
        appState.body_mass_step = parseFloat(this.value);
        elements.body_mass_stepValue.textContent = appState.body_mass_step.toFixed(1);
        
        // Synchronize with Tab 1 if parameters are linked
        if (appState.use_tab1_params) {
            appState.body_mass = appState.body_mass_step;
            elements.body_mass.value = appState.body_mass;
            elements.body_massValue.textContent = appState.body_mass.toFixed(1);
            
            // Update relative VO2max if weight changes
            appState.VO2max_kg = appState.VO2max / appState.body_mass;
            elements.VO2max_kg.value = appState.VO2max_kg;
            elements.VO2max_kgValue.textContent = appState.VO2max_kg.toFixed(2);
            
            updatePlot();
            updateCriticalPowerFromMlss();
        }
        
        updateStepTestPlot();
    });

    // Added Event Listeners for Tab 2 HR Sliders
        elements.HR_max_step.addEventListener('input', function() {
            appState.HR_max_step = parseInt(this.value);
            elements.HR_max_stepValue.textContent = appState.HR_max_step;
            if (!appState.use_tab1_params) { // Only update plot if not linked, otherwise Tab 1 handler does it
                updateStepTestPlot();
            }
        });

        elements.HR_Base_step.addEventListener('input', function() {
            appState.HR_Base_step = parseInt(this.value);
            elements.HR_Base_stepValue.textContent = appState.HR_Base_step;
            if (!appState.use_tab1_params) {
                updateStepTestPlot();
            }
        });

        elements.CE_HR_step.addEventListener('input', function() {
            appState.CE_HR_step = parseFloat(this.value);
            elements.CE_HR_stepValue.textContent = appState.CE_HR_step.toFixed(2);
            if (!appState.use_tab1_params) {
                updateStepTestPlot();
            }
        });

    // --- NEW: Event Listeners for Delay Sliders ---
    elements.vo2_delay.addEventListener('input', function() {
        appState.vo2_delay = parseInt(this.value);
        elements.vo2_delayValue.textContent = appState.vo2_delay;
        updateStepTestPlot(); // Recalculate simulation with new delay
    });

    elements.vlass_delay.addEventListener('input', function() {
        appState.vlass_delay = parseInt(this.value);
        elements.vlass_delayValue.textContent = appState.vlass_delay;
        updateStepTestPlot(); // Recalculate simulation with new delay
    });

    // --- NEW: Event Listener for Optional vLa<sub>SS</sub> Capping ---
        elements.cap_vlass_by_o2_deficit.addEventListener('change', function() {
        appState.cap_vlass_by_o2_deficit = this.checked;
        if (this.checked) {
            showNotification("vLa<sub>SS</sub> capping by V̇O₂ deficit enabled.", 'info');
        } else {
            showNotification("vLa<sub>SS</sub> capping by V̇O₂ deficit disabled.", 'info');
        }
        updateStepTestPlot(); // Recalculate simulation with new setting
    });

    // --- NEW: Event Listener for Optional vLa<sub>SS</sub> Boosting ---
    elements.boost_vlass_by_deficit.addEventListener('change', function() {
        appState.boost_vlass_by_deficit = this.checked;
        elements.vlass_boost_factor_control.style.display = this.checked ? 'block' : 'none';
        if (this.checked) {
            showNotification("vLass boosting by V̇O₂ deficit magnitude enabled.", 'info');
        } else {
            showNotification("vLass boosting by V̇O₂ deficit magnitude disabled.", 'info');
        }
        updateStepTestPlot();
    });

    elements.vlass_boost_factor.addEventListener('input', function() {
    appState.vlass_boost_factor = parseFloat(this.value);
    elements.vlass_boost_factorValue.textContent = appState.vlass_boost_factor.toFixed(2);
    if (appState.boost_vlass_by_deficit) {
        updateStepTestPlot();
    }
});
    
    // Load sample interval data
    elements.load_interval_example.addEventListener('click', function() {
        // Sample interval data
        appState.interval_data = [
        { time_s: 0, power: 0, cadence: 80 },      // Start: 0 Watt for 2 minutes
        { time_s: 120, power: 200, cadence: 80 },  // 2 minutes at 200 Watts
        { time_s: 240, power: 250, cadence: 80 },  // Intervals start - 2 minutes at 250 Watts
        { time_s: 360, power: 200, cadence: 80 },  // 2 minutes recovery at 200 Watts
        { time_s: 480, power: 300, cadence: 90 },  // 2 minutes at 300 Watts
        { time_s: 600, power: 200, cadence: 80 },  // 2 minutes recovery at 200 Watts
        { time_s: 720, power: 350, cadence: 90 },  // 2 minutes at 350 Watts
        { time_s: 840, power: 200, cadence: 80 },  // 2 minutes recovery at 200 Watts
        { time_s: 960, power: 400, cadence: 90 },  // 2 minutes at 400 Watts
        { time_s: 1080, power: 200, cadence: 80 }, // 2 minutes recovery at 200 Watts
        { time_s: 1200, power: 450, cadence: 90 }, // 2 minutes at 450 Watts
        { time_s: 1320, power: 200, cadence: 80 }, // 2 minutes recovery at 200 Watts
        { time_s: 1440, power: 500, cadence: 90 }, // 2 minutes at 500 Watts
        { time_s: 1560, power: 200, cadence: 80 }, // 5 minutes at 200 Watts to cool down
        { time_s: 1860, power: 100, cadence: 80 }, // 5 minutes at 100 Watts to finish
        { time_s: 2160, power: 0, cadence: 80 },
        { time_s: 3360, power: 0, cadence: 80 }    // End of program
        ];
        
// Clear any file upload data
appState.power_data = null;
elements.fileName.textContent = "";
elements.power_data.value = "";

// Show notification
showNotification("Example interval data loaded with cadence values", 'info');

// Update plot
updateStepTestPlot();

// Update time window sliders for example data
if (appState.interval_data && appState.interval_data.length > 0) {
    const timePoints = appState.interval_data.map(d => d.time_s);
    const minTime = Math.min(...timePoints);
    const maxTime = Math.max(...timePoints);
    
    // Update slider ranges
    elements.view_time_start.min = minTime;
    elements.view_time_start.max = maxTime;
    elements.view_time_start.value = minTime;
    appState.view_time_start = minTime;
    elements.view_time_startValue.textContent = minTime;
    
    elements.view_time_end.min = minTime;
    elements.view_time_end.max = maxTime;
    elements.view_time_end.value = maxTime;
    appState.view_time_end = maxTime;
    elements.view_time_endValue.textContent = maxTime;
}
});


// Helper function to normalize column name
function normalizeColumnName(name) {
    if (!name) return "";
    
    // Convert to string, trim whitespace and convert to lowercase
    const normalizedName = String(name).toLowerCase().trim();
    
    // Time column identifiers
    if (/^time$|^t_s$|^t$|^time_s$|^timestamp$|^time_seconds$/.test(normalizedName)) {
        return "time";
    }
    
    // Power column identifiers
    if (/^power$|^watts$|^watt$/.test(normalizedName)) {
        return "power";
    }
    
    // Cadence column identifiers
    if (/^cadence$|^rpm$|^cad$/.test(normalizedName)) {
        return "cadence";
    }
    
    // Return original normalized name if no match
    return normalizedName;
}

// Helper function to find column indices in headers
function findColumnIndices(headers) {
    // Ensure headers is an array and convert items to strings
    const cleanHeaders = Array.isArray(headers) ? 
        headers.map(h => h !== null && h !== undefined ? String(h) : "") : 
        [];
    
    // Normalize headers
    const normalizedHeaders = cleanHeaders.map(h => normalizeColumnName(h));
    
    // Debug: log the normalized headers
    console.log("Normalized headers:", normalizedHeaders);
    
    // Find time/timestamp column
    let timeIdx = normalizedHeaders.indexOf("time");
    
    // Find power column
    let powerIdx = normalizedHeaders.indexOf("power");
    
    // Find cadence column
    let cadenceIdx = normalizedHeaders.indexOf("cadence");
    
    console.log("Column indices - Time:", timeIdx, "Power:", powerIdx, "Cadence:", cadenceIdx);
    
    return { timeIdx, powerIdx, cadenceIdx };
}

// Helper function to validate power value
function validatePower(value) {
    if (value === null || value === undefined || isNaN(value)) return null;
    
    // Filter out invalid power values (negative or too high)
    if (value < 0 || value > 2500 || value === 65535) return null;
    
    return value;
}

// Helper function to validate cadence value
function validateCadence(value) {
    if (value === null || value === undefined || isNaN(value)) return null;
    
    // Filter out invalid cadence values (negative or too high)
    if (value < 0 || value > 250) return null;
    
    return value;
}

// Function to process CSV data
function processCSVData(contents) {

    // Detect delimiter (try to be smarter about it)
    let delimiter = ';';
    const firstLine = contents.split('\n')[0];
    
    // Count occurrences of potential delimiters
    const commaCount = (firstLine.match(/,/g) || []).length;
    const semicolonCount = (firstLine.match(/;/g) || []).length;
    const tabCount = (firstLine.match(/\t/g) || []).length;
    
    if (commaCount > semicolonCount && commaCount > tabCount) {
        delimiter = ',';
    } else if (tabCount > semicolonCount && tabCount > commaCount) {
        delimiter = '\t';
    }
    
    console.log("Detected delimiter:", delimiter);
    
    const rows = contents.split('\n');
    return { rows, delimiter };
}

// Function to process XLSX data
function processXLSXData(file, callback) {
    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const data = new Uint8Array(e.target.result);
            const workbook = XLSX.read(data, { type: 'array' });
            
            // Get the first sheet
            const firstSheetName = workbook.SheetNames[0];
            const worksheet = workbook.Sheets[firstSheetName];
            
            // Convert to JSON
            const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
            
            callback(jsonData);
        } catch (error) {
            console.error("Error processing XLSX file:", error);
            showNotification("Error processing XLSX file", 'warning');
        }
    };
    reader.readAsArrayBuffer(file);
}

// Helper function to parse timestamp into seconds
function parseTimestamp(timestamp) {
    if (!timestamp) return NaN;
    
    try {
        // Check if it's already in seconds format
        const asNumber = parseFloat(String(timestamp).replace(',', '.'));
        if (!isNaN(asNumber)) {
            return asNumber;
        }
        
        // Check if it's a date object (from Excel)
        if (timestamp instanceof Date) {
            return timestamp.getHours() * 3600 + timestamp.getMinutes() * 60 + timestamp.getSeconds();
        }
        
        // Try to parse ISO format timestamp (2025-03-21T05:07:03)
        const timestampStr = String(timestamp).trim();
        const date = new Date(timestampStr);
        if (!isNaN(date.getTime())) {
            // Return seconds since midnight
            return date.getHours() * 3600 + date.getMinutes() * 60 + date.getSeconds();
        }
    } catch (e) {
        console.error("Error parsing timestamp:", e, "Value:", timestamp);
    }
    return NaN;
}

// File upload handling with improved data handling
elements.power_data.addEventListener('change', function(e) {
    const file = e.target.files[0];
    if (!file) return;
    
    // Display the file name
    elements.fileName.textContent = file.name;
    
    // Clear any interval data
    appState.interval_data = null;
    
    // Process based on file type
    const fileExtension = file.name.split('.').pop().toLowerCase();
    
    if (fileExtension === 'xlsx' || fileExtension === 'xls') {
        // Process Excel file
        processXLSXData(file, function(rows) {
            processFileData(rows, null, file.name);
        });
    } else {
        // Process CSV, TXT file
        const reader = new FileReader();
        reader.onload = function(e) {
            const contents = e.target.result;
            const { rows, delimiter } = processCSVData(contents);
            processFileData(rows, delimiter, file.name);
        };
        reader.readAsText(file);
    }
});

// Function to process file data regardless of source
function processFileData(rows, delimiter, fileName) {
    try {
        console.log("Processing file:", fileName);
        console.log("First few rows:", rows.slice(0, 3));
        
        // Temporary arrays to store parsed data points before interpolation
        const dataPoints = [];
        let hasCadenceData = false;
        
        const hasHeader = appState.has_header && rows.length > 1;
        const startRow = hasHeader ? 1 : 0;
        
        let timeIdx = 0, powerIdx = 1, cadenceIdx = 2;
        let firstTimestamp = null;
        
        // If we have headers, try to identify the columns
        if (hasHeader) {
            // Handle different formats for headers
            let headers;
            if (delimiter) {
                // For CSV files
                headers = rows[0].split(delimiter);
            } else {
                // For XLSX files
                headers = rows[0];
            }
            
            const indices = findColumnIndices(headers);
            
            if (indices.timeIdx !== -1) timeIdx = indices.timeIdx;
            if (indices.powerIdx !== -1) powerIdx = indices.powerIdx;
            if (indices.cadenceIdx !== -1) cadenceIdx = indices.cadenceIdx;
            
        }
        
        console.log("Using columns - Time:", timeIdx, "Power:", powerIdx, "Cadence:", cadenceIdx);
        
        // Parse the data rows
        for (let i = startRow; i < rows.length; i++) {
            if (!rows[i]) continue;
            
            let cells;
            if (delimiter) {
                // For CSV files
                const row = rows[i].trim();
                if (row === '') continue;
                cells = row.split(delimiter);
            } else {
                // For XLSX files
                cells = rows[i];
            }
            
            if (!cells || cells.length <= Math.max(timeIdx, powerIdx)) continue;
            
            // Parse time and power values
            const timeValue = cells[timeIdx];
            let powerValue = cells[powerIdx];

            // Handle GOTOES special case where power might be 65535 (invalid value)
            if (powerValue === 65535 || powerValue === "65535") {
                continue; // Skip invalid power data
            }

            // Try to convert power to number if it's not already
            if (typeof powerValue === 'string') {
                powerValue = parseFloat(powerValue.replace(',', '.'));
            }

            // Validate power value
            powerValue = validatePower(powerValue);

            if (!powerValue) continue; // Skip invalid power data

            if (!firstTimestamp && timeValue) firstTimestamp = timeValue;

            // Convert timestamp to seconds
            let timeSeconds = parseTimestamp(timeValue);
            if (isNaN(timeSeconds)) continue;

            // If using ISO timestamps, make time relative to first timestamp
            if (typeof timeValue === 'string' && 
                (timeValue.includes('T') || timeValue.includes('-'))) {
                const firstTimeSeconds = parseTimestamp(firstTimestamp);
                if (!isNaN(firstTimeSeconds)) {
                    timeSeconds = timeSeconds - firstTimeSeconds;
                }
            }
            
            const dataPoint = { time_s: timeSeconds, power: powerValue };
            
            // Check if we have cadence data
            if (cadenceIdx !== -1 && cells.length > cadenceIdx) {
                let cadence = cells[cadenceIdx];
                
                // Try to convert cadence to number if it's not already
                if (typeof cadence === 'string') {
                    cadence = parseFloat(cadence.replace(',', '.'));
                }
                
                // Validate cadence value
                cadence = validateCadence(cadence);
                
                if (cadence !== null) {
                    dataPoint.cadence = cadence;
                    hasCadenceData = true;
                }
            }
            
            dataPoints.push(dataPoint);
        }
        
        console.log("Parsed data points:", dataPoints.length);
        console.log("First few data points:", dataPoints.slice(0, 3));
        
        if (dataPoints.length > 0) {
            // Sort data points by time
            dataPoints.sort((a, b) => a.time_s - b.time_s);
            
            // Create arrays for 1-second interpolated data
            const time_s = [];
            const power = [];
            const cadence = hasCadenceData ? [] : null;
            
            // Get min and max time from data
            const minTime = Math.floor(dataPoints[0].time_s);
            const maxTime = Math.ceil(dataPoints[dataPoints.length - 1].time_s);
            
            console.log("Time range:", minTime, "to", maxTime);
            
            // Create data point for every second
            for (let t = minTime; t <= maxTime; t++) {
                time_s.push(t);
                
                // Find the data point with largest time <= t
                let prevIdx = -1;
                let nextIdx = -1;
                for (let i = 0; i < dataPoints.length; i++) {
                    if (dataPoints[i].time_s <= t) {
                        prevIdx = i;
                    } else {
                        nextIdx = i;
                        break;
                    }
                }

                // Determine if there's a significant time gap
                const isTimeGap = prevIdx >= 0 && nextIdx >= 0 && 
                    (dataPoints[nextIdx].time_s - dataPoints[prevIdx].time_s > 1);

                if (appState.gap_handling === 'zero' && isTimeGap) {
                    // If gap handling is set to zero and there's a time gap, use zero values
                    power.push(0);
                    if (hasCadenceData) {
                        cadence.push(0);
                    }
                } else if (prevIdx >= 0) {
                    // Otherwise use power from the previous data point (default behavior)
                    power.push(dataPoints[prevIdx].power);
                    if (hasCadenceData) {
                        cadence.push(dataPoints[prevIdx].cadence || null);
                    }
                } else {
                    // If no previous point, use the first point's values
                    power.push(dataPoints[0].power);
                    if (hasCadenceData) {
                        cadence.push(dataPoints[0].cadence || null);
                    }
                }
            }
            
            appState.power_data = {
                time_s: time_s,
                power: power,
                cadence: cadence
            };
            
            // Update time window sliders
            if (appState.power_data && appState.power_data.time_s && appState.power_data.time_s.length > 0) {
                const minTime = Math.min(...appState.power_data.time_s);
                const maxTime = Math.max(...appState.power_data.time_s);
                
                // Update slider ranges
                elements.view_time_start.min = minTime;
                elements.view_time_start.max = maxTime;
                elements.view_time_start.value = minTime;
                appState.view_time_start = minTime;
                elements.view_time_startValue.textContent = minTime;
                
                elements.view_time_end.min = minTime;
                elements.view_time_end.max = maxTime;
                elements.view_time_end.value = maxTime;
                appState.view_time_end = maxTime;
                elements.view_time_endValue.textContent = maxTime;
            }

            // Show notification
            let message = `${time_s.length} data points loaded and interpolated to 1-second intervals`;
            if (hasCadenceData) {
                message += " with cadence data";
                // Enable the use file cadence option if cadence data is available
                if (appState.cadence_dependent_step) {
                    elements.use_file_cadence.disabled = false;
                    elements.use_file_cadence.checked = true;
                    appState.use_file_cadence = true;
                }
            } else {
                // Disable the use file cadence option if no cadence data is available
                elements.use_file_cadence.disabled = true;
                appState.use_file_cadence = false;
                elements.use_file_cadence.checked = false;
            }
            
            showNotification(message, 'info');
            
            // Update plot
            updateStepTestPlot();
        } else {
            showNotification("No valid data found in the file", 'warning');
        }
    } catch (error) {
        console.error("Error processing file:", error);
        showNotification("Error processing the file: " + error.message, 'warning');
    }
}
    
    // Initialize with default values
    // Update controls with initial values
    elements.CEVO2Value.textContent = appState.CEVO2.toFixed(1);
    elements.CE_range_startValue.textContent = appState.CE_range[0].toFixed(1);
    elements.CE_range_endValue.textContent = appState.CE_range[1].toFixed(1);
    elements.VO2maxValue.textContent = appState.VO2max.toFixed(0);
    elements.VO2max_kgValue.textContent = appState.VO2max_kg.toFixed(2);
    elements.VO2BaseValue.textContent = appState.VO2Base.toFixed(0);
    elements.vLamaxValue.textContent = appState.vLamax.toFixed(2);
    elements.HR_maxValue.textContent = appState.HR_max;
    elements.HR_BaseValue.textContent = appState.HR_Base;
    elements.CE_HRValue.textContent = appState.CE_HR.toFixed(2);
    elements.body_massValue.textContent = appState.body_mass.toFixed(1);
    elements.ageValue.textContent = appState.age;
    elements.heightValue.textContent = appState.height;
    elements.cadenceValue.textContent = appState.cadence;
    
    elements.cadence_stepValue.textContent = appState.cadence_step;
    elements.CEVO2_stepValue.textContent = appState.CEVO2_step.toFixed(1);
    elements.VO2max_stepValue.textContent = appState.VO2max_step.toFixed(0);
    elements.VO2Base_stepValue.textContent = appState.VO2Base_step.toFixed(0);
    elements.vLamax_stepValue.textContent = appState.vLamax_step.toFixed(2);
    elements.HR_max_stepValue.textContent = appState.HR_max_step;
    elements.HR_Base_stepValue.textContent = appState.HR_Base_step;
    elements.CE_HR_stepValue.textContent = appState.CE_HR_step.toFixed(2);
    elements.body_mass_stepValue.textContent = appState.body_mass_step.toFixed(1);
    elements.critical_powerValue.textContent = appState.critical_power;
    elements.w_primeValue.textContent = appState.w_prime.toFixed(1);
    elements.w_prime_balance_minValue.textContent = appState.w_prime_balance_min.toFixed(1);
    elements.pmaxValue.textContent = appState.pmax;
    elements.CE_range_start_stepValue.textContent = appState.CE_range_step[0].toFixed(1);
    elements.CE_range_end_stepValue.textContent = appState.CE_range_step[1].toFixed(1);
    elements.glycogen_initValue.textContent = appState.glycogen_init;
    elements.glycogen_maxValue.textContent = appState.glycogen_max;
    elements.carb_intake_rateValue.textContent = appState.carb_intake_rate;
    elements.rest_kh_percentageValue.textContent = appState.rest_kh_percentage;
    elements.vo2_delayValue.textContent = appState.vo2_delay;
    elements.vlass_delayValue.textContent = appState.vlass_delay;
    
    // Set initial visibility of cadence controls
    elements.cadenceControls.style.display = 'none';
    elements.cadenceControlsStep.style.display = 'none';
    
    // Set initial visibility of substrate controls
    elements.substrate_controls.style.display = 'none';
    elements.substrate_plot_container.style.display = 'none';
    elements.substrate_info.style.display = 'none';
    elements.kh_adjust_control.style.display = 'none';
    
    // Individual params area displayed by default
    elements.individual_params.style.display = 'block';
    
    // Initialize plots
    updatePlot();
    
    // Handle page resize events
    window.addEventListener('resize', function() {
        // Redraw all plots on resize
        updatePlot();
        if (document.getElementById('belastungssimulation-tab').classList.contains('active')) {
            updateStepTestPlot();
        }
    });
    
    // Calculate MLSS and set CP when loading the page
    updatePlot();
    
    // Set the use_mlss_as_cp checkbox to checked
    elements.use_mlss_as_cp.checked = appState.use_mlss_as_cp;
    elements.use_w_prime_balance_abort.checked = appState.use_w_prime_balance_abort;
    // Set PCr model to checked - Zeile entfernt

    // Immediately synchronize CP slider with current MLSS value
    if (appState.use_mlss_as_cp && appState.mlss_value) {
        appState.critical_power = appState.mlss_value;
        elements.critical_power.value = appState.mlss_value;
        elements.critical_powerValue.textContent = appState.mlss_value;
        elements.critical_power.disabled = true;
    }
    
    // Disable CP slider if use_mlss_as_cp is activated
    if (appState.use_mlss_as_cp) {
        elements.critical_power.disabled = true;
    }
    
    // Initialize delta efficiency value
    const initialDeltaEta = calculateDeltaEfficiency(appState.CEVO2);
    document.getElementById('delta-eta-value').textContent = 
        `${initialDeltaEta.min.toFixed(1)}-${initialDeltaEta.max.toFixed(1)}%`;

    // Add initialization for vLass_tauValue
    elements.vLass_on_tauValue.textContent = appState.vLass_on_tau;
    elements.vLass_off_tauValue.textContent = appState.vLass_off_tau;
    updateStepTestPlot();

    // Event Listeners für Zeitfenster-Slider
    elements.view_time_start.addEventListener('input', function() {
        appState.view_time_start = parseInt(this.value);
        // Ensure start time is less than end time
        if (appState.view_time_start >= appState.view_time_end) {
            appState.view_time_start = appState.view_time_end - 1;
            if (appState.view_time_start < 0) appState.view_time_start = 0; // Verhindere negative Startzeit
            this.value = appState.view_time_start;
        }
        elements.view_time_startValue.textContent = appState.view_time_start;
        updateStepTestPlot();
    });

    elements.view_time_end.addEventListener('input', function() {
        appState.view_time_end = parseInt(this.value);
        // Ensure end time is greater than start time
        if (appState.view_time_end <= appState.view_time_start) {
            appState.view_time_end = appState.view_time_start + 1;
            this.value = appState.view_time_end;
        }
        elements.view_time_endValue.textContent = appState.view_time_end;
        updateStepTestPlot();
    });

    // Event Listeners für die Achsen-Anpassungen
    elements.customize_time_window.addEventListener('change', function() {
        appState.customize_time_window = this.checked;
        elements.time_window_sliders.style.display = this.checked ? 'block' : 'none';
        
        // Logik für die "Calculate summary for selected window" Checkbox
        if (this.checked) {
            elements.summary_for_window_container.style.display = 'block';
        } else {
            elements.summary_for_window_container.style.display = 'none';
            // Wenn die X-Achsen-Anpassung deaktiviert wird, auch die Fenster-Zusammenfassung deaktivieren
            appState.calculateSummaryForWindow = false;
            if (elements.calculate_summary_for_window) { // Sicherheitscheck
                 elements.calculate_summary_for_window.checked = false;
            }
        }
        updateStepTestPlot();
    });
    
    // Event-Listener für die "Calculate summary for selected window" Checkbox
    if (elements.calculate_summary_for_window) { // Sicherheitscheck
        elements.calculate_summary_for_window.addEventListener('change', function() {
            appState.calculateSummaryForWindow = this.checked;
            updateStepTestPlot(); 
        });
    }


    elements.customize_y_axis.addEventListener('change', function() {
        appState.customize_y_axis = this.checked;
        elements.y_axis_sliders.style.display = this.checked ? 'block' : 'none';
        updateStepTestPlot();
    });

    elements.view_power_max.addEventListener('input', function() {
        appState.view_power_max = parseInt(this.value);
        elements.view_power_maxValue.textContent = appState.view_power_max;
        updateStepTestPlot();
    });

    elements.view_vo2_max.addEventListener('input', function() {
        appState.view_vo2_max = parseInt(this.value);
        elements.view_vo2_maxValue.textContent = appState.view_vo2_max;
        updateStepTestPlot();
    });

    elements.view_lactate_min.addEventListener('input', function() {
        appState.view_lactate_min = parseFloat(this.value);
        // Ensure minimum is less than maximum
        if (appState.view_lactate_min >= appState.view_lactate_max) {
            appState.view_lactate_min = appState.view_lactate_max - 1;
            this.value = appState.view_lactate_min;
        }
        elements.view_lactate_minValue.textContent = appState.view_lactate_min.toFixed(1);
        updateStepTestPlot();
    });

    elements.view_lactate_max.addEventListener('input', function() {
        appState.view_lactate_max = parseFloat(this.value);
        // Ensure maximum is greater than minimum
        if (appState.view_lactate_max <= appState.view_lactate_min) {
            appState.view_lactate_max = appState.view_lactate_min + 1;
            this.value = appState.view_lactate_max;
        }
        elements.view_lactate_maxValue.textContent = appState.view_lactate_max.toFixed(1);
        updateStepTestPlot();
    });

    elements.view_lactate_max.addEventListener('input', function() {
        appState.view_lactate_max = parseFloat(this.value);
        elements.view_lactate_maxValue.textContent = appState.view_lactate_max;
        // Ensure maximum is greater than minimum
        if (appState.view_lactate_max <= appState.view_lactate_min) {
            appState.view_lactate_max = appState.view_lactate_min + 1;
            this.value = appState.view_lactate_max;
            elements.view_lactate_maxValue.textContent = appState.view_lactate_max;
        }
        updateStepTestPlot();
    });
    
    // Update plot once more to ensure everything is correct
    initializeVo2StartSlider();
    updateStepTestPlot();
    calculateAndUpdateMaxLacticPower();
</script>