<!-- 
Hinzufügen:
1. Ruhe-Glykogen-Einstellung zu Tab 2
2. In Tab 2 Cadence-Dependency fixen und die Möglichkeit haben, die Kurven permanent ein- oder auszublenden durch Klicken
3. Automatische Muskelmassen-Berechnung durch Klick
4. RQ anahand Substrat, dann P/O2-Berechnung anhand des Substratverbrauchs + Substratverbrauch in Tab 2 einblenden
5. Mit RQ kann dann auch Brutto und Netowirk besser berechnet werden und P/O2 etc...
6. Blutlaktat modelliern
7. In Tab 1 VO2ss als Prozent von 100% und dann auf gleicher Achse ncoh RQ
8. Ausgabe wie viel Stress score der verschiedeneenanteile und auch wie viel substrate verstoffwechelt wurden
9. In Tab 2 ein VO2-Startpunkt optional festelegen, so dass PCr SPeicher nicht immer direkt leer werden am Start
10. Bi Exponentiell funtkeiornt nioch nicht ganz korrekt.
-->


<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Metabolic Simulation</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <style>
        /* Root variables for color scheme */
        :root {
            --primary-color: #2683C6;
            --secondary-color: #9C85C0;  
            --accent-color: #EF5350;
            --light-color: #f8f9fa;
            --dark-color: #343a40;
            --border-color: #dee2e6;
            --gradient-start: #f1f8ff;
            --gradient-end: #ffffff;
            --cho-color: #D81B60; /* Carbohydrate color (orange) */
            --fat-color: #009688; /* Fat color (dark green) */
            --glycogen-color: #D81B60; /* Glycogen color (brown) */
        }
        
        /* Base styles for all elements */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Roboto', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        /* Body styles */
        body {
            background-color: #f5f5f5;
            color: var(--dark-color);
            line-height: 1.6;
            overflow: hidden;
        }
        
        /* Main container layout */
        .container {
            display: flex;
            height: 100vh;
            max-width: 100%;
        }
        
        /* Sidebar styles */
        .sidebar {
            width: 350px;
            flex-shrink: 0; /* Prevent sidebar from shrinking */
            background: linear-gradient(to bottom, var(--gradient-start), var(--gradient-end));
            padding: 20px;
            box-shadow: 2px 0 5px rgba(0,0,0,0.1);
            overflow-y: auto; /* Add scrollbar to sidebar */
            border-right: 1px solid var(--border-color);
            max-height: 100vh;
            position: relative;
            z-index: 10;
        }
        
        /* Main content area */
        .main-content {
            flex: 1;
            padding: 20px;
            display: flex;
            flex-direction: column;
            background-color: #fff;
            overflow-y: auto;
            width: 100%; /* Stelle sicher, dass der Container die volle Breite nutzt */
        }
        
        /* Heading styles */
        h1 {
            color: var(--primary-color);
            margin-bottom: 20px;
            font-size: 1.8rem;
            text-align: center;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--border-color);
        }
        
        /* Control group container */
        .control-group {
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid var(--border-color);
            background-color: white;
            border-radius: 6px;
            padding: 15px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        
        .control-group:last-child {
            border-bottom: none;
        }
        
        /* Control label styles */
        .control-label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: var(--dark-color);
        }
        
        /* Slider container */
        .slider-container {
            margin-bottom: 15px;
        }
        
        .slider-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
        }
        
        .slider-label label {
            flex-grow: 1;
        }
        
        .slider-value {
            min-width: 60px;
            text-align: right;
            font-weight: bold;
            color: var(--primary-color);
        }
        
        /* Range slider styling */
        .range-slider {
            -webkit-appearance: none;
            width: 100%;
            height: 8px;
            border-radius: 5px;
            background: linear-gradient(to right, #ddd, var(--primary-color));
            outline: none;
            margin: 10px 0;
        }
        
        .range-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--primary-color);
            cursor: pointer;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        
        .range-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--primary-color);
            cursor: pointer;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        
        /* Checkbox styling */
        .checkbox-container {
            display: flex;
            align-items: center;
            margin: 10px 0;
            cursor: pointer;
        }
        
        .checkbox-container input {
            margin-right: 10px;
            cursor: pointer;
        }
        
        /* Radio button group */
        .radio-group {
            margin: 10px 0;
        }
        
        .radio-option {
            margin: 5px 0;
            display: flex;
            align-items: center;
            cursor: pointer;
        }
        
        .radio-option input {
            margin-right: 10px;
            cursor: pointer;
        }
        
        /* Button styling */
        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
            margin-top: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        button:hover {
            background-color: #1a6eae;
            transform: translateY(-1px);
            box-shadow: 0 3px 5px rgba(0,0,0,0.15);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        /* Plot container styling */
        #plot-container, #steptest-plot-container, #substrate-plot-container {
            height: 650px; 
            width: 100%; /* Stelle sicher, dass der Container die volle Breite nutzt */
            max-width: 100%; /* Begrenze die maximale Breite */
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.08);
            margin-bottom: 20px;
            padding: 5px;
            box-sizing: border-box; /* Stelle sicher, dass Padding nicht die Breite erhöht */
        }
        
        #substrate-plot-container {
            height: 350px; /* Smaller height for substrate plot */
            display: none; /* Initially hidden */
        }
        
        /* Values container for data display */
        #values-container {
            background-color: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.08);
            font-family: monospace;
            white-space: pre-wrap;
            height: 220px;
            overflow-y: auto;
            color: #444;
            font-size: 0.92rem;
            border-left: 4px solid var(--primary-color);
        }
        
        /* Notification popup */
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background-color: white;
            padding: 10px 15px;
            border-radius: 5px;
            box-shadow: 0 2px 15px rgba(0,0,0,0.2);
            display: none;
            max-width: 300px;
            z-index: 1000;
            animation: fadeIn 0.3s;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .notification.warning {
            border-left: 4px solid #42BA97; 
        }
        
        .notification.info {
            border-left: 4px solid var(--primary-color);
        }
        
        /* Subheading */
        h4 {
            margin-top: 15px;
            color: var(--primary-color);
        }
        
        /* Horizontal rule */
        hr {
            border: 0;
            height: 1px;
            background-color: var(--border-color);
            margin: 15px 0;
        }
        
        /* Dual slider container */
        .dual-slider-container {
            position: relative;
            margin-bottom: 15px;
        }
        
        .dual-slider {
            -webkit-appearance: none;
            width: 100%;
            height: 8px;
            border-radius: 5px;
            background: linear-gradient(to right, #ddd, var(--primary-color));
            outline: none;
            margin: 10px 0;
        }
        
        .dual-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--primary-color);
            cursor: pointer;
            z-index: 2;
        }
        
        .dual-slider-values {
            display: flex;
            justify-content: space-between;
            font-size: 0.9rem;
        }
        
        /* Header section with info icon */
        .header-section {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .info-icon {
        color: var(--primary-color);
        cursor: pointer;
        font-size: 1.2rem;
        display: flex;
        align-items: center;
        justify-content: center;
        width: 22px;
        height: 22px;
        border-radius: 50%;
        background-color: rgba(38, 131, 198, 0.1);
    }

    /* Tooltip styles */
    .tooltip {
        position: relative;
        display: inline-block;
    }

    .tooltip .tooltiptext {
        visibility: hidden;
        width: 220px;
        background-color: #555;
        color: #fff;
        text-align: left;
        border-radius: 6px;
        padding: 10px;
        position: absolute;
        z-index: 1000; /* Hoher z-index für Vordergrundanzeige */
        top: 25px;
        left: -10px; /* Leicht nach links versetzt */
        opacity: 0;
        transition: opacity 0.3s;
        font-size: 0.9rem;
        line-height: 1.4;
        box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        overflow-wrap: break-word;
        word-wrap: break-word;
        pointer-events: none; /* Verhindert, dass der Tooltip Mausklicks blockiert */
    }

    /* Stelle sicher, dass der Tooltip nicht über die Sidebar hinausragt */
    .sidebar .tooltip .tooltiptext {
        max-width: 280px; /* Etwas weniger als die Sidebar-Breite (350px) */
    }

    /* Tooltip position for icons near the right edge of sidebar */
    .sidebar .control-group .header-section .tooltip .tooltiptext,
    .sidebar .control-group .slider-label .tooltip .tooltiptext,
    .sidebar .control-group .parameter-row .tooltip .tooltiptext {
        left: auto;
        right: 0;
    }

    /* Tooltip position for icons in checkboxes that are right-aligned */
    .sidebar .checkbox-container .tooltip .tooltiptext {
        left: auto;
        right: 0;
    }

    .tooltip:hover .tooltiptext {
        visibility: visible;
        opacity: 1;
    }

    /* Axis controls container */
    .axis-controls {
        display: flex;
        justify-content: space-between;
        margin-bottom: 20px;
        padding: 10px;
        background-color: rgba(38, 131, 198, 0.05);
        border-radius: 4px;
    }

    /* Axis control checkbox container */
    .axis-control-container {
        margin-bottom: 10px;
    }

    .card-title {
        margin-bottom: 10px;
        font-weight: 600;
        font-size: 1.1rem;
        color: var(--primary-color);
        border-bottom: 1px solid var(--border-color);
        padding-bottom: 5px;
    }

    /* Fancy checkbox styling */
    .fancy-checkbox {
        display: inline-block;
        position: relative;
        padding-left: 30px;
        cursor: pointer;
        font-size: 0.9rem;
        user-select: none;
    }
        
        .fancy-checkbox input {
            position: absolute;
            opacity: 0;
            cursor: pointer;
            height: 0;
            width: 0;
        }
        
        .checkmark {
            position: absolute;
            top: 0;
            left: 0;
            height: 20px;
            width: 20px;
            background-color: #eee;
            border-radius: 3px;
            transition: all 0.2s;
        }
        
        .fancy-checkbox:hover input ~ .checkmark {
            background-color: #ccc;
        }
        
        .fancy-checkbox input:checked ~ .checkmark {
            background-color: var(--primary-color);
        }
        
        .checkmark:after {
            content: "";
            position: absolute;
            display: none;
        }
        
        .fancy-checkbox input:checked ~ .checkmark:after {
            display: block;
        }
        
        .fancy-checkbox .checkmark:after {
            left: 7px;
            top: 3px;
            width: 5px;
            height: 10px;
            border: solid white;
            border-width: 0 2px 2px 0;
            transform: rotate(45deg);
        }
        
        /* Small text helper */
        .small-text {
            font-size: 0.85rem;
            color: #666;
            margin-top: 5px;
        }
        
        /* Model info box */
        .model-info {
            font-size: 0.9rem;
            color: #666;
            margin: 10px 0;
            padding: 10px;
            border-left: 3px solid var(--secondary-color);
            background-color: rgba(66, 186, 151, 0.05);
        }
        
        /* Badge styles */
        .badge {
            display: inline-block;
            padding: 3px 7px;
            font-size: 0.75rem;
            font-weight: 600;
            border-radius: 12px;
            margin-left: 5px;
            vertical-align: middle;
        }
        
        .badge-primary {
            background-color: var(--primary-color);
            color: white;
        }
        
        .badge-secondary {
            background-color: var(--secondary-color);
            color: white;
        }
        
        .badge-accent {
            background-color: var(--accent-color);
            color: white;
        }
        
        /* Parameter row layout */
        .parameter-row {
            margin-bottom: 12px;
            display: flex;
            align-items: center;
        }
        
        .parameter-label {
            flex-grow: 1;
            font-size: 0.9rem;
        }

        /* Customize scrollbar for the sidebar */
        .sidebar::-webkit-scrollbar {
            width: 8px;
        }
        
        .sidebar::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }
        
        .sidebar::-webkit-scrollbar-thumb {
            background: #bbb;
            border-radius: 10px;
        }
        
        .sidebar::-webkit-scrollbar-thumb:hover {
            background: #999;
        }
        
        /* Tab Styling */
        .tabs {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .tab {
            padding: 10px 20px;
            cursor: pointer;
            transition: all 0.3s;
            border-bottom: 3px solid transparent;
            font-weight: 500;
        }
        
        .tab.active {
            color: var(--primary-color);
            border-bottom: 3px solid var(--primary-color);
        }
        
        .tab:hover:not(.active) {
            background-color: rgba(38, 131, 198, 0.05);
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        /* File Upload Styling */
        .file-upload {
            border: 2px dashed #ccc;
            border-radius: 5px;
            padding: 15px;
            margin: 10px 0;
            text-align: center;
            background-color: #f9f9f9;
            transition: all 0.3s;
            cursor: pointer;
        }
        
        .file-upload:hover {
            border-color: var(--primary-color);
            background-color: rgba(38, 131, 198, 0.05);
        }
        
        .file-upload input {
            display: none;
        }
        
        .file-upload-label {
            display: block;
            font-weight: 500;
            margin-bottom: 10px;
            color: #555;
        }
        
        .file-upload-info {
            font-size: 0.8rem;
            color: #777;
            margin-top: 10px;
        }
        
        .file-name {
            font-weight: 500;
            color: var(--primary-color);
            margin-top: 10px;
            word-break: break-all;
        }
        
        /* Swap axes container - removed as per request */
        .swap-axes-container {
            margin: 15px 0;
            padding: 10px;
            background-color: rgba(38, 131, 198, 0.05);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        /* Exercise Summary Statistics Styling */
        .exercise-summary {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.08);
            padding: 15px;
            margin: 20px 0;
            font-family: 'Roboto', sans-serif;
            height: 220px;
            overflow-y: auto;
            border-left: 4px solid var(--primary-color);
        }

        .exercise-summary h3 {
            margin-top: 0;
            color: var(--primary-color);
            font-size: 1.2rem;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border-color);
        }

        .summary-content {
            font-family: monospace;
            font-size: 0.92rem;
            color: #444;
        }

        .summary-row {
            margin-bottom: 6px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .summary-label {
            font-weight: 600;
        }

        .summary-value {
            font-weight: bold;
            color: var(--dark-color);
        }

        /* Disclaimer alert */
        .disclaimer-alert {
            background-color: #ffecb3;
            color: #7a5700;
            padding: 12px;
            margin-bottom: 15px;
            border-radius: 5px;
            border-left: 5px solid #ffc107;
            font-size: 0.9rem;
        }
        
        /* Efficiency parameter display */
        .eta-value {
            font-weight: bold;
            color: var(--primary-color);
            margin-left: 5px;
        }
        
        .eta-infobox {
            background-color: rgba(38, 131, 198, 0.05);
            padding: 10px;
            margin-top: 10px;
            border-left: 3px solid var(--primary-color);
            font-size: 0.9rem;
        }
        
        .formula {
            font-style: italic;
            margin: 5px 0;
            font-family: 'Times New Roman', serif;
        }
        
        /* Substrate utilization styles */
        .dropdown-container {
            margin: 10px 0;
        }
        
        .dropdown-label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            font-size: 0.9rem;
        }
        
        .dropdown-select {
            width: 100%;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background-color: white;
            font-size: 0.9rem;
            color: var(--dark-color);
            cursor: pointer;
        }
        
        .substrate-info {
            background-color: rgba(255, 165, 0, 0.1);
            padding: 10px;
            margin-top: 10px;
            border-left: 3px solid var(--cho-color);
            font-size: 0.9rem;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="sidebar" id="sidebar">
            <h1 style="font-size: 1.3em;">Mader's Metabolic Simulation</h1>
          
          <div class="tabs">
              <div class="tab active" data-tab="leistungsdiagramm">P-V̇O<sub>2</sub>-La Dynamics</div>
              <div class="tab" data-tab="belastungssimulation">Exercise Simulation</div>
          </div>
          
          <!-- Tab 1: Power Diagram Controls -->
          <div class="tab-content active" id="leistungsdiagramm-content">
              <div class="control-group" id="ce-controls">
                  <div class="header-section">
                      <div class="control-label">Oxygen Demand Settings</div>
                      <div class="tooltip info-icon">ⓘ
                          <span class="tooltiptext">Describes the P-V̇O<sub>2</sub>Relationship during incrementel cycling exercise</span>
                      </div>
                  </div>
                  
                  <div class="checkbox-container">
                      <label class="fancy-checkbox">
                          <input type="checkbox" id="curvilinear" name="curvilinear">
                          <span class="checkmark"></span>
                          Curvilinear CE relationship
                          <div class="tooltip info-icon" style="margin-left: 47px;">ⓘ
                              <span class="tooltiptext">
                                <p>A linear V̇O<sub>2</sub>-P relationship shows constant oxygen cost per unit work, suggesting uniform efficiency. The curvilinear model exhibits increasing oxygen consumption at higher intensities, reflecting physiological changes and decreased efficiency above lactate threshold.</p>
                                <p>Here, CE<sub>Start</sub> represents efficiency at the beginning of the V̇O<sub>2</sub>-P curve, while CE<sub>Target</sub> represents efficiency at the end, coinciding exactly with V̇O<sub>2,max</sub>.</p>
                              </span>
                          </div>
                      </label>
                  </div>
                  
                  <div id="linear-ce-control" class="slider-container">
                      <div class="slider-label">
                          <label for="CEVO2">CE (ml·min<sup>-1</sup>·W<sup>-1</sup>):</label>
                          <span id="CEVO2-value" class="slider-value">10.9</span>
                      </div>
                      <input type="range" id="CEVO2" class="range-slider" min="8" max="15" value="11" step="0.1">
                      
                      <div class="parameter-row" style="margin-top: 5px;">
                        <div class="parameter-label">Delta Efficiency (Δη):</div>
                        <span id="delta-eta-value" class="slider-value">24.7-26.5%</span>
                        <div class="tooltip info-icon" style="margin-left: 5px;">ⓘ
                            <span class="tooltiptext">                                  
                                <p>Delta efficiency is calculated from the slope of the P-V̇O<sub>2</sub>-Relationship (CE) using the caloric equivalent (depends on the RQ value with a range between 19.62 and 21.13 [kJ·l<sup>-1</sup>]):</p>
                                <p>Δη = 1 / ((CE · caloric Equivalent) / 60)</p>
                                <p>Example: Δη = 1 / ((11.65 · 20.87) / 60) ≈ 24.7%</p>
                            </span>
                        </div>
                    </div>
                    
                    <div class="parameter-row">
                        <div class="parameter-label">η<sub>gross</sub> (Fat<sub>max</sub> | MLSS):</div>
                        <span id="gross-eta-value" class="slider-value">FAT<sub>max</sub>:20.3% | MLSS=23.1%</span>
                        <div class="tooltip info-icon" style="margin-left: 5px;">ⓘ
                            <span class="tooltiptext">                                  
                                <p>Gross efficiency is the ratio of mechanical work performed to total aerobic energy expenditure:</p>
                                <p>η<sub>gross</sub> = (Power output [Watt]) / (Aerobic energy expenditure [Watt])</p>
                                <p>Typically ranging from 19-22% in cycling. Values are calculated at both FAT<sub>max</sub> and MLSS power outputs using the predicted RQ to determine caloric equivalents.</p>
                            </span>
                        </div>
                    </div>
                    
                    <div class="parameter-row">
                        <div class="parameter-label">η<sub>net</sub> (Fat<sub>max</sub> | MLSS):</div>
                        <span id="net-eta-value" class="slider-value">FAT<sub>max</sub>=24.2% | MLSS=27.5%</span>
                        <div class="tooltip info-icon" style="margin-left: 5px;">ⓘ
                            <span class="tooltiptext">                                  
                                <p>Net efficiency is the ratio of mechanical work performed to aerobic energy expenditure above resting level:</p>
                                <p>η<sub>net</sub> = (Power output [Watt]) / (Aerobic energy expenditure - Resting energy expenditure [Watt])</p>
                                <p>By eliminating the influence of resting metabolism, net efficiency yields systematically higher values than gross efficiency, typically between 19-24% in cycling. This calculation accounts for the energy that's actually used for the exercise itself rather than basic bodily functions.</p>
                            </span>
                        </div>
                    </div>
                  </div>
                  
                  <div id="curvilinear-ce-control" class="slider-container" style="display:none;">
                      <div class="slider-label">
                          <label for="CE_range_start">CE<sub>Start</sub> (ml·min<sup>-1</sup>·W<sup>-1</sup>):</label>
                          <span id="CE_range_start-value" class="slider-value">11.0</span>
                      </div>
                      <input type="range" id="CE_range_start" class="range-slider" min="8" max="15" value="11" step="0.1">
                      
                      <div class="slider-label">
                          <label for="CE_range_end">CE<sub>Target</sub> (ml·min<sup>-1</sup>·W<sup>-1</sup>):</label>
                          <span id="CE_range_end-value" class="slider-value">12.0</span>
                      </div>
                      <input type="range" id="CE_range_end" class="range-slider" min="8" max="15" value="12" step="0.1">
                  </div>
              </div>
              
              <div class="control-group">
                  <div class="header-section">
                      <div class="control-label">Cadence Dependency</div>
                      <div class="tooltip info-icon">ⓘ
                          <span class="tooltiptext">Incorporate cycling cadence effects on the V̇O<sub>2</sub>-P relationship as described in Dunst et al. (2025). This modifies metabolic parameters based on the pedaling rate.</span>
                      </div>
                  </div>
                  
                  <div class="checkbox-container">
                      <label class="fancy-checkbox">
                          <input type="checkbox" id="cadence_dependent" name="cadence_dependent">
                          <span class="checkmark"></span>
                          Enable U-Shaped Cadence Dependency
                      </label>
                  </div>
                  
                  <div id="cadence-controls" style="display:none;">
                      <div id="cadence-control" class="slider-container">
                          <div class="slider-label">
                              <label for="cadence">Cadence (rpm):</label>
                              <span id="cadence-value" class="slider-value">80</span>
                          </div>
                          <input type="range" id="cadence" class="range-slider" min="20" max="200" value="80" step="1">
                      </div>
                      
                  <div class="parameter-row">
                      <div class="parameter-label">CE-Dependency:</div>
                      <div class="spacer"></div>
                      <div class="tooltip info-icon">ⓘ
                          <span class="tooltiptext">Formula: CEV̇O<sub>2</sub>(rpm) = 0.0004 · rpm² - 0.094 · rpm + 16.857. Research shows a U-shaped relationship between cadence and oxygen demand per watt.</span>
                      </div>
                      <span class="slider-value">✓</span>
                  </div>
                  
                  <div class="parameter-row">
                      <div class="parameter-label">V̇O<sub>2,Base</sub> Dependency:</div>
                      <div class="spacer"></div>
                      <div class="tooltip info-icon">ⓘ
                          <span class="tooltiptext">Formula: V̇O<sub>2,Base</sub>(rpm) = 0.172 · rpm² - 14.460 · rpm + 548.039. Research shows a U-shaped relationship between cadence and resting oxygen uptake.</span>
                      </div>
                      <span class="slider-value">✓</span>
                  </div>
                      
                  <div class="checkbox-container">
                      <label class="fancy-checkbox">
                          <input type="checkbox" id="vo2max_dependent" name="vo2max_dependent">
                          <span class="checkmark"></span>
                          Include V̇O<sub>2,max</sub> Dependency
                      </label>
                      <div class="tooltip info-icon">ⓘ
                          <span class="tooltiptext">Based on Fig.4 from the paper, V̇O<sub>2,max</sub> might also be slightly cadence-dependent, with optimal values around 80-90 rpm. This is an experimental feature.</span>
                      </div>
                      <span class="slider-value">?</span>
                  </div>
                  
                  <div class="checkbox-container">
                      <label class="fancy-checkbox">
                          <input type="checkbox" id="vlamax_dependent" name="vlamax_dependent">
                          <span class="checkmark"></span>
                          Include vLa<sub>max</sub> Dependency 
                      </label>
                      <div class="tooltip info-icon">ⓘ
                          <span class="tooltiptext">Formula: vLa<sub>max</sub>(rpm) = -0.0002 · rpm² + 0.00931 · rpm. The paper suggests this may not reflect true physiological processes but rather testing methodology limitations.</span>
                      </div>
                      <span class="slider-value">?</span>
                  </div>
              </div>
                  
                  <div class="small-text">Based on the research from Dunst et al. (2025) showing how metabolic parameters vary with cycling cadence.</div>
              </div>
              
              <div class="control-group">
                  <div class="header-section">
                      <div class="control-label">Physiological Input-Parameters</div>
                      <div class="tooltip info-icon">ⓘ
                          <span class="tooltiptext">Physiological input parameters to calculate workload-specific metabolic response according to Mader's metabolic model.</span>
                      </div>
                  </div>
                  
                  <div class="slider-container">
                      <div class="slider-label">
                          <label for="VO2max">V̇O<sub>2,max</sub> (ml·min<sup>-1</sup>):</label>
                          <span id="VO2max-value" class="slider-value">6000</span>
                      </div>
                      <input type="range" id="VO2max" class="range-slider" min="2000" max="7500" value="6000" step="10">
                  </div>
                  
                  <div class="slider-container">
                      <div class="slider-label">
                          <label for="VO2max_kg">V̇O<sub>2,max</sub> (ml·min<sup>-1</sup>·kg<sup>-1</sup>):</label>
                          <span id="VO2max_kg-value" class="slider-value">66.67</span>
                      </div>
                      <input type="range" id="VO2max_kg" class="range-slider" min="30" max="100" value="66.67" step="0.01">
                  </div>
                  
                  <div class="slider-container">
                      <div class="slider-label">
                          <label for="VO2Base">V̇O<sub>2,Base</sub> (ml·min<sup>-1</sup>):</label>
                          <span id="VO2Base-value" class="slider-value">394</span>
                      </div>
                      <input type="range" id="VO2Base" class="range-slider" min="200" max="800" value="394" step="1">
                  </div>
                  
                  <div class="slider-container">
                      <div class="slider-label">
                          <label for="vLamax">vLa<sub>max</sub> (mmol·l<sup>-1</sup>·s<sup>-1</sup>):</label>
                          <span id="vLamax-value" class="slider-value">0.96</span>
                      </div>
                      <input type="range" id="vLamax" class="range-slider" min="0.20" max="1.50" value="0.96" step="0.01">
                  </div>
                  
                  <div class="checkbox-container">
                      <label class="fancy-checkbox">
                          <input type="checkbox" id="weight_based" name="weight_based">
                          <span class="checkmark"></span>
                          Weight-based values
                      </label>
                  </div>
                  </div>
              
              <div class="control-group">
                  <div class="header-section">
                      <div class="control-label">V̇O<sub>2,Base</sub> Calculation</div>
                      <div class="tooltip info-icon">ⓘ
                          <span class="tooltiptext">Calculation of resting oxygen consumption based on anthropometric data.</span>
                      </div>
                  </div>
                  
                  <div class="radio-group">
                      <div class="control-label">Gender:</div>
                      <div class="radio-option">
                          <input type="radio" id="male" name="gender" value="Male" checked>
                          <label for="male">Male</label>
                      </div>
                      <div class="radio-option">
                          <input type="radio" id="female" name="gender" value="Female">
                          <label for="female">Female</label>
                      </div>
                  </div>
                  
                  <div class="slider-container">
                      <div class="slider-label">
                          <label for="body_mass">Body Mass (kg):</label>
                          <span id="body_mass-value" class="slider-value">92.0</span>
                      </div>
                      <input type="range" id="body_mass" class="range-slider" min="40" max="120" value="92" step="0.1">
                  </div>
                  
                  <div class="slider-container">
                      <div class="slider-label">
                          <label for="age">Age (years):</label>
                          <span id="age-value" class="slider-value">28</span>
                      </div>
                      <input type="range" id="age" class="range-slider" min="18" max="100" value="28" step="1">
                  </div>
                  
                  <div class="slider-container">
                      <div class="slider-label">
                          <label for="height">Height (cm):</label>
                          <span id="height-value" class="slider-value">193</span>
                      </div>
                      <input type="range" id="height" class="range-slider" min="140" max="220" value="193" step="1">
                  </div>
                  
                  <button id="calculate_vo2base" type="button">Calculate V̇O<sub>2</sub>Base</button>
                  
                  <div class="small-text">Uses the Harris-Benedict equation to estimate basal metabolic rate, which is then converted to oxygen consumption.</div>
              </div>
              
              <!-- Substrate utilization section -->
              <div class="control-group">
                  <div class="header-section">
                      <div class="control-label">Substrate Utilization</div>
                      <div class="tooltip info-icon">ⓘ
                          <span class="tooltiptext">Display carbohydrate and fat oxidation rates based on lactate balance calculation. Shows the substrate contribution to total energy production across workloads.</span>
                      </div>
                  </div>
                  
                  <div class="checkbox-container">
                      <label class="fancy-checkbox">
                          <input type="checkbox" id="show_substrate" name="show_substrate">
                          <span class="checkmark"></span>
                          Show Substrate Utilization
                      </label>
                  </div>
                  
                  <div id="substrate-controls" style="display:none;">
                      <div class="dropdown-container">
                          <label for="energy_unit" class="dropdown-label">Energy Unit:</label>
                          <select id="energy_unit" class="dropdown-select">
                              <option value="g/h">g/h</option>
                              <option value="kcal/h">kcal/h</option>
                              <option value="kJ/h">kJ/h</option>
                          </select>
                      </div>
                      
                      <div class="checkbox-container">
                          <label class="fancy-checkbox">
                              <input type="checkbox" id="show_kh_adjust" name="show_kh_adjust">
                              <span class="checkmark"></span>
                              Adjust CHO utilization at rest
                              <div class="tooltip info-icon" style="margin-left: 5px;">ⓘ
                                  <span class="tooltiptext">Allows adjustment of the carbohydrate utilization at rest (default is based purely on the model calculations, but you can adjust to match empirical values. According to Friedlander (1998, 1999) and Brooks (2012), total CHO percentage at rest is approximately 35-40%, at 45% of V̇O<sub>2,peak</sub> about 50-60%, and at 65% of V̇O<sub>2,peak</sub> about 60-70%. It should be noted that empirical measurements tend to show higher fat metabolism and carbohydrate utilization at rest compared to pure model calculations).</span>
                              </div>
                          </label>
                      </div>
                      
                      <div id="kh-adjust-control" style="display:none;">
                          <div class="slider-container">
                              <div class="slider-label">
                                  <label for="rest_kh_percentage">Resting CHO percentage (%):</label>
                                  <span id="rest_kh_percentage-value" class="slider-value">20</span>
                              </div>
                              <input type="range" id="rest_kh_percentage" class="range-slider" min="0" max="100" value="20" step="1">
                          </div>
                      </div>
                      
                      <!-- Swap VO2 and Power axes option removed as per request -->
                  </div>
                  
                <div class="substrate-info" style="display:none;" id="substrate-info">
                    <p>The substrate utilization calculation is based on the metabolic model:</p>
                    <ul style="padding-left: 20px; margin: 5px 0;">
                        <li>Carbohydrate oxidation increases with power, reaching 100% at MLSS</li>
                        <li>Fat oxidation is highest at FAT<sub>max</sub> intensity</li>
                        <li>CHO:Fat ratio is determined by the relationship between lactate production (vLa<sub>ss</sub>) and elimination (vLa<sub>ox</sub>)</li>
                    </ul>
                    <p>The energy equivalents used: 4.1 kcal/g for CHO and 9.45 kcal/g for fat.</p>
                    <p>The predicted Respiratory Quotient (RQ) is calculated from the substrate mix (0.70 for 100% fat, 1.00 for 100% CHO). 
                    The caloric equivalent is determined from RQ using Stegemann's table (1990), which is used for efficiency calculations.</p>
                </div>
              </div>
              
              <div class="control-group">
                  <div class="axis-controls">
                      <div class="card-title">Plot Settings</div>
                      <div>
                          <label class="fancy-checkbox">
                              <input type="checkbox" id="lock_y_axis" name="lock_y_axis" checked>
                              <span class="checkmark"></span>
                              Lock Y-Axis
                          </label>
                      </div>
                      <div>
                          <label class="fancy-checkbox">
                              <input type="checkbox" id="lock_x_axis" name="lock_x_axis" checked>
                              <span class="checkmark"></span>
                              Lock X-Axis
                          </label>
                      </div>
                  </div>
              </div>
          </div>

          <!-- Tab 2: Exercise Simulation Controls -->
          <div class="tab-content" id="belastungssimulation-content">
              <!-- Disclaimer Alert -->
              <div class="disclaimer-alert">
                  <strong><em>Disclaimer:</em> This tab and all calculations are still under development and should be considered experimental only!</strong>
              </div>
              
              <div class="control-group">
                  <div class="header-section">
                      <div class="control-label">Step Test Simulation Parameters</div>
                      <div class="tooltip info-icon">ⓘ
                          <span class="tooltiptext">Parameters for the step test or exercise simulation.</span>
                      </div>
                  </div>
                  
                  <div class="slider-container">
                      <div class="slider-label">
                          <label for="step_watt">Step Increment (Watts):</label>
                          <span id="step_watt-value" class="slider-value">20</span>
                      </div>
                      <input type="range" id="step_watt" class="range-slider" min="1" max="200" value="20" step="1">
                  </div>
                  
                  <div class="slider-container">
                      <div class="slider-label">
                          <label for="step_duration">Step Duration (s):</label>
                          <span id="step_duration-value" class="slider-value">30</span>
                      </div>
                      <input type="range" id="step_duration" class="range-slider" min="1" max="1800" value="30" step="1">
                  </div>
                  
                  <div class="slider-container">
                      <div class="slider-label">
                          <label for="max_power_step">Maximum Power (Watts):</label>
                          <span id="max_power_step-value" class="slider-value">560</span>
                      </div>
                      <input type="range" id="max_power_step" class="range-slider" min="100" max="1000" value="560" step="10">
                  </div>
                  
                  <div class="slider-container">
                      <div class="slider-label">
                          <label for="power_scale">Power Adjustment (%):</label>
                          <span id="power_scale-value" class="slider-value">100</span>
                      </div>
                      <input type="range" id="power_scale" class="range-slider" min="0" max="200" value="100" step="1">
                  </div>
                  
                  <button id="load_interval_example" type="button">Load Example Exercise Data</button>
                  
                  <div class="file-upload" style="margin-top: 20px;">
                    <label for="power_data" class="file-upload-label">Insert workout file</label>
                    <input type="file" id="power_data" accept=".csv,.txt,.xlsx,.xls">
                    <div class="file-upload-info">Supported formats: CSV, TXT, XLSX with time/timestamp, power and cadence data</div>
                    <div id="file-name" class="file-name"></div>
                </div>

                <div class="checkbox-container">
                    <label class="fancy-checkbox">
                        <input type="checkbox" id="has_header" name="has_header" checked>
                        <span class="checkmark"></span>
                        File has headers
                    </label>
                </div>

                <div class="radio-group" style="margin-top: 10px; font-size: 0.95em;">
                    <div class="control-label">Uploaded workout data gap processing:</div>
                    <div class="radio-option">
                      <input type="radio" id="gap_handling_last" name="gap_handling" value="last" checked>
                      <label for="gap_handling_last">Maintain last values</label>
                      <div class="tooltip info-icon" style="margin-left: 5px;">ⓘ
                        <span class="tooltiptext">When processing your uploaded workout file, time gaps will be filled with the last recorded power value. This displays intervals without drops in power visualization, ideal to construct interval training data.</span>
                      </div>
                    </div>
                    <div class="radio-option">
                      <input type="radio" id="gap_handling_zero" name="gap_handling" value="zero"> 
                      <label for="gap_handling_zero">Insert zero values</label>
                      <div class="tooltip info-icon" style="margin-left: 5px;">ⓘ
                        <span class="tooltiptext">When processing your uploaded workout file, all time gaps will be filled with zero power values. This creates clear visual breaks in your power data, suitable for analyzing training sessions with rest periods.</span>
                      </div>
                    </div>
                  </div>
                
                <button id="smooth_power" type="button">Smooth Power Curve (5-point window)</button>

                <div class="control-group">
                    <div class="header-section">
                        <div class="control-label">Display Window Settings</div>
                        <div class="tooltip info-icon">ⓘ
                            <span class="tooltiptext">Adjust the display window for time and Y-Axis values in the plot without affecting the simulation calculations.</span>
                        </div>
                    </div>
                    
                    <div class="axis-control-container">
                        <label class="fancy-checkbox">
                            <input type="checkbox" id="customize_time_window" name="customize_time_window">
                            <span class="checkmark"></span>
                            Adjust X-Axis range
                        </label>
                    </div>
                    
                    <div id="time-window-sliders" style="display:none;">
                        <div class="slider-container">
                            <div class="slider-label">
                                <label for="view_time_start">Start Time (s):</label>
                                <span id="view_time_start-value" class="slider-value">0</span>
                            </div>
                            <input type="range" id="view_time_start" class="range-slider" min="0" max="7200" value="0" step="1">
                        </div>
                        
                        <div class="slider-container">
                            <div class="slider-label">
                                <label for="view_time_end">End Time (s):</label>
                                <span id="view_time_end-value" class="slider-value">3600</span>
                            </div>
                            <input type="range" id="view_time_end" class="range-slider" min="0" max="14400" value="3600" step="1">
                        </div>
                    </div>
                    
                    <div class="axis-control-container">
                        <label class="fancy-checkbox">
                            <input type="checkbox" id="customize_y_axis" name="customize_y_axis">
                            <span class="checkmark"></span>
                            Adjust Y-Axis ranges
                        </label>
                    </div>
                    
                    <div id="y-axis-sliders" style="display:none;">
                        <div class="slider-container">
                            <div class="slider-label">
                                <label for="view_power_max">Power Y-Axis Maximum:</label>
                                <span id="view_power_max-value" class="slider-value">1420</span>
                            </div>
                            <input type="range" id="view_power_max" class="range-slider" min="100" max="2000" value="1420" step="50">
                        </div>
                        
                        <div class="slider-container">
                            <div class="slider-label">
                                <label for="view_vo2_max">V̇O<sub>2</sub> Y-Axis Maximum:</label>
                                <span id="view_vo2_max-value" class="slider-value">6500</span>
                            </div>
                            <input type="range" id="view_vo2_max" class="range-slider" min="1000" max="10000" value="6500" step="500">
                        </div>
                        
                        <div class="slider-container">
                            <div class="slider-label">
                                <label for="view_lactate_min">Lactate Y-Axis Minimum:</label>
                                <span id="view_lactate_min-value" class="slider-value">0</span>
                            </div>
                            <input type="range" id="view_lactate_min" class="range-slider" min="-20" max="5" value="0" step="1">
                        </div>
                        
                        <div class="slider-container">
                            <div class="slider-label">
                                <label for="view_lactate_max">Lactate Y-Axis Maximum:</label>
                                <span id="view_lactate_max-value" class="slider-value">25</span>
                            </div>
                            <input type="range" id="view_lactate_max" class="range-slider" min="5" max="50" value="25" step="1">
                        </div>
                    </div>
                </div>
              </div>

              <div class="control-group">
                <div class="header-section">
                    <div class="control-label">Cadence Dependency</div>
                    <div class="tooltip info-icon">ⓘ
                        <span class="tooltiptext">Incorporate cycling cadence effects for the exercise simulation. This modifies metabolic parameters based on the pedaling rate.</span>
                    </div>
                </div>
                
                <div class="checkbox-container">
                    <label class="fancy-checkbox">
                        <input type="checkbox" id="cadence_dependent_step" name="cadence_dependent_step">
                        <span class="checkmark"></span>
                        Enable U-Shaped Cadence Dependency
                    </label>
                </div>
                
                <div id="cadence-controls-step" style="display:none;">
                    <div class="slider-container">
                        <div class="slider-label">
                            <label for="cadence_step">Fixed Cadence (rpm):</label>
                            <span id="cadence_step-value" class="slider-value">90</span>
                        </div>
                        <input type="range" id="cadence_step" class="range-slider" min="20" max="200" value="90" step="1">
                    </div>
                    
                    <div class="checkbox-container">
                        <label class="fancy-checkbox">
                            <input type="checkbox" id="use_file_cadence" name="use_file_cadence" checked>
                            <span class="checkmark"></span>
                            Use cadence from file (if available)
                            <div class="tooltip info-icon" style="margin-left: 5px;">ⓘ
                                <span class="tooltiptext">If checked and available in the uploaded data, cadence values from the file will be used instead of the fixed value above.</span>
                            </div>
                        </label>
                    </div>
                    
                    <div class="parameter-row">
                        <div class="parameter-label">CE (CEV̇O<sub>2</sub>) Dependency:</div>
                        <div class="tooltip info-icon">ⓘ
                            <span class="tooltiptext">Formula: CEV̇O<sub>2</sub>(rpm) = 0.0004 · rpm² - 0.094 · rpm + 16.857</span>
                        </div>
                        <span class="slider-value">✓</span>
                    </div>
                    
                    <div class="parameter-row">
                        <div class="parameter-label">V̇O<sub>2,Base</sub> Dependency:</div>
                        <div class="tooltip info-icon">ⓘ
                            <span class="tooltiptext">Formula: V̇O<sub>2,Base</sub>(rpm) = 0.172 · rpm² - 14.460 · rpm + 548.039</span>
                        </div>
                        <span class="slider-value">✓</span>
                    </div>
                    
                    <div class="checkbox-container">
                        <label class="fancy-checkbox">
                            <input type="checkbox" id="vo2max_dependent_step" name="vo2max_dependent_step">
                            <span class="checkmark"></span>
                            Include V̇O<sub>2,max</sub> Dependency
                        </label>
                    </div>
                    
                    <div class="checkbox-container">
                        <label class="fancy-checkbox">
                            <input type="checkbox" id="vlamax_dependent_step" name="vlamax_dependent_step">
                            <span class="checkmark"></span>
                            Include vLa<sub>max</sub> Dependency
                        </label>
                    </div>
                </div>
                
                <div class="small-text">Based on the research from Dunst et al. (2025) showing how metabolic parameters vary with cycling cadence.</div>
            </div>
            
            <div class="control-group">
                <div class="header-section">
                    <div class="control-label">Physiological Parameters</div>
                    <div class="tooltip info-icon">ⓘ
                        <span class="tooltiptext">Physiological parameters for the simulation calculation.</span>
                    </div>
                </div>

                    <div class="slider-container">
                        <div class="slider-label" style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <label for="vo2_start">V̇O₂ Start (ml·min<sup>-1</sup>):</label>
                                <span id="vo2_start-value" class="slider-value">--</span>
                            </div>
                            <div class="tooltip info-icon">ⓘ
                                <span class="tooltiptext">Initial V̇O₂ value for the exercise simulation. Defaults to V̇O₂ at FATmax. Constrained between V̇O₂Base and V̇O₂max.</span>
                            </div>
                        </div>
                        <input type="range" id="vo2_start" class="range-slider" min="200" max="7500" value="400" step="1">
                    </div>
                
            <!-- Container for Mono-exponential ON Slider -->
            <div id="monoexponential-on-control">
                <div class="slider-container">
                    <div class="slider-label">
                        <label for="vo2_up_time_constant">V̇O<sub>2,on</sub> time constant (τ<sub>on</sub>) (s):</label>
                        <span id="vo2_up_time_constant-value" class="slider-value">30</span>
                    </div>
                    <input type="range" id="vo2_up_time_constant" class="range-slider" min="0" max="120" value="30" step="1">
                </div>
            </div>

            <!-- Container for Mono-exponential OFF Slider -->
            <div id="monoexponential-off-control">
                <div class="slider-container">
                    <div class="slider-label">
                        <label for="vo2_down_time_constant">V̇O<sub>2,off</sub> time constant (τ<sub>off</sub>) (s):</label>
                        <span id="vo2_down_time_constant-value" class="slider-value">35</span>
                    </div>
                          
<input type="range" id="vo2_down_time_constant" class="range-slider" min="10" max="120" value="35" step="1"> <!-- Min value adjusted to 10 -->
</div>

<!-- START: Intensity-Dependent Tau_Off Checkbox -->
<div class="checkbox-container" style="margin-top: -5px; margin-bottom: 15px;">
    <label class="fancy-checkbox">
        <input type="checkbox" id="dynamic_tau_off" name="dynamic_tau_off">
        <span class="checkmark"></span>
        Intensity-Dependent τ<sub>off</sub>
        <div class="tooltip info-icon" style="margin-left: 5px;">ⓘ
            <span class="tooltiptext" style="width: 260px; left: auto; right: 0;"> <!-- Adjusted width slightly -->
                <p><strong>Dynamic τ<sub>off</sub>:</strong> Adjusts V̇O₂ recovery time (τ<sub>off</sub>) based on recent intensity.</p>
                <p><strong>How:</strong> Finds max V̇O₂ (% of V̇O₂<sub>max</sub>) in the last <strong>2 * previous τ<sub>off</sub></strong> seconds.</p>
                <p><strong>Formula:</strong> Calculates a base τ<sub>off</sub> using:<br>
                   <code>τ<sub>off_base</sub> = 0.45 * Intensity% + 10</code></p>
                <p><strong>Slider Role:</strong> When active, slider sets τ<sub>off</sub> for <strong>50%</strong> intensity (default ≈ 33s), shifting the linear τ<sub>off</sub>-intensity relationship.</p>
                <p><em>Simulates faster recovery after lower intensity, slower after higher intensity.</em></p>
            </span>
        </div>
    </label>
</div>
<!-- END: Intensity-Dependent Tau_Off Checkbox -->

<!-- NEW: VO2 Delay Slider -->


            <div class="slider-container">
                    <div class="slider-label" style="display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <label for="vo2_delay">V̇O₂ Response Delay (s):</label>
                            <span id="vo2_delay-value" class="slider-value">2</span>
                        </div>
                        <div class="tooltip info-icon">ⓘ
                            <span class="tooltiptext">Pure time delay (in seconds) before V̇O₂ starts responding kinetically to a change in intensity. Simulates transport and initial metabolic inertia. Affects V̇O₂ actual, O₂ deficit, vLaOx, etc. Default: 2s. Range: 0-10s.</span>
                        </div>
                    </div>
                    <input type="range" id="vo2_delay" class="range-slider" min="0" max="10" value="2" step="1">
                </div>
            </div>
                
                <div class="slider-container">
                    <div class="slider-label">
                        <label for="la_max">Lactate exercise termination value (mmol·l<sup>-1</sup>):</label>
                        <span id="la_max-value" class="slider-value">20.0</span>
                    </div>
                    <input type="range" id="la_max" class="range-slider" min="4" max="30" value="20" step="0.5">
                </div>
                
                <div class="checkbox-container">
                    <label class="fancy-checkbox">
                        <input type="checkbox" id="use_lactate_abort" name="use_lactate_abort">
                        <span class="checkmark"></span>
                        Terminate simulation when lactate exceeds max value
                        <div class="tooltip info-icon" style="margin-left: 5px;">ⓘ
                            <span class="tooltiptext">When checked, the simulation will terminate if blood lactate concentration exceeds the specified maximum value.</span>
                        </div>
                    </label>
                </div>
                
                <div class="slider-container">
                    <div class="slider-label">
                        <label for="la_base">Resting Lactate-value (mmol·l<sup>-1</sup>):</label>
                        <span id="la_base-value" class="slider-value">0.8</span>
                    </div>
                    <input type="range" id="la_base" class="range-slider" min="0.5" max="2" value="0.8" step="0.1">
                </div>

                            <!-- vLass ON Time Constant Slider -->
                            <div class="slider-container">
                                <div class="slider-label" style="display: flex; justify-content: space-between; align-items: center;">
                                    <div>
                                        <label for="vLass_on_tau">vLa<sub>SS,on</sub> Time Constant (τ<sub>vLaSS,on</sub>) (s):</label>
                                        <span id="vLass_on_tau-value" class="slider-value">5</span>
                                    </div>
                                    <div class="tooltip info-icon">ⓘ
                                        <span class="tooltiptext">Time constant for the exponential rise of the lactate production rate (vLa<sub>SS</sub>) during increases in intensity. Represents how quickly vLa<sub>SS</sub> approaches its higher target value. Default: 5s.</span>
                                    </div>
                                </div>
                                <input type="range" id="vLass_on_tau" class="range-slider" min="1" max="60" value="5" step="1">
                            </div>

                            <!-- vLass OFF Time Constant Slider -->
                            <div class="slider-container">
                                <div class="slider-label" style="display: flex; justify-content: space-between; align-items: center;">
                                    <div>
                                        <label for="vLass_off_tau">vLa<sub>SS,off</sub> Time Constant (τ<sub>vLaSS,off</sub>) (s):</label>
                                        <span id="vLass_off_tau-value" class="slider-value">2</span>
                                    </div>
                                    <div class="tooltip info-icon">ⓘ
                                        <span class="tooltiptext">Time constant for the exponential fall of the lactate production rate (vLa<sub>SS</sub>) during decreases in intensity or recovery. Represents how quickly vLa<sub>SS</sub> approaches its lower target value. Default: 2s.</span>
                                    </div>
                                </div>
                                <input type="range" id="vLass_off_tau" class="range-slider" min="1" max="60" value="2" step="1">
                            </div>
                            <!-- vLaSS Delay Slider -->
                            <div class="slider-container">
                                <div class="slider-label" style="display: flex; justify-content: space-between; align-items: center;">
                                    <div>
                                        <label for="vlass_delay">vLa<sub>SS</sub> Response Delay (s):</label>
                                        <span id="vlass_delay-value" class="slider-value">2</span>
                                    </div>
                                    <div class="tooltip info-icon">ⓘ
                                        <span class="tooltiptext">Pure time delay (in seconds) before lactate production rate (vLa<sub>SS</sub>) starts responding kinetically to a change in intensity. Simulates delays in glycolytic pathway activation. Affects calculated lactate dynamics. Default: 2s. Range: 0-10s.</span>
                                    </div>
                                </div>
                                <input type="range" id="vlass_delay" class="range-slider" min="0" max="10" value="2" step="1">
                            </div>

                            <div style="margin-top: 15px; padding-top: 10px; border-top: 1px solid var(--border-color);">
                                <div class="header-section" style="margin-bottom: 5px;">
                                    <div class="parameter-label" style="flex-grow: 1;">Muscle pH (pH<sub>m</sub>) Simulation</div>
                                    <div class="tooltip info-icon" style="margin-left: 5px;">ⓘ
                                        <span class="tooltiptext" style="width: 270px; left: auto; right: 0;"> <!-- Tooltip nach links öffnen -->
                                            <p><strong>Muscle pH (pH<sub>m</sub>) & Glycolysis Simulation (Tab 2):</strong></p>
                                            <p>pH<sub>m</sub> is calculated based on Mader (2003) / Heck & Bartmus (2022, Ch. 4), using estimated [Pi] (from PCr), [La]<sub>m</sub> (from La<sub>Accumulation</sub>), and pCO₂ (from %V̇O₂max).</p>
                                            <p> The calculated pH<sub>m</sub> of the previous step is used to regulate the effective maximal lactate production rate (vLa<sub>max,eff</sub>) for the current step, simulating pH inhibition of PFK (phosphofructokinase):</p>
                                            <p style="font-family: monospace; font-size: 0.85em; margin-left: 10px;">vLa<sub>max,eff</sub> = vLa<sub>max,base</sub> * PFK_Activity_Factor(pH<sub>m</sub>)</p>
                                            <p>This pH-modulated vLa<sub>max,eff</sub> then determines the target lactate production rate (vLa<sub>ss</sub>).</p>
                                            <p><i>Ref: Heck, H., & Bartmus, U. (2022). Laktat (p. 59, 85). Springer.</i></p>
                                            <p><i>Note: Uses approximations.</i></p>
                                        </span>
                                    </div>
                                </div>
                            </div>
            </div>
            
            <!-- Glycogen Storage Parameters Section -->
            <div class="control-group">
                <div class="header-section">
                    <div class="control-label">Glycogen Storage Parameters</div>
                    <div class="tooltip info-icon">ⓘ
                        <span class="tooltiptext">Parameters for simulating muscle glycogen storage dynamics during exercise and carbohydrate intake.</span>
                    </div>
                </div>
                
                <!-- Added auto-calculate button for glycogen values based on muscle mass -->
                <div class="checkbox-container">
                    <label class="fancy-checkbox">
                        <input type="checkbox" id="auto_glycogen" name="auto_glycogen">
                        <span class="checkmark"></span>
                        Auto-calculate glycogen values based on muscle mass
                        <div class="tooltip info-icon" style="margin-left: 5px;">ⓘ
                            <span class="tooltiptext">Calculate glycogen-store values based on active muscle mass.</span>
                        </div>
                    </label>
                </div>
                
                <div class="slider-container">
                    <div class="slider-label">
                        <label for="glycogen_init">Initial Glycogen Storage (g):</label>
                        <span id="glycogen_init-value" class="slider-value">350</span>
                    </div>
                    <input type="range" id="glycogen_init" class="range-slider" min="0" max="800" value="350" step="10">
                </div>
                
                <div class="slider-container">
                    <div class="slider-label">
                        <label for="glycogen_max">Maximum Glycogen Storage (g):</label>
                        <span id="glycogen_max-value" class="slider-value">350</span>
                    </div>
                    <input type="range" id="glycogen_max" class="range-slider" min="100" max="800" value="350" step="10">
                </div>
                
                <div class="slider-container">
                    <div class="slider-label">
                        <label for="carb_intake_rate">Carbohydrate Intake Rate (g·h<sup>-1</sup>):</label>
                        <span id="carb_intake_rate-value" class="slider-value">0</span>
                    </div>
                    <input type="range" id="carb_intake_rate" class="range-slider" min="0" max="150" value="0" step="5">
                </div>
                
                <div class="substrate-info">
                    <p>Glycogen storage model assumptions:</p>
                    <ul style="padding-left: 20px; margin: 5px 0;">
                        <li>Carbohydrate utilization increases with intensity and reaches 100% at and above MLSS</li>
                        <li>Glycogen depletion rate is calculated from actual CHO oxidation rate</li>
                        <li>A typical well-loaded muscle glycogen storage is 350-500g for a trained cyclist</li>
                        <li>Maximum carbohydrate intake and utilization is typically 60-90g/h (with appropriate training)</li>
                    </ul>
                </div>
            </div>
            
            <div class="control-group">
                <div class="header-section">
                    <div class="control-label">W' Balance Parameters</div>
                    <div class="tooltip info-icon">ⓘ
                        <span class="tooltiptext">Parameters for the W' balance model calculation.</span>
                    </div>
                </div>
                
                
                <div class="slider-container">
                    <div class="slider-label">
                        <label for="critical_power">Critical Power (CP) (W):</label>
                        <span id="critical_power-value" class="slider-value">365</span>
                    </div>
                    <input type="range" id="critical_power" class="range-slider" min="100" max="500" value="365" step="1">
                </div>
                
                <div class="slider-container">
                    <div class="slider-label">
                        <label for="w_prime">W' (kJ):</label>
                        <span id="w_prime-value" class="slider-value">25.0</span>
                    </div>
                    <input type="range" id="w_prime" class="range-slider" min="5" max="40" value="20" step="0.5">
                </div>

                <div class="slider-container">
                    <div class="label-info-value-line" style="display: flex; align-items: center;">
                        <div class="slider-label" style="margin-right: 5px;">
                            <label for="pmax">P<sub>max</sub> (W):</label>
                        </div>
                        <div class="tooltip info-icon" style="margin-right: 5px;">ⓘ
                            <span class="tooltiptext">Maximum instantaneous power an athlete can produce, representing the third parameter in the 3-parameter critical power model. This represents the capacity of the alactic (PCr/immediate) energy system.</span>
                        </div>
                        <span id="pmax-value" class="slider-value">1400</span>
                    </div>
                    <input type="range" id="pmax" class="range-slider" min="400" max="2000" value="1400" step="20">
                </div>
                
                <div class="checkbox-container">
                    <label class="fancy-checkbox">
                        <input type="checkbox" id="use_mlss_as_cp" name="use_mlss_as_cp" checked="checked">
                        <span class="checkmark"></span>
                        Use MLSS from Tab 1 as CP
                        <div class="tooltip info-icon" style="margin-left: 5px;">ⓘ
                            <span class="tooltiptext">When checked, Critical Power will automatically update to match the MLSS value from Tab 1.</span>
                        </div>
                    </label>
                </div>
                
                <div class="slider-container">
                    <div class="slider-label">
                        <label for="w_prime_balance_min">W' Balance Minimum (kJ):</label>
                        <span id="w_prime_balance_min-value" class="slider-value">-10.0</span>
                    </div>
                    <input type="range" id="w_prime_balance_min" class="range-slider" min="-20" max="10" value="0" step="0.5">
                </div>
                
                <div class="checkbox-container">
                    <label class="fancy-checkbox">
                        <input type="checkbox" id="use_w_prime_balance_abort" name="use_w_prime_balance_abort" checked="checked">
                        <span class="checkmark"></span>
                        Abort simulation when W' Balance falls below slider minimum
                        <div class="tooltip info-icon" style="margin-left: 5px;">ⓘ
                            <span class="tooltiptext">When checked, the simulation will terminate if W' Balance falls below the specified minimum.</span>
                        </div>
                    </label>
                </div>

                W' Balance model (Kontro et al. 2014):
                <div class="model-info">
                    <p>W'<sub>BAL</sub>(t) = W' - ∫<sub>0</sub><sup>t</sup>(W'<sub>EXP</sub> · e<sup>-(t-u)/τ<sub>W'</sub></sup>)du</p>
                    <p>Where τ<sub>W'</sub> = 546·e<sup>(-0.01·DCP)</sup> + 316</p>
                </div>

                MAP & Strain Score (SS) model :
                <div class="tooltip info-icon" style="margin-left: 5px;">ⓘ
                    <span class="tooltiptext">Maximum instantaneous power an athlete can produce, representing the third parameter in the 3-parameter critical power model. Based on Kontro et al. (2025), this is used to calculate MPA (Maximum Power Available) and the Strain Score (SS), which are novel metrics for fatigue quantification. P<sub>max</sub> represents the capacity of the alactic (PCr/immediate) energy system.</span>
                </div>
                <div class="model-info">
                    <p>SS = Σ(SR) · (P<sub>max</sub>/CP²) · (100/3600)</p>
                    <p>SR = k<sub>strain</sub> · P</p>
                    <p></p>k<sub>strain</sub> = (P<sub>max</sub> - MPA + CP)/(P<sub>max</sub> - P + CP)</p>
                    <p>MPA = P<sub>max</sub> - (P<sub>max</sub> - CP) · (W'<sub>EXP</sub>/W')²</p>
                </div>
            </div>
            
            <div class="control-group">
                  <div class="header-section">
                      <div class="control-label">PCr and O<sub>2</sub> Deficit Model</div>
                      <div class="tooltip info-icon">ⓘ
                          <span class="tooltiptext">Simulation of PCr dynamics and O<sub>2</sub> deficit based on mismatch between O<sub>2</sub> demand and actual O<sub>2</sub> uptake.</span>
                      </div>
                  </div>
                  
                  <div id="pcr-model-controls">
                  <div class="slider-container">
                      <div class="slider-label" style="display: flex; justify-content: space-between; align-items: center;">
                          <div>
                              <label for="pcr_init">Resting PCr (mmol·kg<sup>-1</sup>):</label>
                              <span id="pcr_init-value" style="margin-left: 23px;" class="slider-value">25.0</span>
                          </div>
                          <div class="tooltip info-icon">ⓘ
                              <span class="tooltiptext">Initial phosphocreatine (PCr) concentration in active muscle tissue. Typical values range from 15-38 mmol·kg<sup>-1</sup> of muscle wet weight.</span>
                          </div>
                      </div>
                      <input type="range" id="pcr_init" class="range-slider" min="15" max="38" value="25" step="0.1">
                  </div>
              
                  <div class="slider-container">
                      <div class="slider-label" style="display: flex; justify-content: space-between; align-items: center;">
                          <div>
                              <label for="p_o_ratio">P/O<sub>2</sub> (mol ATP · mol O<sub>2</sub><sup>-1</sup>):</label>
                              <span id="p_o_ratio-value" style="margin-left: 10px;" class="slider-value">4.80</span>
                          </div>
                          <div class="tooltip info-icon">ⓘ
                              <span class="tooltiptext">P/O<sub>2</sub> Ratio represents the amount of ATP molecules generated per oxygen molecule consumed. Value depends on substrate mixture (4.61 for purely fat, 5.0 for purely carbohydrate metabolism).</span>
                          </div>
                      </div>
                      <input type="range" id="p_o_ratio" class="range-slider" min="4.61" max="5.0" value="4.80" step="0.01">
                  </div>
                  
                  <div class="slider-container">
                      <div class="slider-label" style="display: flex; justify-content: space-between; align-items: center;">
                          <div>
                              <label for="active_muscle_mass">Active Muscle Mass (kg):</label>
                              <span id="active_muscle_mass-value" style="margin-left: 19px;" class="slider-value">25.0</span>
                          </div>
                          <div class="tooltip info-icon">ⓘ
                              <span class="tooltiptext">
                                  <strong>Research-based recommendations:</strong><br>
                                  • For cyclists, active muscle mass depends on gender, body weight, and position:<br>
                                  <br>
                                  <u>Women</u>:<br>
                                  - Seated cycling: ~22% of body weight (0.34 × 0.65)<br>
                                  - Standing cycling: ~25.5% of body weight (0.34 × 0.75)<br>
                                  <br>
                                  <u>Men</u>:<br>
                                  - Seated cycling: ~27% of body weight (0.42 × 0.65)<br>
                                  - Standing cycling: ~31.5% of body weight (0.42 × 0.75)<br>
                                  <br>
                                  Based on Janssen et al. (2000) MRI data and exercise physiology research on cycling biomechanics.
                              </span>
                          </div>
                      </div>
                      <input type="range" id="active_muscle_mass" class="range-slider" min="5" max="40" value="25" step="0.5">
                  </div>

                  <div class="parameter-row" style="margin-top: 10px;">
                    <div class="parameter-label">O<sub>2</sub>-Lactate Equiv. (β):</div>
                    <div class="tooltip info-icon" style="margin-left: 5px;">ⓘ
                        <span class="tooltiptext">Oxygen equivalent of lactate accumulation in blood (β). Represents the amount of O₂ (ml/kg) required aerobically to produce the energy equivalent to accumulating 1 mM of lactate in the blood. Value ≈ 3.0 ml O₂·kg⁻¹·mM⁻¹. Used here to estimate the O₂ deficit covered by net lactate production. (di Prampero, P. E. (1981). Energetics of muscular exercise. *Rev Physiol Biochem Pharmacol*, 89, 143-222. See Sect. 6.4).</span>
                    </div>
                    <span class="slider-value">≈ 3.0 ml·kg⁻¹·mM⁻¹</span>
                  </div>
                  
                  <div class="checkbox-container">
                      <label class="fancy-checkbox">
                          <input type="checkbox" id="show_vo2_demand" name="show_vo2_demand">
                          <span class="checkmark"></span>
                          Show V̇O<sub>2</sub> Demand Curve
                          <div class="tooltip info-icon" style="margin-left: 5px;">ⓘ
                              <span class="tooltiptext">Shows the actual V̇O<sub>2</sub> demand for each power output as a dotted line, with the area between actual V̇O<sub>2</sub> and demand filled to visualize O<sub>2</sub> deficit.</span>
                          </div>
                      </label>
                  </div>
                  
                  <div class="eta-infobox">
                      <p>The PCr model calculates phosphocreatine dynamics based on O<sub>2</sub> deficit/surplus:</p>
                      <p class="formula">PCr<sub>Store</sub>(t) = PCr<sub>Initial</sub> - ∫<sub>0</sub><sup>t</sup>(O<sub>2</sub>Deficit × P/O<sub>2</sub> Ratio)</p>
                      <p>Accumulated O<sub>2</sub> deficit represents the mismatch between O<sub>2</sub> demand and uptake.</p>
                   </div>
                </div>
            </div>
            
            <div class="control-group">
              <div class="header-section">
                  <div class="control-label">Model Parameters</div>
                  <div class="tooltip info-icon">ⓘ
                      <span class="tooltiptext">Parameters for the metabolic model of the simulation.</span>
                  </div>
              </div>
              
              <div class="checkbox-container">
                  <label class="fancy-checkbox">
                      <input type="checkbox" id="use_tab1_params" name="use_tab1_params" checked="checked">
                      <span class="checkmark"></span>
                      Use model parameters from Tab 1
                  </label>
              </div>
              
              <!-- Individual parameters if not imported -->
              <div id="individual-params" style="display:block;">
                  <div class="checkbox-container">
                      <label class="fancy-checkbox">
                          <input type="checkbox" id="curvilinear_step" name="curvilinear_step">
                          <span class="checkmark"></span>
                          Curvilinear CE relationship
                          <div class="tooltip info-icon" style="margin-left: 5px;">ⓘ
                              <span class="tooltiptext">Based on the curvilinear relationship between power output and energy consumption.</span>
                          </div>
                      </label>
                  </div>
                  
                  <div id="linear-ce-control-step" class="slider-container">
                      <div class="slider-label">
                          <label for="CEVO2_step">CE (ml·min<sup>-1</sup>·W<sup>-1</sup>):</label>
                          <span id="CEVO2_step-value" class="slider-value">10.9</span>
                      </div>
                      <input type="range" id="CEVO2_step" class="range-slider" min="8" max="15" value="11" step="0.1">
                  </div>
                  
                  <div id="curvilinear-ce-control-step" class="slider-container" style="display:none;">
                      <div class="slider-label">
                          <label for="CE_range_start_step">CE<sub>Start</sub> (ml·min<sup>-1</sup>·W<sup>-1</sup>):</label>
                          <span id="CE_range_start_step-value" class="slider-value">10.9</span>
                      </div>
                      <input type="range" id="CE_range_start_step" class="range-slider" min="8" max="15" value="11" step="0.1">
                      
                      <div class="slider-label">
                          <label for="CE_range_end_step">CE<sub>Target</sub> (ml·min<sup>-1</sup>·W<sup>-1</sup>):</label>
                          <span id="CE_range_end_step-value" class="slider-value">12.0</span>
                      </div>
                      <input type="range" id="CE_range_end_step" class="range-slider" min="8" max="15" value="12" step="0.1">
                  </div>
                  
                  <div class="slider-container">
                      <div class="slider-label">
                          <label for="VO2max_step">V̇O<sub>2,max</sub> (ml·min<sup>-1</sup>):</label>
                          <span id="VO2max_step-value" class="slider-value">6000</span>
                      </div>
                      <input type="range" id="VO2max_step" class="range-slider" min="2000" max="7500" value="6000" step="10">
                  </div>
                  
                  <div class="slider-container">
                      <div class="slider-label">
                          <label for="VO2Base_step">V̇O<sub>2,Base</sub> (ml·min<sup>-1</sup>):</label>
                          <span id="VO2Base_step-value" class="slider-value">394</span>
                      </div>
                      <input type="range" id="VO2Base_step" class="range-slider" min="200" max="800" value="394" step="1">
                  </div>
                  
                  <div class="slider-container">
                      <div class="slider-label">
                          <label for="vLamax_step">vLa<sub>max</sub> (mmol·l<sup>-1</sup>·s<sup>-1</sup>):</label>
                          <span id="vLamax_step-value" class="slider-value">0.96</span>
                      </div>
                      <input type="range" id="vLamax_step" class="range-slider" min="0.20" max="1.50" value="0.96" step="0.01">
                  </div>
                  
                  <div class="slider-container">
                      <div class="slider-label">
                          <label for="body_mass_step">Body Mass (kg):</label>
                          <span id="body_mass_step-value" class="slider-value">92.0</span>
                      </div>
                      <input type="range" id="body_mass_step" class="range-slider" min="40" max="120" value="92" step="0.1">
                  </div>
              </div>
              </div>
        </div>
    </div>
    
    <div class="main-content">
        <div id="leistungsdiagramm-tab" class="tab-content active">
            <div id="plot-container"></div>
            <div id="substrate-plot-container"></div>
            <div id="values-container"></div>
        </div>
        
        <div id="belastungssimulation-tab" class="tab-content">
            <div id="steptest-plot-container"></div>
            <div id="exercise-summary" class="values-container exercise-summary">
                <h3>Exercise Summary Statistics</h3>
                <div class="summary-content">
                    <div class="summary-row"><span class="summary-label">Average Power:</span> <span id="avg-power" class="summary-value">--</span></div>
                    <div class="summary-row"><span class="summary-label">Normalized Power:</span> <span id="norm-power" class="summary-value">--</span></div>
                    <div class="summary-row"><span class="summary-label">Total Energy:</span> <span id="total-energy" class="summary-value">--</span></div>
                    <div class="summary-row"><span class="summary-label">Total Work:</span> <span id="total-work" class="summary-value" style="color: darkgrey;">--</span></div>
                    <div class="summary-row"><span class="summary-label">Work > CP:</span> <span id="work-above-cp" class="summary-value" style="color: #42BA97;">--</span></div>
                    <div class="summary-row"><span class="summary-label">W' Balance Drop:</span> <span id="wprime-drop" class="summary-value" style="color: #42BA97;">--</span></div>
                    <div class="summary-row"><span class="summary-label">Total Carbohydrate Utilization:</span> <span id="cho-utilization" class="summary-value" style="color: #D81B60;">--</span></div>
                    <div class="summary-row"><span class="summary-label">Total Fat Utilization:</span> <span id="fat-utilization" class="summary-value" style="color: #009688;">--</span></div>
                    <div class="summary-row"><span class="summary-label">Strain Score (SS):</span> <span id="total-ss" class="summary-value" style="color: #F06292;">--</span></div>
                    <div class="summary-row"><span class="summary-label">SS<sub>CP</sub>:</span> <span id="ss-cp" class="summary-value" style="color: #42BA97;">--</span></div>
                    <div class="summary-row"><span class="summary-label">SS<sub>W'</sub>:</span> <span id="ss-wprime" class="summary-value" style="color: #EF5350;">--</span></div>
                    <div class="summary-row"><span class="summary-label">SS<sub>Pmax</sub>:</span> <span id="ss-pmax" class="summary-value" style="color: #607D8B;">--</span></div>
                </div>
            </div>
        </div>

    
</div>

<div id="notification" class="notification"></div>
</body>
</html>

<script>
    // App state management
    const appState = {
        // Tab 1 Parameters
        traceVisibility: {}, 
        CEVO2: 10.9,
        CE_range: [11.0, 12.0],
        VO2max: 6450,           
        VO2max_kg: 70.80,       
        VO2Base: 394,
        vLamax: 0.96,           
        body_mass: 92.0,        
        gender: 'Male',
        age: 29,                
        height: 193,
        curvilinear: false,
        weight_based: false,
        lock_y_axis: true,
        lock_x_axis: true,
        calculated_vo2base: null,
        w_prime_balance_min: -10.0,
        use_w_prime_balance_abort: true,
        use_lactate_abort: false, 
        // View window state
        view_time_start: 0,
        view_time_end: 3600,
        customize_time_window: false,
        customize_y_axis: false,
        view_power_max: 1420,
        view_vo2_max: 6500,
        view_lactate_min: 0,
        view_lactate_max: 25,
        vLass_on_tau: 5,  // Default ON time constant for vLass
        vLass_off_tau: 2, // Default OFF time constant for vLass
        mlss_value: null, 
        // Substrate utilization parameters 
        show_substrate: false,
        energy_unit: "g/h",
        rest_kh_percentage: 20,
        show_kh_adjust: false,
        swap_axes: false, // Still in state but not shown in UI
        // Cadence Dependency Tab 1
        cadence_dependent: false,
        cadence: 80,
        vo2max_dependent: false,
        vlamax_dependent: false,
        // Tab 2 Parameters
        step_watt: 20,
        step_duration: 30,
        max_power_step: 560, 
        // V̇O₂ Kinetics Model
        vo2_start: 400, // Initial default, will be updated
        vo2_at_fatmax: null, // To store the calculated default
        vo2_up_time_constant: 30,
        vo2_down_time_constant: 35,
        dynamic_tau_off: false,
        vo2_delay: 2,       // Default VO2 delay in seconds
        vlass_delay: 2,      // Default vLaSS delay in seconds
        la_max: 20,
        la_base: 0.8,
        smooth_power: false,
        has_header: true,
        separator: ';',
        gap_handling: 'last', // Default: last values for intervals
        use_tab1_params: true,
        CEVO2_step: 10.9,
        curvilinear_step: false,
        CE_range_step: [11.0, 12.0],
        VO2max_step: 6450,      
        VO2Base_step: 394,
        vLamax_step: 0.96,      
        body_mass_step:92.0,   
        critical_power: 365,
        w_prime: 25.0,
        pmax: 1420, // Maximum power for 3-parameter CP model
        use_mlss_as_cp: true,
        power_scale: 100, // Standardwert 100%
        pcr_init: 25.0,
        p_o_ratio: 4.80,
        active_muscle_mass: 25.0,
        show_vo2_demand: false,
        
        // New auto-calculate glycogen values
        auto_glycogen: false,
        
        // Glycogen storage parameters
        glycogen_init: 350,
        glycogen_max: 350,
        carb_intake_rate: 0,
        
        // Cadence Dependency Tab 2
        cadence_dependent_step: false,
        cadence_step: 80,
        vo2max_dependent_step: false,
        vlamax_dependent_step: false,
        use_file_cadence: false,
        
        // Interval Data
        interval_data: null,
        power_data: null,

        // Speichert den Sichtbarkeitsstatus für jeden Trace
        traceVisibility: {}, 

        // Cache for MLSS
        mlss_value: null
        };
        
        // DOM elements for Tab 1
        const elements = {
            // Tab Navigation
            tabs: document.querySelectorAll('.tab'),
            tabContents: document.querySelectorAll('.tab-content'),
            tabContentLeistungsdiagramm: document.getElementById('leistungsdiagramm-content'),
            tabContentBelastungssimulation: document.getElementById('belastungssimulation-content'),
            leistungsdiagrammTab: document.getElementById('leistungsdiagramm-tab'),
            belastungssimulationTab: document.getElementById('belastungssimulation-tab'),
            
            // Tab 1 Elements
            CEVO2: document.getElementById('CEVO2'),
            CEVO2Value: document.getElementById('CEVO2-value'),
            CE_range_start: document.getElementById('CE_range_start'),
            CE_range_startValue: document.getElementById('CE_range_start-value'),
            CE_range_end: document.getElementById('CE_range_end'),
            CE_range_endValue: document.getElementById('CE_range_end-value'),
            VO2max: document.getElementById('VO2max'),
            VO2maxValue: document.getElementById('VO2max-value'),
            VO2max_kg: document.getElementById('VO2max_kg'),
            VO2max_kgValue: document.getElementById('VO2max_kg-value'),
            VO2Base: document.getElementById('VO2Base'),
            VO2BaseValue: document.getElementById('VO2Base-value'),
            vLamax: document.getElementById('vLamax'),
            vLamaxValue: document.getElementById('vLamax-value'),
            body_mass: document.getElementById('body_mass'),
            body_massValue: document.getElementById('body_mass-value'),
            age: document.getElementById('age'),
            ageValue: document.getElementById('age-value'),
            height: document.getElementById('height'),
            heightValue: document.getElementById('height-value'),
            male: document.getElementById('male'),
            female: document.getElementById('female'),
            curvilinear: document.getElementById('curvilinear'),
            weight_based: document.getElementById('weight_based'),
            lock_y_axis: document.getElementById('lock_y_axis'),
            lock_x_axis: document.getElementById('lock_x_axis'),
            calculate_vo2base: document.getElementById('calculate_vo2base'),
            linearCeControl: document.getElementById('linear-ce-control'),
            curvilinearCeControl: document.getElementById('curvilinear-ce-control'),
            plotContainer: document.getElementById('plot-container'),
            valuesContainer: document.getElementById('values-container'),
            
            // Substrate Utilization Elements
            show_substrate: document.getElementById('show_substrate'),
            energy_unit: document.getElementById('energy_unit'),
            show_kh_adjust: document.getElementById('show_kh_adjust'),
            rest_kh_percentage: document.getElementById('rest_kh_percentage'),
            rest_kh_percentageValue: document.getElementById('rest_kh_percentage-value'),
            kh_adjust_control: document.getElementById('kh-adjust-control'),
            substrate_plot_container: document.getElementById('substrate-plot-container'),
            substrate_info: document.getElementById('substrate-info'),
            substrate_controls: document.getElementById('substrate-controls'),
            swap_axes: null, // Removed from UI but kept in state
            
            // Cadence Dependency Tab 1
            cadence_dependent: document.getElementById('cadence_dependent'),
            cadence: document.getElementById('cadence'),
            cadenceValue: document.getElementById('cadence-value'),
            cadenceControls: document.getElementById('cadence-controls'),
            vo2max_dependent: document.getElementById('vo2max_dependent'),
            vlamax_dependent: document.getElementById('vlamax_dependent'),
            
            // Tab 2 Elements
            step_watt: document.getElementById('step_watt'),
            step_wattValue: document.getElementById('step_watt-value'),
            step_duration: document.getElementById('step_duration'),
            step_durationValue: document.getElementById('step_duration-value'),
            max_power_step: document.getElementById('max_power_step'),
            max_power_stepValue: document.getElementById('max_power_step-value'),
            vo2_up_time_constant: document.getElementById('vo2_up_time_constant'),
            vo2_up_time_constantValue: document.getElementById('vo2_up_time_constant-value'),
            vo2_down_time_constant: document.getElementById('vo2_down_time_constant'),
            vo2_down_time_constantValue: document.getElementById('vo2_down_time_constant-value'),
            dynamic_tau_off: document.getElementById('dynamic_tau_off'),
            // Kinetics Model Toggle
            monoexponentialOnControl: document.getElementById('monoexponential-on-control'),
            monoexponentialOffControl: document.getElementById('monoexponential-off-control'),
            vo2_start: document.getElementById('vo2_start'),
            vo2_startValue: document.getElementById('vo2_start-value'),
            la_max: document.getElementById('la_max'),
            la_maxValue: document.getElementById('la_max-value'),
            la_base: document.getElementById('la_base'),
            la_baseValue: document.getElementById('la_base-value'),
            critical_power: document.getElementById('critical_power'),
            critical_powerValue: document.getElementById('critical_power-value'),
            w_prime: document.getElementById('w_prime'),
            w_primeValue: document.getElementById('w_prime-value'),
            w_prime_balance_min: document.getElementById('w_prime_balance_min'),
            w_prime_balance_minValue: document.getElementById('w_prime_balance_min-value'),
            pmax: document.getElementById('pmax'),
            pmaxValue: document.getElementById('pmax-value'),       
            use_w_prime_balance_abort: document.getElementById('use_w_prime_balance_abort'),
            use_lactate_abort: document.getElementById('use_lactate_abort'),
            use_mlss_as_cp: document.getElementById('use_mlss_as_cp'),
            load_interval_example: document.getElementById('load_interval_example'),
            power_data: document.getElementById('power_data'),
            fileName: document.getElementById('file-name'),
            has_header: document.getElementById('has_header'),
            gap_handling_last: document.getElementById('gap_handling_last'),
            gap_handling_zero: document.getElementById('gap_handling_zero'),            
            separator_semicolon: document.getElementById('separator_semicolon'),
            separator_comma: document.getElementById('separator_comma'),
            separator_tab: document.getElementById('separator_tab'),
            smooth_power: document.getElementById('smooth_power'),
            use_tab1_params: document.getElementById('use_tab1_params'),
            individual_params: document.getElementById('individual-params'),
            CEVO2_step: document.getElementById('CEVO2_step'),
            CEVO2_stepValue: document.getElementById('CEVO2_step-value'),
            curvilinear_step: document.getElementById('curvilinear_step'),
            linearCeControlStep: document.getElementById('linear-ce-control-step'),
            curvilinearCeControlStep: document.getElementById('curvilinear-ce-control-step'),
            CE_range_start_step: document.getElementById('CE_range_start_step'),
            CE_range_start_stepValue: document.getElementById('CE_range_start_step-value'),
            CE_range_end_step: document.getElementById('CE_range_end_step'),
            CE_range_end_stepValue: document.getElementById('CE_range_end_step-value'),
            VO2max_step: document.getElementById('VO2max_step'),
            VO2max_stepValue: document.getElementById('VO2max_step-value'),
            VO2Base_step: document.getElementById('VO2Base_step'),
            VO2Base_stepValue: document.getElementById('VO2Base_step-value'),
            vLamax_step: document.getElementById('vLamax_step'),
            vLamax_stepValue: document.getElementById('vLamax_step-value'),
            vLass_on_tau: document.getElementById('vLass_on_tau'),
            vLass_on_tauValue: document.getElementById('vLass_on_tau-value'),
            vLass_off_tau: document.getElementById('vLass_off_tau'),
            vLass_off_tauValue: document.getElementById('vLass_off_tau-value'),
            vo2_delay: document.getElementById('vo2_delay'),
            vo2_delayValue: document.getElementById('vo2_delay-value'),
            vlass_delay: document.getElementById('vlass_delay'),
            vlass_delayValue: document.getElementById('vlass_delay-value'),
            body_mass_step: document.getElementById('body_mass_step'),
            body_mass_stepValue: document.getElementById('body_mass_step-value'),
            steptestPlotContainer: document.getElementById('steptest-plot-container'),
            power_scale: document.getElementById('power_scale'),
            power_scaleValue: document.getElementById('power_scale-value'),
            
            // New auto-calculate glycogen element
            auto_glycogen: document.getElementById('auto_glycogen'),
            
            // Glycogen Storage Elements
            glycogen_init: document.getElementById('glycogen_init'),
            glycogen_initValue: document.getElementById('glycogen_init-value'),
            glycogen_max: document.getElementById('glycogen_max'),
            glycogen_maxValue: document.getElementById('glycogen_max-value'),
            carb_intake_rate: document.getElementById('carb_intake_rate'),
            carb_intake_rateValue: document.getElementById('carb_intake_rate-value'),
            
            // PCr Model Controls
            pcr_model_controls: document.getElementById('pcr-model-controls'),
            pcr_init: document.getElementById('pcr_init'),
            pcr_initValue: document.getElementById('pcr_init-value'),
            p_o_ratio: document.getElementById('p_o_ratio'),
            p_o_ratioValue: document.getElementById('p_o_ratio-value'),
            active_muscle_mass: document.getElementById('active_muscle_mass'),
            active_muscle_massValue: document.getElementById('active_muscle_mass-value'),
            show_vo2_demand: document.getElementById('show_vo2_demand'),
            
            // Cadence Dependency Tab 2
            cadence_dependent_step: document.getElementById('cadence_dependent_step'),
            cadence_step: document.getElementById('cadence_step'),
            cadence_stepValue: document.getElementById('cadence_step-value'),
            cadenceControlsStep: document.getElementById('cadence-controls-step'),
            vo2max_dependent_step: document.getElementById('vo2max_dependent_step'),
            vlamax_dependent_step: document.getElementById('vlamax_dependent_step'),
            use_file_cadence: document.getElementById('use_file_cadence'),
            
            // Exercise Summary Statistics
            avg_power: document.getElementById('avg-power'),
            norm_power: document.getElementById('norm-power'),
            wprime_drop: document.getElementById('wprime-drop'),
            total_work: document.getElementById('total-work'),
            work_above_cp: document.getElementById('work-above-cp'),
            total_energy: document.getElementById('total-energy'),
            cho_utilization: document.getElementById('cho-utilization'),
            fat_utilization: document.getElementById('fat-utilization'),
            total_ss: document.getElementById('total-ss'),
            ss_cp: document.getElementById('ss-cp'),
            ss_wprime: document.getElementById('ss-wprime'),
            ss_pmax: document.getElementById('ss-pmax'),

            // Notification
            notification: document.getElementById('notification'),

            // View window settings
            view_time_start: document.getElementById('view_time_start'),
            view_time_startValue: document.getElementById('view_time_start-value'),
            view_time_end: document.getElementById('view_time_end'),
            view_time_endValue: document.getElementById('view_time_end-value'),
            customize_time_window: document.getElementById('customize_time_window'),
            time_window_sliders: document.getElementById('time-window-sliders'),
            customize_y_axis: document.getElementById('customize_y_axis'),
            y_axis_sliders: document.getElementById('y-axis-sliders'),
            view_power_max: document.getElementById('view_power_max'),
            view_power_maxValue: document.getElementById('view_power_max-value'),
            view_vo2_max: document.getElementById('view_vo2_max'),
            view_vo2_maxValue: document.getElementById('view_vo2_max-value'),
            view_lactate_min: document.getElementById('view_lactate_min'),
            view_lactate_minValue: document.getElementById('view_lactate_min-value'),
            view_lactate_max: document.getElementById('view_lactate_max'),
            view_lactate_maxValue: document.getElementById('view_lactate_max-value')
            };
    
    // Tab switching logic
    elements.tabs.forEach(tab => {
        tab.addEventListener('click', () => {
            const tabName = tab.getAttribute('data-tab');
            
            // Deactivate all tabs and contents
            elements.tabs.forEach(t => t.classList.remove('active'));
            elements.tabContents.forEach(c => c.classList.remove('active'));
            document.getElementById('leistungsdiagramm-tab').classList.remove('active');
            document.getElementById('belastungssimulation-tab').classList.remove('active');
            
            // Activate selected tab and content
            tab.classList.add('active');
            document.getElementById(`${tabName}-content`).classList.add('active');
            document.getElementById(`${tabName}-tab`).classList.add('active');
            
            // If switching to belastungssimulation tab, update step test plot
            if (tabName === 'belastungssimulation') {
                // Check if CP should be set to MLSS
                if (appState.use_mlss_as_cp && appState.mlss_value) {
                    appState.critical_power = appState.mlss_value;
                    elements.critical_power.value = appState.critical_power;
                    elements.critical_powerValue.textContent = appState.critical_power;
                }
                updateStepTestPlot();
            } else {
                updatePlot();
                if (appState.show_substrate) {
                    updateSubstratePlot();
                }
            }
        });
    });
    
    // Function to calculate basal metabolic rate (BMR)
    function calculateBMR(gender, mass, height, age) {
        if (gender === 'Male') {
            return 66.5 + (13.75 * mass) + (5.003 * height) - (6.775 * age);
        } else {
            return 655.1 + (9.563 * mass) + (1.850 * height) - (4.676 * age);
        }
    }
    
    // Function to calculate VO2Base from BMR
    function calculateVO2Base(kcalDay, gender) {
        const ka = 19.946;
        const factor = gender === 'Male' ? 1.287 : 1.278;
        return (kcalDay / (24 * 60 * ka)) * 4.1868 * factor * 1000;
    }
    
    // Function to find optimal 'a' coefficient for curvilinear relationship
    function findOptimalA(startCE, targetCE, VO2max, VO2Base) {
        // Objective function to minimize: find 'a' that makes the slope at the VO2max intersection equal targetCE
        const objective = function(a) {
            const b = startCE;
            const c = VO2Base - VO2max;
            const discriminant = b*b - 4*a*c;
            if (discriminant < 0) return 1e6;
            const xIntersect = (-b + Math.sqrt(discriminant))/(2*a);
            if (xIntersect <= 0) return 1e6;
            const slopeAtIntersection = 2*a*xIntersect + startCE;
            return Math.pow(slopeAtIntersection - targetCE, 2);
        };
        
        // Simple optimization algorithm
        let aMin = 0.001;
        let aMax = 0.1;
        let iterations = 100;
        let step = (aMax - aMin) / iterations;
        let bestA = aMin;
        let bestError = objective(aMin);
        
        for (let i = 1; i <= iterations; i++) {
            const a = aMin + i * step;
            const error = objective(a);
            if (error < bestError) {
                bestError = error;
                bestA = a;
            }
        }
        
        return bestA;
    }
    
    // Function to smooth data with a rolling window
    function smoothData(data, windowSize) {
        if (!Array.isArray(data) || data.length < windowSize) {
            return data;
        }
        
        const result = [];
        
        for (let i = 0; i < data.length; i++) {
            let sum = 0;
            let count = 0;
            
            for (let j = Math.max(0, i - Math.floor(windowSize/2)); 
                 j <= Math.min(data.length - 1, i + Math.floor(windowSize/2)); 
                 j++) {
                sum += data[j];
                count++;
            }
            
            result.push(sum / count);
        }
        
        return result;
    }
    
    // Cadence-dependent functions from Dunst et al. paper
    function calculateCadenceDependentCEVO2(cadence) {
        // Formula from paper: CEVȮ2(PR) = 0.0004 * PR² - 0.094 * PR + 16.857
        return 0.0004 * Math.pow(cadence, 2) - 0.094 * cadence + 16.857;
    }
    
    function calculateCadenceDependentVO2Base(cadence) {
        // Formula from paper: VȮ2Base(PR) = 0.172 * PR² - 14.460 * PR + 548.039
        return 0.172 * Math.pow(cadence, 2) - 14.460 * cadence + 548.039;
    }
    
    function calculateCadenceDependentVLamax(cadence) {
        // Formula from paper: vLamax(PR) = -0.0002 * PR² + 0.00931 * PR
        return -0.0002 * Math.pow(cadence, 2) + 0.00931 * cadence;
    }
    
    function calculateCadenceDependentVO2max(cadence, baseVO2max) {
        // Implementation based on a quadratic approach with peak at 90 rpm
        const peakCadence = 90;     // Maximum at 90 rpm
        const zeroCadence = 210;    // At 210 rpm VO2 = 0
        const zeroRatio = 0.1;      // At 0 rpm VO2 is 10% of maximum
        
        if (cadence >= peakCadence) {
            // Right side of parabola: Maximum at peakCadence, zero at zeroCadence
            return Math.max(0, baseVO2max * (1 - Math.pow((cadence - peakCadence) / (zeroCadence - peakCadence), 2)));
        } else {
            // Left side: Maximum at peakCadence, 10% at 0 rpm
            // Using quadratic function: f(x) = ax² + bx + c
                    
            const a = baseVO2max * (zeroRatio - 1) / Math.pow(peakCadence, 2);
            const b = -2 * a * peakCadence;
            const c = baseVO2max + a * Math.pow(peakCadence, 2);
            
            return Math.max(0, a * Math.pow(cadence, 2) + b * cadence + c);
        }
    }
    
    // Function to adjust carbohydrate percentage with rest percentage
    function adjustCarbPercentageWithRestValue(carbPercentage, restKhPercentage) {
        if (!appState.show_kh_adjust) return carbPercentage;
        
        // Determine the initial value at x=0 (at rest)
        const initialCarb0 = carbPercentage[0];
        
        // Ensure the target value is not less than the current minimum
        const targetRestPercentage = Math.max(restKhPercentage, Math.min(...carbPercentage));
        
        // If the target value is already the current value, no change needed
        if (targetRestPercentage === initialCarb0) return carbPercentage;
        
        // Calculate the range (possible adjustment range)
        const rangeUp = 100 - initialCarb0;
        
        // Calculate the percentage adjustment upward
        const percentageAdjustment = (targetRestPercentage - initialCarb0) / rangeUp;
        
        // Calculate new values with percentage increase based on available range
        const adjustedValues = [];
        for (let i = 0; i < carbPercentage.length; i++) {
            const currentValue = carbPercentage[i];
            const availableRange = 100 - currentValue;
            const adjustment = percentageAdjustment * availableRange;
            adjustedValues.push(Math.min(100, currentValue + adjustment));
        }
        
        return adjustedValues;
    }
    
    // New function to calculate glycogen storage values based on active muscle mass
    function calculateGlycogenValues() {
        // Scientific constants for glycogen storage (in g/kg of muscle tissue)
        const glycogenPerKgMuscle = {
            normal: 15, // Normal levels in g/kg 
            loaded: 20,  // Carb-loaded levels in g/kg
            max: 25      // Maximum theoretical levels in g/kg
        };
        
        let muscleMass;
        
        // Use active_muscle_mass if PCr model is enabled, otherwise estimate from body mass
        if (appState.show_pcr_model) {
            muscleMass = appState.active_muscle_mass;
        } else {
            // Estimate active muscle mass based on gender and body mass
            // Research suggests ~27% for men and ~22% for women during seated cycling
            const musclePercentage = appState.gender === 'Male' ? 0.27 : 0.22;
            muscleMass = appState.body_mass * musclePercentage;
        }
        
        // Calculate values
        const initialGlycogen = Math.round(muscleMass * glycogenPerKgMuscle.normal);
        const maxGlycogen = Math.round(muscleMass * glycogenPerKgMuscle.loaded);
        
        return {
            initialGlycogen,
            maxGlycogen
        };
    }
    
    // Main function to calculate metabolic values for Tab 1
    function calculateValues() {
        // Apply cadence dependency if enabled
        let effectiveCEVO2 = appState.CEVO2;
        let effectiveVO2Base = appState.VO2Base;
        let effectiveVLamax = appState.vLamax;
        let effectiveVO2max = appState.VO2max;
        
        // Apply cadence dependency if enabled
        if (appState.cadence_dependent) {
            // CE and VO2Base dependency are always applied when cadence dependency is enabled
            effectiveCEVO2 = calculateCadenceDependentCEVO2(appState.cadence);
            effectiveVO2Base = calculateCadenceDependentVO2Base(appState.cadence);
            
        // Optional vLamax dependency
        if (appState.vlamax_dependent) {
            effectiveVLamax = calculateCadenceDependentVLamax(appState.cadence);
        }
            
            // Optional VO2max dependency
            if (appState.vo2max_dependent) {
                effectiveVO2max = calculateCadenceDependentVO2max(appState.cadence, appState.VO2max);
            }
        }
        
        // Metabolic model constants
        const CELaO2 = 0.02049 / appState.body_mass;
        const VolLa = 0.4;
        const ks1 = 0.0635;
        const ks2 = Math.pow(1.1, 3);
        
        // Calculate max power with linear CE value
        const maxPower = appState.curvilinear ? 
            ((effectiveVO2max - effectiveVO2Base) / appState.CE_range[0]) * 1.7 :
            ((effectiveVO2max - effectiveVO2Base) / effectiveCEVO2) * 1.7;
        
        // Create power array (extended by 70% to ensure dotted lines reach further)
        const P = Array.from({length: Math.ceil(maxPower) + 1}, (_, i) => i);
        
        let VO2ss_unlimited;
        let aOpt = null;
        
        if (appState.curvilinear) {
            // Calculate optimal coefficient for curvilinear relationship
            aOpt = findOptimalA(appState.CE_range[0], appState.CE_range[1], effectiveVO2max, effectiveVO2Base);
            
            // Curvilinear VO2ss calculation
            VO2ss_unlimited = P.map(p => aOpt * p * p + appState.CE_range[0] * p + effectiveVO2Base);
        } else {
            // Linear VO2ss calculation
            VO2ss_unlimited = P.map(p => effectiveCEVO2 * p + effectiveVO2Base);
        }
        
        // Find where VO2ss crosses VO2max
        const crossIndices = VO2ss_unlimited.findIndex(v => v >= effectiveVO2max);
        const crossPoint = crossIndices !== -1 ? crossIndices : VO2ss_unlimited.length;
        
        // Limit VO2ss to VO2max
        const VO2ss = VO2ss_unlimited.map(v => Math.min(v, effectiveVO2max));
        
        // Calculate vLass
        const vLass = VO2ss.map(vo2 => 
            effectiveVLamax / (1 + ks2 * Math.pow((effectiveVO2max - vo2)/(ks1 * vo2), 3/2))
        );
        
        // Calculate vLaox
        const vLaox = VO2ss_unlimited.map(vo2 => (CELaO2 * vo2) / (VolLa * 60));
        
        // Calculate pyruvate deficit
        const PD = vLaox.map((ox, i) => ox - vLass[i]);
        
        // Convert to minutes for display
        const vLass_min = vLass.map(v => v * 60);
        const vLaox_min = vLaox.map(v => v * 60);
        const PD_min = PD.map(p => p * 60);
        
        // Calculate lactate accumulation
        const La_accum = [];
        for (let i = 0; i < P.length; i++) {
            if (i === 0) {
                La_accum.push(Math.max(0, (vLass[i] - vLaox[i])));
            } else {
                La_accum.push(La_accum[i-1] + Math.max(0, (vLass[i] - vLaox[i])));
            }
        }
        
        // Set initial values to NA
        const startIdx = La_accum.findIndex(la => la > 0);
        if (startIdx !== -1) {
            for (let i = 0; i < startIdx; i++) {
                La_accum[i] = NaN;
            }
        }
        
        // Find important points
        const pdMaxPos = P[PD_min.indexOf(Math.max(...PD_min))];
        
        // Find closest to zero (MLSS)
        let minAbsPD = Infinity;
        let pdZeroPos = 0;
        for (let i = 0; i < PD_min.length; i++) {
            const absPD = Math.abs(PD_min[i]);
            if (absPD < minAbsPD) {
                minAbsPD = absPD;
                pdZeroPos = P[i];
            }
        }
        
        // Store previous MLSS value
        const oldMlssValue = appState.mlss_value;
        // Update MLSS value
        appState.mlss_value = pdZeroPos;
        
        // If MLSS value has changed and use_mlss_as_cp is active,
        // update CP value immediately whether in Tab 1 or Tab 2
        if (oldMlssValue !== pdZeroPos) {
            if (appState.use_mlss_as_cp) {
                // Update CP to match new MLSS value
                appState.critical_power = pdZeroPos;
                if (elements.critical_power) {
                    elements.critical_power.value = pdZeroPos;
                    elements.critical_powerValue.textContent = pdZeroPos;
                    elements.critical_power.disabled = true;
                }
            }
        }
        
        // Calculate substrate utilization if feature is enabled
        let carbPercentage = [];
        let fatPercentage = [];
        let carbGramPerHour = [];
        let fatGramPerHour = [];
        let carbKcalPerHour = [];
        let fatKcalPerHour = [];
        let carbKjPerHour = [];
        let fatKjPerHour = [];
        let totalEnergyKcalPerHour = [];
        let predictedRQ = []; // Added for RQ calculation
        
        if (appState.show_substrate) {
            // Constants for energy equivalents
            const kcalPerO2L = 4.86;
            const kcalPerGramCarb = 4.1;
            const kcalPerGramFat = 9.45;
            const kjPerKcal = 4.184;
            
            // Convert VO2 (ml/min) to L/min and then to kcal/h
            const VO2L_min = VO2ss.map(vo2 => vo2 / 1000);
            const totalKcalMin = VO2L_min.map(vo2 => vo2 * kcalPerO2L);
            totalEnergyKcalPerHour = totalKcalMin.map(kcal => kcal * 60);
            
            // Calculate carbohydrate oxidation based on lactate production vs oxidation
            carbPercentage = new Array(P.length);
            for (let i = 0; i < P.length; i++) {
                if (vLaox_min[i] <= 0) {
                    // If no lactate oxidation occurs
                    carbPercentage[i] = 0;
                } else if (PD_min[i] <= 0) {
                    // At or above the crossing point (MLSS): 100% CHO
                    carbPercentage[i] = 100;
                } else {
                    // Below the crossing point: percentage based on vLass to vLaox ratio
                    carbPercentage[i] = Math.min(100, (vLass_min[i] / vLaox_min[i]) * 100);
                }
            }
            
            // Apply adjustments if rest CHO percentage adjustment is enabled
            if (appState.show_kh_adjust) {
                carbPercentage = adjustCarbPercentageWithRestValue(carbPercentage, appState.rest_kh_percentage);
            }
            
            fatPercentage = carbPercentage.map(cp => 100 - cp);

            // Calculate predicted RQ based on substrate mix
            predictedRQ = carbPercentage.map(cp => calculateRQ(cp));
            
            // Calculate absolute substrate oxidation rates
            const carbKcalMin = totalKcalMin.map((kcal, i) => kcal * (carbPercentage[i] / 100));
            const fatKcalMin = totalKcalMin.map((kcal, i) => kcal * (fatPercentage[i] / 100));
            
            carbKcalPerHour = carbKcalMin.map(kcal => kcal * 60);
            fatKcalPerHour = fatKcalMin.map(kcal => kcal * 60);
            
            carbKjPerHour = carbKcalPerHour.map(kcal => kcal * kjPerKcal);
            fatKjPerHour = fatKcalPerHour.map(kcal => kcal * kjPerKcal);
            
            const carbGramMin = carbKcalMin.map(kcal => kcal / kcalPerGramCarb);
            const fatGramMin = fatKcalMin.map(kcal => kcal / kcalPerGramFat);
            
            carbGramPerHour = carbGramMin.map(g => g * 60);
            fatGramPerHour = fatGramMin.map(g => g * 60);
        }
        
        return {
            P,
            VO2ss,
            VO2ss_unlimited,
            crossPoint,
            vLass_min,
            vLaox_min,
            PD_min,
            La_accum,
            pd_max_pos: pdMaxPos,
            pd_zero_pos: pdZeroPos,
            max_power: maxPower,
            a_opt: aOpt,
            effective_values: {
                CEVO2: effectiveCEVO2,
                VO2Base: effectiveVO2Base,
                vLamax: effectiveVLamax,
                VO2max: effectiveVO2max
            },
            // Substrate data
            carb_percentage: carbPercentage,
            fat_percentage: fatPercentage,
            carb_g_h: carbGramPerHour,
            fat_g_h: fatGramPerHour,
            carb_kcal_h: carbKcalPerHour,
            fat_kcal_h: fatKcalPerHour,
            carb_kj_h: carbKjPerHour,
            fat_kj_h: fatKjPerHour,
            total_energy_kcal_h: totalEnergyKcalPerHour,
            predicted_rq: predictedRQ 
        };
    }
    
    // Function to update the substrate plot in Tab 1
    function updateSubstratePlot() {
        // Only render if substrate visualization is enabled
        if (!appState.show_substrate) {
            elements.substrate_plot_container.style.display = 'none';
            return;
        }
        
        // Make substrate plot container visible
    elements.substrate_plot_container.style.display = 'block';

    const vals = calculateValues();

    // Calculate and store VO2 at FATmax for default VO2 Start
        const fatmaxIdx = vals.PD_min.indexOf(Math.max(...vals.PD_min));
        if (fatmaxIdx >= 0 && fatmaxIdx < vals.VO2ss.length) {
            appState.vo2_at_fatmax = Math.round(vals.VO2ss[fatmaxIdx]);

            // Set initial VO2 Start value only if it hasn't been manually set yet
            // Or if the calculated fatmax VO2 has changed and the current start value doesn't match
            const base = appState.use_tab1_params ? appState.VO2Base : appState.VO2Base_step;
            const maxVal = appState.use_tab1_params ? appState.VO2max : appState.VO2max_step;
            const currentSliderValue = parseFloat(elements.vo2_start.value);
            const isInitialOrMismatch = isNaN(currentSliderValue) || currentSliderValue === 400 || appState.vo2_start !== appState.vo2_at_fatmax;

            if (isInitialOrMismatch) {
                // Set default start VO2, constrained
                appState.vo2_start = Math.min(maxVal, Math.max(base, appState.vo2_at_fatmax));
                elements.vo2_start.value = appState.vo2_start;
                elements.vo2_startValue.textContent = appState.vo2_start;
                // Update constraints
                elements.vo2_start.min = base;
                elements.vo2_start.max = maxVal;
            }
        }

    // Calculate relative values based on body weight
    const relPower = vals.P.map(p => p / appState.body_mass);
        
        // Choose display values based on weight-based setting
        const displayPower = appState.weight_based ? relPower : vals.P;
        const relPdMaxPos = vals.pd_max_pos / appState.body_mass;
        const relPdZeroPos = vals.pd_zero_pos / appState.body_mass;
        const displayPdMaxPos = appState.weight_based ? relPdMaxPos : vals.pd_max_pos;
        const displayPdZeroPos = appState.weight_based ? relPdZeroPos : vals.pd_zero_pos;
        
        // Create traces for the substrate plot
        const traces = [];
        
        // Percentage substrate plot
        traces.push({
            x: displayPower,
            y: vals.carb_percentage,
            name: "CHO-Utilization (%)",
            type: 'scatter',
            mode: 'lines',
            line: {color: '#D81B60', dash: 'dot', width: 2}
        });
        
        traces.push({
            x: displayPower,
            y: vals.fat_percentage,
            name: "Fat-Utilization (%)",
            type: 'scatter',
            mode: 'lines',
            line: {color: '#009688', dash: 'dot', width: 2}
        });
        
        // Vertical marker lines for FATmax and MLSS
        if (displayPdMaxPos >= Math.min(...displayPower) && displayPdMaxPos <= Math.max(...displayPower)) {
            traces.push({
                x: [displayPdMaxPos, displayPdMaxPos],
                y: [0, 100],
                name: "FAT<sub>max</sub>",
                type: 'scatter',
                mode: 'lines',
                line: {color: '#CCCCCC', dash: 'dot', width: 1},
                showlegend: false
            });
        }
        
        if (displayPdZeroPos >= Math.min(...displayPower) && displayPdZeroPos <= Math.max(...displayPower)) {
            traces.push({
                x: [displayPdZeroPos, displayPdZeroPos],
                y: [0, 100],
                name: "MLSS",
                type: 'scatter',
                mode: 'lines',
                line: {color: '#CCCCCC', dash: 'dot', width: 1},
                showlegend: false
            });
        }
        
        // Layout configuration
        const layout = {
            title: {
                text: "Substrate Utilization Percentages",
                font: {
                    size: 16,
                    color: 'var(--primary-color)'
                }
            },
            margin: {l: 60, r: 60, t: 60, b: 70},
            xaxis: {
                title: {
                    text: `Power (${appState.weight_based ? "W·kg<sup>-1</sup>" : "W"})`,
                    font: {
                        size: 12
                    }
                },
                range: [0, 600],
                showgrid: true,
                gridcolor: 'rgba(200,200,200,0.2)'
            },
            yaxis: {
                title: {
                    text: "Percentage of Energy Expenditure (%)",
                    font: {
                        size: 12
                    }
                },
                range: [0, 100],
                showgrid: true,
                gridcolor: 'rgba(200,200,200,0.2)'
            },
            showlegend: true,
            legend: {
                x: 0.60,
                y: 0.99,
                bgcolor: 'rgba(255, 255, 255, 0.0)'
            },
            paper_bgcolor: 'rgba(255,255,255,0)',
            plot_bgcolor: 'rgba(255,255,255,0.5)',
            hovermode: 'closest'
        };
        
        // Create the plot
        Plotly.newPlot('substrate-plot-container', traces, layout, {
            displayModeBar: true,
            responsive: true
        });
    }
    
    // Function to update the plot in Tab 1
    function updatePlot() {
        const vals = calculateValues();
        
        // Calculate relative values based on body weight
        const relVO2max = vals.effective_values.VO2max / appState.body_mass;
        const relPower = vals.P.map(p => p / appState.body_mass);
        const relVO2ss = vals.VO2ss.map(vo2 => vo2 / appState.body_mass);
        const relVO2ss_unlimited = vals.VO2ss_unlimited.map(vo2 => vo2 / appState.body_mass);
        const relPdMaxPos = vals.pd_max_pos / appState.body_mass;
        const relPdZeroPos = vals.pd_zero_pos / appState.body_mass;
        
        // Choose display values based on weight-based setting
        const displayPower = appState.weight_based ? relPower : vals.P;
        const displayVO2ss = appState.weight_based ? relVO2ss : vals.VO2ss;
        const displayVO2ss_unlimited = appState.weight_based ? relVO2ss_unlimited : vals.VO2ss_unlimited;
        const displayVO2max = appState.weight_based ? relVO2max : vals.effective_values.VO2max;
        const displayPdMaxPos = appState.weight_based ? relPdMaxPos : vals.pd_max_pos;
        const displayPdZeroPos = appState.weight_based ? relPdZeroPos : vals.pd_zero_pos;
        
        const y1Max = displayVO2max * 1.25;
        const xMax = Math.max(...displayPower);
        const xMid = xMax / 2;
        
        // Prepare substrate data if feature is enabled
        let displaySubstrateData = {
            cho: null,
            fat: null,
            unit: ""
        };
        
        if (appState.show_substrate) {
            // Select substrate data based on energy unit choice
            switch(appState.energy_unit) {
                case "g/h":
                    displaySubstrateData.cho = vals.carb_g_h;
                    displaySubstrateData.fat = vals.fat_g_h;
                    displaySubstrateData.unit = "g·h<sup>-1</sup>";
                    break;
                case "kcal/h":
                    displaySubstrateData.cho = vals.carb_kcal_h;
                    displaySubstrateData.fat = vals.fat_kcal_h;
                    displaySubstrateData.unit = "kcal·h<sup>-1</sup>";
                    break;
                case "kJ/h":
                    displaySubstrateData.cho = vals.carb_kj_h;
                    displaySubstrateData.fat = vals.fat_kj_h;
                    displaySubstrateData.unit = "kJ·h<sup>-1</sup>";
                    break;
            }
        }
        
        // Create traces for the plot
        const traces = [];
        
        // Handle different axes orientation based on swap_axes setting
        if (appState.swap_axes) {
            // Swapped axes: V̇O₂ on X-Axis, Power on Y-Axis
            
            // V̇O₂max vertical line
            traces.push({
                y: displayPower,
                x: Array(displayPower.length).fill(displayVO2max),
                name: "V̇O<sub>2,max</sub>",
                type: 'scatter',
                mode: 'lines',
                line: {color: '#CCCCCC', dash: 'dot', width: 2},
                showlegend: false
            });
            
            // FATmax horizontal line
            if (displayPdMaxPos >= Math.min(...displayPower) && displayPdMaxPos <= Math.max(...displayPower)) {
                traces.push({
                    y: [displayPdMaxPos, displayPdMaxPos],
                    x: [0, y1Max],
                    name: "FAT<sub>max</sub>",
                    type: 'scatter',
                    mode: 'lines',
                    line: {color: '#CCCCCC', dash: 'dot', width: 2},
                    showlegend: false
                });
            }
            
            // MLSS horizontal line
            if (displayPdZeroPos >= Math.min(...displayPower) && displayPdZeroPos <= Math.max(...displayPower)) {
                traces.push({
                    y: [displayPdZeroPos, displayPdZeroPos],
                    x: [0, y1Max],
                    name: "MLSS",
                    type: 'scatter',
                    mode: 'lines',
                    line: {color: '#CCCCCC', dash: 'dot', width: 2},
                    showlegend: false
                });
            }
            
            // V̇O₂ss Curve
            traces.push({
                y: displayPower,
                x: displayVO2ss,
                name: "V̇O<sub>2,SS</sub>",
                type: 'scatter',
                mode: 'lines',
                line: {color: '#2683C6', width: 3},
                showlegend: true
            });
            
            // Lactate rates and accumulation
            traces.push({
                x: displayPower,
                y: vals.vLass_min,
                name: "vLa<sub>SS</sub>",
                type: 'scatter',
                mode: 'lines',
                yaxis: 'y2',
                line: {color: '#EF5350', dash: 'dash', width: 2},
                showlegend: true
            });
            
            traces.push({
                x: displayPower,
                y: vals.vLaox_min,
                name: "vLa<sub>ox</sub>",
                type: 'scatter',
                mode: 'lines',
                yaxis: 'y2',
                line: {color: '#1CADE4', dash: 'dash', width: 2},
                showlegend: true
            });
            
            traces.push({
                x: displayPower,
                y: vals.PD_min,
                name: "PD",
                type: 'scatter',
                mode: 'lines',
                yaxis: 'y2',
                line: {color: "#9C85C0", width: 3},
                showlegend: true
            });
            
            traces.push({
                x: displayPower,
                y: vals.La_accum,
                name: "La<sub>Accumulation</sub>",
                type: 'scatter',
                mode: 'lines',
                yaxis: 'y2',
                line: {color: '#C8133B', width: 3},
                showlegend: true
            });
            
            if (appState.show_substrate) {
                // Find the index where VO2ss reaches VO2max (this is already calculated as vals.crossPoint)
                const vo2maxReachedIdx = vals.crossPoint;
                
                // CHO utilization (only up to where VO2ss reaches VO2max)
                traces.push({
                    y: displayPower.slice(0, vo2maxReachedIdx),
                    x: displaySubstrateData.cho.slice(0, vo2maxReachedIdx),
                    name: `CHO (${displaySubstrateData.unit})`,
                    type: 'scatter',
                    mode: 'lines',
                    xaxis: 'x2',
                    line: {color: '#D81B60', dash: 'dot', width: 2},
                    showlegend: true
                });
                
                // Fat utilization (only up to MLSS)
                const pdZeroIdx = displayPower.findIndex(p => p >= displayPdZeroPos);
                if (pdZeroIdx > 0) {
                    traces.push({
                        y: displayPower.slice(0, pdZeroIdx),
                        x: displaySubstrateData.fat.slice(0, pdZeroIdx),
                        name: `Fat (${displaySubstrateData.unit})`,
                        type: 'scatter',
                        mode: 'lines',
                        xaxis: 'x2',
                        line: {color: '#009688', dash: 'dot', width: 2},
                        showlegend: true
                    });
                }
            }
        } else {
            // Normal axes: Power on X-Axis, V̇O₂ on Y-Axis (default)
            
            // V̇O₂max horizontal line
            traces.push({
                x: displayPower,
                y: Array(displayPower.length).fill(displayVO2max),
                name: "V̇O<sub>2,max</sub>",
                type: 'scatter',
                mode: 'lines',
                line: {color: '#CCCCCC', dash: 'dot', width: 2},
                showlegend: false
            });
            
            // FATmax vertical line
            if (displayPdMaxPos >= Math.min(...displayPower) && displayPdMaxPos <= Math.max(...displayPower)) {
                traces.push({
                    x: [displayPdMaxPos, displayPdMaxPos],
                    y: [0, 20],
                    name: "FAT<sub>max</sub>",
                    type: 'scatter',
                    mode: 'lines',
                    line: {color: '#CCCCCC', dash: 'dot', width: 2},
                    showlegend: false,
                    yaxis: 'y2'
                });
            }
            
            // MLSS vertical line
            if (displayPdZeroPos >= Math.min(...displayPower) && displayPdZeroPos <= Math.max(...displayPower)) {
                traces.push({
                    x: [displayPdZeroPos, displayPdZeroPos],
                    y: [0, 20],
                    name: "MLSS",
                    type: 'scatter',
                    mode: 'lines',
                    line: {color: '#CCCCCC', dash: 'dot', width: 2},
                    showlegend: false,
                    yaxis: 'y2'
                });
            }
            
            // V̇O₂ss Curve
            if (vals.crossPoint > 1) {
                traces.push({
                    x: displayPower.slice(0, vals.crossPoint),
                    y: displayVO2ss_unlimited.slice(0, vals.crossPoint),
                    name: "V̇O<sub>2,SS</sub>",
                    type: 'scatter',
                    mode: 'lines',
                    line: {color: '#2683C6', width: 3},
                    showlegend: true
                });
                
                if (vals.crossPoint < displayPower.length) {
                    traces.push({
                        x: displayPower.slice(vals.crossPoint),
                        y: displayVO2ss_unlimited.slice(vals.crossPoint),
                        name: "V̇O<sub>2,SS,extrapolated</sub>",
                        type: 'scatter',
                        mode: 'lines',
                        line: {color: '#2683C6', dash: 'dash', width: 3},
                        showlegend: true
                    });
                }
            }
            
            // Lactate rates and accumulation
            traces.push({
                x: displayPower,
                y: vals.vLass_min,
                name: "vLa<sub>SS</sub>",
                type: 'scatter',
                mode: 'lines',
                yaxis: 'y2',
                line: {color: '#EF5350', dash: 'dash', width: 2},
                showlegend: true
            });
            
            traces.push({
                x: displayPower,
                y: vals.vLaox_min,
                name: "vLa<sub>ox</sub>",
                type: 'scatter',
                mode: 'lines',
                yaxis: 'y2',
                line: {color: '#1CADE4', dash: 'dash', width: 2},
                showlegend: true
            });
            
            traces.push({
                x: displayPower,
                y: vals.PD_min,
                name: "PD",
                type: 'scatter',
                mode: 'lines',
                yaxis: 'y2',
                line: {color: "#9C85C0", width: 3},
                showlegend: true
            });
            
            traces.push({
                x: displayPower,
                y: vals.La_accum,
                name: "La<sub>Accumulation</sub>",
                type: 'scatter',
                mode: 'lines',
                yaxis: 'y2',
                line: {color: '#C8133B', width: 3},
                showlegend: true
            });
            
            // Add substrate traces if enabled
            if (appState.show_substrate) {
                // Find the index where VO2ss reaches VO2max (this is already calculated as vals.crossPoint)
                const vo2maxReachedIdx = vals.crossPoint;
                
                // CHO utilization (only up to where VO2ss reaches VO2max)
                traces.push({
                    x: displayPower.slice(0, vo2maxReachedIdx),
                    y: displaySubstrateData.cho.slice(0, vo2maxReachedIdx),
                    name: `CHO (${displaySubstrateData.unit})`,
                    type: 'scatter',
                    mode: 'lines',
                    yaxis: 'y3',
                    line: {color: '#D81B60', dash: 'dot', width: 2},
                    showlegend: true
                });
                
                // Fat utilization (only up to MLSS)
                const pdZeroIdx = displayPower.findIndex(p => p >= displayPdZeroPos);
                if (pdZeroIdx > 0) {
                    traces.push({
                        x: displayPower.slice(0, pdZeroIdx),
                        y: displaySubstrateData.fat.slice(0, pdZeroIdx),
                        name: `Fat (${displaySubstrateData.unit})`,
                        type: 'scatter',
                        mode: 'lines',
                        yaxis: 'y3',
                        line: {color: '#009688', dash: 'dot', width: 2},
                        showlegend: true
                    });
                }
            }
        }
        
        // Annotations
        const annotations = [];
        
        // Fixed Y-Axis ranges for locked mode
        const fixedYAxisRange = appState.weight_based ? [0, 100] : [0, 7500];
        
        // Set axis ranges based on lock settings
        const xaxisRange = appState.lock_x_axis ? 
            (appState.weight_based ? [0, 600/appState.body_mass] : [0, 600]) : 
            [0, Math.max(...displayPower) * 1.05];
        const yaxisRange = appState.lock_y_axis ? fixedYAxisRange : [0, Math.max(...displayVO2ss_unlimited) * 1.1];
        
        // Prepare layout with proper axis configuration based on swap_axes setting
        let layout;
        
        if (appState.swap_axes) {
            // Layout for swapped axes
            layout = {
                title: {
                    text: "V̇O<sub>2,SS</sub>, vLa<sub>SS</sub>, vLa<sub>ox</sub>, PD and Lactate Accumulation",
                    font: {
                        size: 18,
                        color: '#2683C6'
                    }
                },
                margin: {l: 60, r: 60, t: 60, b: 80},
                xaxis: {
                    title: {
                        text: `V̇O<sub>2</sub>ss (${appState.weight_based ? "ml·min<sup>-1</sup>·kg<sup>-1</sup>" : "ml·min<sup>-1</sup>"})`,
                        font: { size: 14 }
                    },
                    range: yaxisRange,
                    showgrid: true,
                    gridcolor: 'rgba(200,200,200,0.2)'
                },
                yaxis: {
                    title: {
                        text: `Power (${appState.weight_based ? "W·kg<sup>-1</sup>" : "W"})`,
                        font: { size: 14 }
                    },
                    side: "left",
                    range: xaxisRange,
                    showgrid: true,
                    gridcolor: 'rgba(200,200,200,0.2)'
                },
                yaxis2: {
                    title: {
                        text: "Lactate Rates (mmol·l<sup>-1</sup>·min<sup>-1</sup>) & Accumulation (mmol·l<sup>-1</sup>)",
                        font: { size: 14 }
                    },
                    overlaying: "y",
                    side: "right",
                    range: [0, 14],
                    showgrid: false,
                    dtick: 2
                },
                showlegend: true,
                legend: {
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'top',
                    orientation: 'h',
                    bgcolor: 'rgba(255, 255, 255, 0)',
                    bordercolor: 'rgba(0,0,0,0)',
                    borderwidth: 0
                },
                annotations: annotations,
                paper_bgcolor: 'rgba(255,255,255,0)',
                plot_bgcolor: 'rgba(255,255,255,0.5)',
                hovermode: 'closest'
            };
            
            // Add substrate utilization axis if feature is enabled
            if (appState.show_substrate) {
                layout.xaxis2 = {
                    title: {
                        text: `Substrate Utilization (${displaySubstrateData.unit})`,
                        font: { size: 14 }
                    },
                    overlaying: "x",
                    side: "top",
                    showgrid: false,
                    range: [0, Math.max(...displaySubstrateData.cho) * 1.1]
                };
            }
            
            // Add annotations for FAT max and MLSS
            annotations.push(
                {
                    y: displayPdMaxPos,
                    x: y1Max * 0.9,
                    text: `FAT<sub>max</sub><br>${appState.weight_based ? displayPdMaxPos.toFixed(1) : Math.round(displayPdMaxPos)} ${appState.weight_based ? "W·kg<sup>-1</sup>" : "W"}`,
                    showarrow: false,
                    font: {color: '#666666'},
                    xanchor: "center"
                },
                {
                    y: displayPdZeroPos,
                    x: y1Max * 0.9,
                    text: `MLSS<br>${appState.weight_based ? displayPdZeroPos.toFixed(1) : Math.round(displayPdZeroPos)} ${appState.weight_based ? "W·kg<sup>-1</sup>" : "W"}`,
                    showarrow: false,
                    font: {color: '#666666'},
                    xanchor: "center"
                }
            );
                
            // Add V̇O₂max annotation
            annotations.push({
                y: xMid,
                x: displayVO2max + (y1Max - displayVO2max) * 0.1,
                text: `V̇O<sub>2,max</sub>: ${relVO2max.toFixed(1)} ml·min<sup>-1</sup>·kg<sup>-1</sup>`,
                showarrow: false,
                font: {color: '#666666'},
                yanchor: "center"
            });
                
        } else {
            // Layout for normal axes orientation
            layout = {
                title: {
                    text: "V̇O<sub>2,SS</sub>, vLa<sub>SS</sub>, vLa<sub>ox</sub>, PD and Lactate Accumulation",
                    font: {
                        size: 18,
                        color: '#2683C6'
                    }
                },
                margin: {l: 60, r: 60, t: 60, b: 80},
                xaxis: {
                    title: {
                        text: `Power (${appState.weight_based ? "W·kg<sup>-1</sup>" : "W"})`,
                        font: {
                            size: 14
                        }
                    },
                    range: xaxisRange,
                    showgrid: true,
                    gridcolor: 'rgba(200,200,200,0.2)'
                },
                yaxis: {
                    title: {
                        text: `V̇O<sub>2</sub>ss (${appState.weight_based ? "ml·min<sup>-1</sup>·kg<sup>-1</sup>" : "ml·min<sup>-1</sup>"})`,
                        font: {
                            size: 14
                        }
                    },
                    side: "left",
                    range: yaxisRange,
                    showgrid: true,
                    gridcolor: 'rgba(200,200,200,0.2)'
                },
                yaxis2: {
                    title: {
                        text: "Lactate Rates (mmol·l<sup>-1</sup>·min<sup>-1</sup>) & Accumulation (mmol·l<sup>-1</sup>)",
                        font: {
                            size: 14
                        }
                    },
                    overlaying: "y",
                    side: "right",
                    range: [0, 14],
                    showgrid: false,
                    dtick: 2
                },
                showlegend: true,
                legend: {
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'top',
                    orientation: 'h',
                    bgcolor: 'rgba(255, 255, 255, 0)',
                    bordercolor: 'rgba(0,0,0,0)',
                    borderwidth: 0
                },
                annotations: annotations,
                paper_bgcolor: 'rgba(255,255,255,0)',
                plot_bgcolor: 'rgba(255,255,255,0.5)',
                hovermode: 'closest'
            };
            
            // Add substrate utilization axis if feature is enabled
            if (appState.show_substrate) {
                // Calculate max value for substrate Y-Axis
                const substrateCHOMax = Math.max(...displaySubstrateData.cho);
                const substrateFatMax = Math.max(...displaySubstrateData.fat.filter(v => !isNaN(v)));
                const substrateMaxValue = Math.max(substrateCHOMax, substrateFatMax) * 1.1;
                
                layout.yaxis3 = {
                    title: {
                        text: `Substrate Utilization (${displaySubstrateData.unit})`,
                        font: {
                            size: 14
                        }
                    },
                    overlaying: "y",
                    side: "right",
                    anchor: "free",
                    position: 0.93,
                    range: [0, substrateMaxValue],
                    showgrid: false
                };
            }
            
            // Add annotations for V̇O₂max, FAT max and MLSS
            annotations.push(
                {
                    x: xMid * 0.70,
                    y: displayVO2max + (y1Max - displayVO2max) * 0.1,
                    text: `V̇O<sub>2,max</sub>: ${relVO2max.toFixed(1)} ml·min<sup>-1</sup>·kg<sup>-1</sup>`,
                    showarrow: false,
                    font: {color: '#666666'},
                    xanchor: "center"
                },
                {
                    x: displayPdMaxPos,
                    y: y1Max * 0.90,
                    text: `FAT<sub>max</sub><br>${appState.weight_based ? displayPdMaxPos.toFixed(1) : Math.round(displayPdMaxPos)} ${appState.weight_based ? "W·kg<sup>-1</sup>" : "W"}`,
                    showarrow: false,
                    font: {color: '#666666'},
                    xanchor: "center"
                },
                {
                    x: displayPdZeroPos,
                    y: y1Max * 0.90,
                    text: `MLSS<br>${appState.weight_based ? displayPdZeroPos.toFixed(1) : Math.round(displayPdZeroPos)} ${appState.weight_based ? "W·kg<sup>-1</sup>" : "W"}`,
                    showarrow: false,
                    font: {color: '#666666'},
                    xanchor: "center"
                }
            );
        }
        
        // Formula text
        let formulaText = '';
        if (appState.curvilinear) {
            if (appState.weight_based) {
                formulaText = `V̇O<sub>2,SS</sub> (P) = ${vals.a_opt.toFixed(4)} · P² + ${appState.CE_range[0].toFixed(1)} · P + ${(vals.effective_values.VO2Base/appState.body_mass).toFixed(1)}`;
            } else {
                formulaText = `V̇O<sub>2,SS</sub> (P) = ${vals.a_opt.toFixed(4)} · P² + ${appState.CE_range[0].toFixed(1)} · P + ${Math.round(vals.effective_values.VO2Base)}`;
            }
        } else {
            if (appState.weight_based) {
                formulaText = `V̇O<sub>2,SS</sub> (P) = ${vals.effective_values.CEVO2.toFixed(1)} · P + ${(vals.effective_values.VO2Base/appState.body_mass).toFixed(1)}`;
            } else {
                formulaText = `V̇O<sub>2,SS</sub> (P) = ${vals.effective_values.CEVO2.toFixed(1)} · P + ${Math.round(vals.effective_values.VO2Base)}`;
            }
        }
        
        // Add cadence info if cadence dependency is enabled
        if (appState.cadence_dependent) {
            formulaText += `<br>(at cadence: ${appState.cadence} rpm)`;
        }
        
        // Add formula annotation
        if (appState.swap_axes) {
            annotations.push({
                y: 0.15 * Math.max(...displayPower),
                x: 0.15 * displayVO2max,
                text: formulaText,
                showarrow: false,
                font: {
                    family: "Arial",
                    size: 12,
                    color: "#666666"
                },
                xanchor: "left",
                yanchor: "middle"
            });
        } else {
            annotations.push({
                x: 0.15 * Math.max(...displayPower),
                y: 0.15 * displayVO2max,
                text: formulaText,
                showarrow: false,
                font: {
                    family: "Arial",
                    size: 12,
                    color: "#666666"
                },
                xanchor: "left",
                yanchor: "middle"
            });
        }
        
        layout.annotations = annotations;
        
        // Create a new plot with consistent settings each time
        Plotly.newPlot('plot-container', traces, layout, {
            displayModeBar: true,
            responsive: true
        });
        
        // Update the values container with correct formatting
        updateValuesDisplay(vals);

        // Update efficiency values display in the UI
        const fatmaxIdx = vals.PD_min.indexOf(Math.max(...vals.PD_min));
        // Find index of MLSS (PD closest to zero)
        let minAbsPD = Infinity;
        let pdZeroIdx = 0;
        for (let i = 0; i < vals.PD_min.length; i++) {
            const absPD = Math.abs(vals.PD_min[i]);
            if (absPD < minAbsPD) {
                minAbsPD = absPD;
                pdZeroIdx = i;
            }
        }

        // Get RQ values at FATmax and MLSS
        const fatmaxRQ = vals.predicted_rq && vals.predicted_rq.length > fatmaxIdx ? 
            vals.predicted_rq[fatmaxIdx] : 0.85;
        const mlssRQ = vals.predicted_rq && vals.predicted_rq.length > pdZeroIdx ? 
            vals.predicted_rq[pdZeroIdx] : 0.95;

        // Calculate efficiency values at FATmax and MLSS
        const fatmaxEfficiency = calculateEfficiency(
            vals.P[fatmaxIdx], 
            vals.VO2ss[fatmaxIdx], 
            fatmaxRQ, 
            vals.effective_values.VO2Base
        );

        const mlssEfficiency = calculateEfficiency(
            vals.P[pdZeroIdx], 
            vals.VO2ss[pdZeroIdx], 
            mlssRQ, 
            vals.effective_values.VO2Base
        );

        // Also update the delta efficiency based on the effective CE value (could be cadence-dependent)
        if (appState.cadence_dependent) {
            const effectiveCE = vals.effective_values.CEVO2;
            const deltaEta = calculateDeltaEfficiency(effectiveCE);
            document.getElementById('delta-eta-value').textContent = 
                `${deltaEta.min.toFixed(1)}-${deltaEta.max.toFixed(1)}%`;
        }

        // Update UI elements
        if (document.getElementById('gross-eta-value')) {
            document.getElementById('gross-eta-value').innerHTML = 
                `${fatmaxEfficiency.gross.toFixed(1)}% | ${mlssEfficiency.gross.toFixed(1)}%`;
        }

        if (document.getElementById('net-eta-value')) {
            document.getElementById('net-eta-value').innerHTML = 
                `${fatmaxEfficiency.net.toFixed(1)}% | ${mlssEfficiency.net.toFixed(1)}%`;
        }

        // Update substrate plot if enabled
        if (appState.show_substrate) {
            updateSubstratePlot();
        }
    }

    // Function to update the values display in Tab 1
    function updateValuesDisplay(vals) {
        const pdMaxIdx = vals.PD_min.indexOf(Math.max(...vals.PD_min));
        
        // Find index of MLSS (PD closest to zero)
        let minAbsPD = Infinity;
        let pdZeroIdx = 0;
        for (let i = 0; i < vals.PD_min.length; i++) {
            const absPD = Math.abs(vals.PD_min[i]);
            if (absPD < minAbsPD) {
                minAbsPD = absPD;
                pdZeroIdx = i;
            }
        }
        
        // Format the output text with proper units
        const formatOutput = (positionName, idx) => {
            const powerValue = appState.weight_based ? vals.P[idx]/appState.body_mass : vals.P[idx];
            const vo2ssValue = appState.weight_based ? vals.VO2ss[idx]/appState.body_mass : vals.VO2ss[idx];
            const powerUnit = appState.weight_based ? "W·kg<sup>-1</sup>" : "W";
            const vo2ssUnit = appState.weight_based ? "ml·min<sup>-1</sup>·kg<sup>-1</sup>" : "ml·min<sup>-1</sup>";
            
            // Calculate percentage of VO2max
            const vo2maxValue = appState.weight_based ? vals.effective_values.VO2max/appState.body_mass : vals.effective_values.VO2max;
            const vo2Percentage = (vo2ssValue / vo2maxValue) * 100;
            
            // Get predicted RQ value
            const rqValue = vals.predicted_rq && idx < vals.predicted_rq.length ? vals.predicted_rq[idx] : 0.85;
            
            // Calculate efficiency values
            const effValues = calculateEfficiency(
                vals.P[idx], 
                vals.VO2ss[idx], 
                rqValue, 
                vals.effective_values.VO2Base
            );
            
            // Prepare substrate info if feature is enabled
            let substrateInfo = "";
            if (appState.show_substrate && idx < vals.carb_percentage.length) {
                // Get values and unit based on energy unit selection
                let choValue, fatValue, unit;
                switch(appState.energy_unit) {
                    case "g/h":
                        choValue = vals.carb_g_h[idx];
                        fatValue = vals.fat_g_h[idx];
                        unit = "g·h<sup>-1</sup>";
                        break;
                    case "kcal/h":
                        choValue = vals.carb_kcal_h[idx];
                        fatValue = vals.fat_kcal_h[idx];
                        unit = "kcal·h<sup>-1</sup>";
                        break;
                    case "kJ/h":
                        choValue = vals.carb_kj_h[idx];
                        fatValue = vals.fat_kj_h[idx];
                        unit = "kJ·h<sup>-1</sup>";
                        break;
                }
                
                substrateInfo = `  Carbohydrates: ${choValue.toFixed(1)} ${unit} (${vals.carb_percentage[idx].toFixed(1)}%)\n` +
                                `  Fat: ${fatValue.toFixed(1)} ${unit} (${vals.fat_percentage[idx].toFixed(1)}%)\n` +
                                `  Predicted RQ: ${rqValue.toFixed(3)}\n`;
            }
            
            return `${positionName} (${powerValue.toFixed(1)} ${powerUnit}):\n` +
                `  V̇O<sub>2,SS</sub>: ${vo2ssValue.toFixed(2)} ${vo2ssUnit} (${vo2Percentage.toFixed(1)}% of V̇O<sub>2,max</sub>)\n` +
                `  vLa<sub>SS</sub>: ${vals.vLass_min[idx].toFixed(4)} mmol·l<sup>-1</sup>·min<sup>-1</sup>\n` +
                `  vLa<sub>ox</sub>: ${vals.vLaox_min[idx].toFixed(4)} mmol·l<sup>-1</sup>·min<sup>-1</sup>\n` +
                `  PD: ${vals.PD_min[idx].toFixed(4)} mmol·l<sup>-1</sup>·min<sup>-1</sup>\n` +
                `  La<sub>Accumulation</sub>: ${isNaN(vals.La_accum[idx]) ? '0.0000' : vals.La_accum[idx].toFixed(4)} mmol·l<sup>-1</sup>\n` +
                substrateInfo +
                `  η<sub>gross</sub>: ${effValues.gross.toFixed(1)}%\n` +
                `  η<sub>net</sub>: ${effValues.net.toFixed(1)}%\n`;
        };
                    
        let outputText = "";
        
        // Add cadence info if enabled
        if (appState.cadence_dependent) {
            outputText += `Cadence: ${appState.cadence} rpm\n`;
            outputText += `CE: ${vals.effective_values.CEVO2.toFixed(2)} ml·min⁻¹·W⁻¹, ` +
                        `V̇O<sub>2,Base</sub>: ${Math.round(vals.effective_values.VO2Base)} ml·min⁻¹\n`;
            
            if (appState.vo2max_dependent) {
                outputText += `V̇O<sub>2,max</sub>: ${Math.round(vals.effective_values.VO2max)} ml·min⁻¹\n`;
            }
            
            if (appState.vlamax_dependent) {
                outputText += `vLa<sub>max</sub>: ${vals.effective_values.vLamax.toFixed(2)} mmol·l⁻¹·s⁻¹\n`;
            }
            
            outputText += `\n`;
        }
        
        outputText += 
            formatOutput("FAT<sub>max</sub>", pdMaxIdx) +
            formatOutput("MLSS", pdZeroIdx);
        
        elements.valuesContainer.innerHTML = outputText;
    }

    
    
    // Function to create power data for step test
    function createPowerData() {
        // Check if interval data is available
        if (appState.interval_data) {
            const data = appState.interval_data;
            
            // Sort by time
            data.sort((a, b) => a.time_s - b.time_s);
            
            // If we have at least two datapoints
            if (data.length > 1) {
                const minTime = data[0].time_s;
                const maxTime = data[data.length - 1].time_s;
                const allSeconds = [];
                const allPower = [];
                const allCadence = [];
                
                // Generate data for every second
                for (let t = minTime; t <= maxTime; t++) {
                    allSeconds.push(t);
                    
                    // Find the last power value at or before this time
                    let lastIdx = 0;
                    for (let i = 0; i < data.length; i++) {
                        if (data[i].time_s <= t) {
                            lastIdx = i;
                        } else {
                            break;
                        }
                    }
                    
                    allPower.push(data[lastIdx].power);
                    
                    // Add cadence if it exists
                    if (data[lastIdx].cadence !== undefined) {
                        allCadence.push(data[lastIdx].cadence);
                    } else {
                        allCadence.push(null);
                    }
                }
                
                return {
                    time_s: allSeconds,
                    power: allPower,
                    cadence: allCadence.every(c => c === null) ? null : allCadence
                };
            }
            
            // If there's cadence data in the interval data
            if (data.some(d => d.cadence !== undefined)) {
                return {
                    time_s: data.map(d => d.time_s),
                    power: data.map(d => d.power),
                    cadence: data.map(d => d.cadence || null)
                };
            } else {
                return {
                    time_s: data.map(d => d.time_s),
                    power: data.map(d => d.power),
                    cadence: null
                };
            }
        }
        // Check if a file was uploaded
        else if (appState.power_data) {
            return appState.power_data;
        }
        // Create step test data
        else {
            const stepWatt = appState.step_watt;
            const stepDurationSec = appState.step_duration;
            const maxPower = appState.max_power_step;
            
            // Create time and power arrays
            const numSteps = Math.floor(maxPower / stepWatt) + 1;
            const stepEndPower = (numSteps - 1) * stepWatt; // Last regular step
            const totalDurationSec = numSteps * stepDurationSec;
            const timeSec = [];
            const power = [];
            
            // Add step test (ensure maxPower is not exceeded)
            for (let i = 0; i < totalDurationSec; i++) {
                timeSec.push(i);
                const currentStep = Math.floor(i / stepDurationSec);
                const currentPower = currentStep * stepWatt;
                // Ensure maxPower is not exceeded
                power.push(Math.min(currentPower, stepEndPower));
            }
            
            // Add cool-down phase (600s at 0 Watt) after the step test
            const cooldownDuration = 600; // 600 seconds (10 minutes)
            const lastTime = timeSec[timeSec.length - 1];
            
            for (let i = 1; i <= cooldownDuration; i++) {
                timeSec.push(lastTime + i);
                power.push(0); // 0 Watt during cooldown
            }
            
            return {
                time_s: timeSec,
                power: power,
                cadence: null // No cadence in generated data
            };
        }
    }
    
    function initializeVo2StartSlider() {
        const base = appState.use_tab1_params ? appState.VO2Base : appState.VO2Base_step;
        const maxVal = appState.use_tab1_params ? appState.VO2max : appState.VO2max_step;
        if (elements.vo2_start) { // Ensure element exists
            elements.vo2_start.min = base;
            elements.vo2_start.max = maxVal;
            // Set value again to ensure it's within current constraints, using the value potentially set in updatePlot
            appState.vo2_start = Math.min(maxVal, Math.max(base, parseFloat(elements.vo2_start.value)));
            elements.vo2_start.value = appState.vo2_start;
            elements.vo2_startValue.textContent = appState.vo2_start;
        }
    }
    initializeVo2StartSlider(); // Call it after the first plot updates

    // Calculate W' Balance using Skiba's model
    function calcWPrimeBalance(powerValues, timeValues, cp, wprime) {
        const wprimeBalance = [];
        wprimeBalance[0] = wprime * 1000;  // Convert to Joules
        
        for (let i = 1; i < powerValues.length; i++) {
            // Time difference between current and previous measurement
            const deltaT = timeValues[i] - timeValues[i-1];
            
            // Calculate W' consumption/recovery
            if (powerValues[i-1] > cp) {
                // W' is consumed when power > CP
                const wprimeExp = (powerValues[i-1] - cp) * deltaT;
                wprimeBalance[i] = wprimeBalance[i-1] - wprimeExp;
            } else {
                // W' recovers when power < CP
                // Calculate DCP and time constant using Skiba's formula
                const dcp = cp - powerValues[i-1];
                const tauWPrime = 546 * Math.exp(-0.01 * dcp) + 316;
                
                // Exponential recovery
                wprimeBalance[i] = wprime * 1000 - (wprime * 1000 - wprimeBalance[i-1]) * Math.exp(-deltaT / tauWPrime);
            }
            
            // Ensure W' Balance doesn't exceed maximum
            wprimeBalance[i] = Math.min(wprimeBalance[i], wprime * 1000);
        }
        
        // Convert from Joules to kJ for display
        return wprimeBalance.map(w => w / 1000);
    }

    // Calculate MPA (Maximum Power Available) based on W' expenditure
    function calculateMPA(wprime_balance, wprime, pmax, cp) {
        // W'exp is the amount of W' expended (wprime - wprime_balance)
        const wprimeExp = wprime * 1000 - wprime_balance * 1000; // Convert to Joules
        
        // Use the modified 3-parameter model from Kontro et al. (2024) where W'exp/W' is raised to the 2nd power
        const mpa = pmax - (pmax - cp) * Math.pow((wprimeExp / (wprime * 1000)), 2);
        
        return Math.max(cp, mpa); // MPA cannot drop below CP
    }

    // Calculate the contribution of each energy system to power output
    function calculateEnergySystemContributions(power, cp, pmax) {
        // Power contributions
        let pCP, pWprime, pPmax;
        
        if (power <= cp) {
            // If power is below CP, all energy comes from aerobic system
            pCP = power;
            pWprime = 0;
            pPmax = 0;
        } else {
            // Calculate Pmax contribution using Equation 11
            pPmax = Math.pow(power - cp, 2) / (pmax - cp);
            
            // Calculate W' contribution using Equation 12
            pWprime = power - cp - pPmax;
            
            // CP contribution is just CP (Equation 13)
            pCP = cp;
        }
        
        return {
            pCP: pCP,
            pWprime: pWprime, 
            pPmax: pPmax
        };
    }

    // Calculate strain coefficient using Equation 14
    function calculateStrainCoefficient(power, mpa, cp, pmax) {
        return (pmax - mpa + cp) / (pmax - power + cp);
    }

    // Calculate strain rate using Equation 15
    function calculateStrainRate(kstrain, power) {
        return kstrain * power;
    }

    // Calculate Strain Score using Equation 16
    function calculateStrainScore(strainRates, cp, pmax) {
        // Sum all strain rates and normalize
        const sumSR = strainRates.reduce((sum, sr) => sum + sr, 0);
        
        // Multiply by normalization factor to get 100 at CP for one hour
        const normalizationFactor = (pmax / Math.pow(cp, 2)) * (100 / 3600);
        
        return sumSR * normalizationFactor;
    }

    // Calculate energy system-specific strain rates
    function calculateSystemStrainRates(power, mpa, cp, pmax) {
        // Get strain coefficient
        const kstrain = calculateStrainCoefficient(power, mpa, cp, pmax);
        
        // Get energy system contributions
        const contributions = calculateEnergySystemContributions(power, cp, pmax);
        
        // Calculate strain rates for each system
        const srCP = kstrain * contributions.pCP;
        const srWprime = kstrain * contributions.pWprime;
        const srPmax = kstrain * contributions.pPmax;
        
        return {
            total: kstrain * power,
            CP: srCP,
            Wprime: srWprime,
            Pmax: srPmax
        };
    }
    
       // Function to calculate step test simulation
        function calculateStepTest() {
            // Get parameters - either from tab 1 or individual
            let CE = appState.use_tab1_params ? appState.CEVO2 : appState.CEVO2_step;
            let CE_range = appState.use_tab1_params ? appState.CE_range : appState.CE_range_step;
            let isCurvilinear = appState.use_tab1_params ? appState.curvilinear : appState.curvilinear_step;
            let VO2max = appState.use_tab1_params ? appState.VO2max : appState.VO2max_step;
            let VO2Base = appState.use_tab1_params ? appState.VO2Base : appState.VO2Base_step;
            let vLamax_base = appState.use_tab1_params ? appState.vLamax : appState.vLamax_step; // Base vLamax before pH/cadence adjustment
            let body_mass = appState.use_tab1_params ? appState.body_mass : appState.body_mass_step;

            // --- START: Intensity-Dependent Tau_Off Setup ---
            const use_dynamic_tau_off = appState.dynamic_tau_off;
            const tau_off_slider_value = appState.vo2_down_time_constant; // This is the baseline at 50% if dynamic is ON
            // Calculate offset based on deviation from the formula's 50% value (0.45*50+10 = 32.5)
            const tau_off_adjustment = use_dynamic_tau_off ? (tau_off_slider_value - 32.5) : 0;
            const tau_off_values = []; // Array to store calculated tau_off for each step
            // --- END: Intensity-Dependent Tau_Off Setup ---

            // Get power data
            const powerData = createPowerData();
            // Check if powerData is valid
            if (!powerData || !powerData.time_s || powerData.time_s.length === 0) {
                console.error("Failed to get power data or power data is empty.");
                showNotification("Error loading or generating power data.", "warning");
                // Return an empty object or default structure to prevent crashes downstream
                return {
                    time_sec: [], power: [], VO2: [], vo2_demand: [], vLass_min: [], vLaox_min: [],
                    PD: [], La_conc: [], w_prime_bal: [], glycogen_store: [], carb_gram_min: [],
                    fat_gram_min: [], abort_power: null, abort_time: null, abort_reason: null,
                    cadence: null, is_curvilinear: false, a_opt: null, ce_range: [0,0],
                    pcr_store: null, accumulated_o2_deficit: null, pHm: null, mpa: [],
                    strain_rates: [], strain_rates_cp: [], strain_rates_wprime: [],
                    strain_rates_pmax: [], cumulative_strain_score: [], pmax: 0
                };
            }
            const timePoints = powerData.time_s;
            let powerValues = [...powerData.power];

            // Scale power values based on power scale (0-200%)
            if (appState.power_scale !== 100) {
                const scaleFactor = appState.power_scale / 100;
                powerValues = powerValues.map(p => p * scaleFactor);
            }

            // Extract cadence data if available
            let cadenceValues = null;
            if (appState.cadence_dependent_step && powerData.cadence && appState.use_file_cadence) {
                cadenceValues = [...powerData.cadence];
                // Fill any null values with the fixed cadence value
                cadenceValues = cadenceValues.map(c => (c === null || isNaN(c)) ? appState.cadence_step : c);
            }

            // Smooth power values if selected
            if (appState.smooth_power && powerValues.length >= 15) {
                powerValues = smoothData(powerValues, 15);
                // Replace NaN values at beginning and end after smoothing
                const naIndices = powerValues.map((v, i) => isNaN(v) ? i : null).filter(i => i !== null);
                if (naIndices.length > 0) {
                    const firstValidIdx = powerValues.findIndex(v => !isNaN(v));
                    const lastValidIdx = powerValues.map((v, i) => !isNaN(v) ? i : null).filter(i => i !== null).pop();
                    // Ensure valid indices exist before assigning
                    const firstVal = (firstValidIdx !== -1) ? powerValues[firstValidIdx] : 0; // Default to 0 if no valid value found
                    const lastVal = (lastValidIdx !== -1) ? powerValues[lastValidIdx] : 0;   // Default to 0 if no valid value found
                    for (const i of naIndices) {
                        powerValues[i] = (i < firstValidIdx) ? firstVal : lastVal;
                    }
                }
                // Smooth cadence values if available
                if (cadenceValues) {
                    cadenceValues = smoothData(cadenceValues, 10); // Use 10-point window for cadence
                    // Replace NaN values for cadence
                    const naCadenceIndices = cadenceValues.map((v, i) => isNaN(v) ? i : null).filter(i => i !== null);
                    if (naCadenceIndices.length > 0) {
                        const firstValidCadIdx = cadenceValues.findIndex(v => !isNaN(v));
                        const lastValidCadIdx = cadenceValues.map((v, i) => !isNaN(v) ? i : null).filter(i => i !== null).pop();
                        // Ensure valid indices exist before assigning
                        const firstCadVal = (firstValidCadIdx !== -1) ? cadenceValues[firstValidCadIdx] : appState.cadence_step; // Default to fixed cadence
                        const lastCadVal = (lastValidCadIdx !== -1) ? cadenceValues[lastValidCadIdx] : appState.cadence_step;   // Default to fixed cadence
                        for (const i of naCadenceIndices) {
                            cadenceValues[i] = (i < firstValidCadIdx) ? firstCadVal : lastCadVal;
                        }
                    }
                }
            }

            // Arrays to store time-dependent effective parameters
            const effectiveCEVO2 = new Array(timePoints.length);
            const effectiveVO2Base = new Array(timePoints.length);
            const effectiveVLamax_input = new Array(timePoints.length); // vLamax before pH adjustment
            const effectiveVO2max = new Array(timePoints.length);

            // Calculate cadence-dependent parameters *before* the main loop
            for (let i = 0; i < timePoints.length; i++) {
                if (appState.cadence_dependent_step) {
                    // Use cadence from file or fixed value, ensure it's a number
                    const currentCadence = (cadenceValues && appState.use_file_cadence && cadenceValues[i] !== null && !isNaN(cadenceValues[i])) ?
                        cadenceValues[i] : appState.cadence_step;

                    effectiveCEVO2[i] = calculateCadenceDependentCEVO2(currentCadence);
                    effectiveVO2Base[i] = calculateCadenceDependentVO2Base(currentCadence);

                    if (appState.vlamax_dependent_step) {
                        effectiveVLamax_input[i] = calculateCadenceDependentVLamax(currentCadence);
                    } else {
                        effectiveVLamax_input[i] = vLamax_base; // Use the base value from state
                    }

                    if (appState.vo2max_dependent_step) {
                        effectiveVO2max[i] = calculateCadenceDependentVO2max(currentCadence, VO2max);
                    } else {
                        effectiveVO2max[i] = VO2max;
                    }
                } else {
                    // If cadence dependency not enabled, use fixed values
                    effectiveCEVO2[i] = CE;
                    effectiveVO2Base[i] = VO2Base;
                    effectiveVLamax_input[i] = vLamax_base; // Use base value from state
                    effectiveVO2max[i] = VO2max;
                }
            }

            // Constants
            const CELaO2 = 0.02049 / body_mass;
            const VolLa = 0.4;
            const ks1 = 0.0635; // ADP^2 dependency for VO2ss
            const ks2 = Math.pow(1.1, 3); // ADP^3 dependency for vLass (original Mader)

            // Simulation parameters
            const vo2UpTimeConstant = appState.vo2_up_time_constant;
            const laMax = appState.la_max;
            const laBase = appState.la_base;
            const vo2_delay_steps = Math.max(0, appState.vo2_delay); // Delay in integer steps (seconds)
            const vlass_delay_steps = Math.max(0, appState.vlass_delay); // Delay in integer steps (seconds)


            // Calculate VO2 target values with curvilinear option
            const vo2Target = [];
            const vo2Demand = []; // VO2 demand for each power level before VO2max limitation
            let aOpt = null;

            // Calculate a coefficient if curvilinear is used
            if (isCurvilinear) {
                // Use potentially cadence-dependent Base/Max for the *first* time step for aOpt calculation
                const baseVO2_for_aOpt = effectiveVO2Base[0];
                const maxVO2_for_aOpt = effectiveVO2max[0];
                aOpt = findOptimalA(CE_range[0], CE_range[1], maxVO2_for_aOpt, baseVO2_for_aOpt);
            }

            for (let i = 0; i < timePoints.length; i++) {
                let vo2ss;
                const currentPower = powerValues[i] !== undefined ? powerValues[i] : 0; // Ensure power value exists
                const currentEffBase = effectiveVO2Base[i];
                const currentEffCE = effectiveCEVO2[i];
                const currentEffMax = effectiveVO2max[i];

                if (isCurvilinear && aOpt !== null) {
                    // Use time-varying base VO2 but constant CE range params for simplicity here
                    vo2ss = aOpt * Math.pow(currentPower, 2) + CE_range[0] * currentPower + currentEffBase;
                } else {
                    vo2ss = currentEffCE * currentPower + currentEffBase;
                }
                vo2Demand[i] = vo2ss; // Store original demand before VO2max limitation
                vo2Target[i] = Math.min(vo2ss, currentEffMax); // Limited by effective VO2max for this step
            }


            // Initialize main simulation arrays
            const vo2Actual = [appState.vo2_start];
            const vLassActual = [0]; // Assume starting vLass rate is 0 (mmol/l/s)
            const vLassTarget_effective = [0]; // Target rate using effective vLamax (mmol/l/s)
            const vLaoxActual_s = [(CELaO2 * vo2Actual[0]) / (VolLa * 60)]; // Initial vLaox (mmol/l/s)
            const LaConc = [laBase]; // Lactate concentration (mmol/l)
            const pcrStore = []; // PCr concentration (mmol/kg ww)
            const pcrResynthesisFactor = 0.30; // Nur 30% des O2-Überschusses gehen in die PCr-Resynthese
            const accumulatedO2Deficit = []; // Accumulated O2 deficit (ml)
            const glycogenStore = []; // Glycogen store (g)
            const carbGramMin = []; // Store CHO usage rate (g/min)
            const fatGramMin = []; // Store FAT usage rate (g/min)
            const pHm = []; // <<<< Array for pHm
            const Pi_est = []; // <<<< Array for estimated Pi (mmol/kg ww)
            const pCO2_est = []; // <<<< Array for estimated pCO2 (mmHg)

            // pH calculation constants
            const dbuff = 0.0185; // Buffer coefficient (mmol/l/pH)
            const Pi_min = 3.0;   // Resting Pi (mmol/kg ww)
            const Pi_max = 25.0;  // Max Pi near exhaustion (mmol/kg ww)
            const PCr_max = appState.pcr_init; // User-set initial PCr
            const PCr_min = 1.0;  // Assumed minimum PCr near exhaustion

            // PFK activity factor constants
            const pH_base_pfk = 7.05; // Reference pH for ~100% PFK activity
            const pH_50_pfk = 6.75;   // Approx. pH for 50% PFK inhibition
            const Hill_n_pH_pfk = 3;  // Hill coefficient for pH inhibition

            // Initialize values for the first time point (t=0)
            pcrStore[0] = appState.pcr_init; // <<< Always initialize PCr
            accumulatedO2Deficit[0] = 0;   // <<< Always initialize deficit

            // Initial pHm calculation (always performed)
            let initial_Pi = Pi_min; // Start with resting Pi
            const initial_pcr_range = PCr_max - PCr_min;
            if (initial_pcr_range > 0) { // Recalculate initial Pi based on initial PCr
            initial_Pi = Pi_min + (Pi_max - Pi_min) * Math.max(0, PCr_max - pcrStore[0]) / initial_pcr_range;
            initial_Pi = Math.min(Pi_max, Math.max(Pi_min, initial_Pi));
            }
            Pi_est[0] = initial_Pi; // Store initial Pi estimate

            let initial_Lam = laBase; // Resting muscle lactate approx.
            let initial_VO2 = vo2Actual[0];
            let initial_effVO2max = effectiveVO2max[0]; // VO2max at t=0
            let initial_vo2Ratio = initial_effVO2max > 0 ? initial_VO2 / initial_effVO2max : 0;
            let initial_pCO2 = Math.max(40, Math.min(80, 40 + 55 * initial_vo2Ratio)); // Estimate initial pCO2
            pCO2_est[0] = initial_pCO2; // Store initial pCO2 estimate

            let initial_logArg = Math.max(1e-9, initial_pCO2);
            let initial_pH = 7.85 + dbuff * (0.8 * initial_Pi - initial_Lam) - 0.55 * Math.log10(initial_logArg);
            pHm[0] = Math.max(6.0, Math.min(7.4, initial_pH)); // Store initial pH

            // Other initializations
            glycogenStore[0] = appState.glycogen_init;
            carbGramMin[0] = 0;
            fatGramMin[0] = 0;

            // Abort tracking variables
            let endIdx = timePoints.length;
            let abortIdx = null;
            let abortPower = null;
            let abortTime = null;
            let abortReason = null;

            // Initialize W' Balance related calculations
            const cp = appState.critical_power;
            const wprime = appState.w_prime;
            const wprimeBalance = [wprime * 1000]; // Start with full W' in Joules
            const mpaValues = [appState.pmax]; // Start with Pmax
            const strainRates = [0];
            const strainRatesCP = [0];
            const strainRatesWprime = [0];
            const strainRatesPmax = [0];
            const cumulativeStrainScore = [0];

            // Main Simulation Loop
            for (let i = 1; i < timePoints.length; i++) {
                const deltaT = timePoints[i] - timePoints[i - 1];
                if (deltaT <= 0) { // Handle duplicate or non-increasing time points
                    vo2Actual.push(vo2Actual[i - 1]);
                    vLassActual.push(vLassActual[i - 1]);
                    vLassTarget_effective.push(vLassTarget_effective[i - 1]);
                    vLaoxActual_s.push(vLaoxActual_s[i - 1]);
                    LaConc.push(LaConc[i - 1]);
                    pcrStore.push(pcrStore[i - 1]); // <<< Carry over
                    accumulatedO2Deficit.push(accumulatedO2Deficit[i - 1]); // <<< Carry over
                    pHm.push(pHm[i - 1]);       // <<< Carry over pH
                    Pi_est.push(Pi_est[i - 1]);   // <<< Carry over Pi
                    pCO2_est.push(pCO2_est[i - 1]); // <<< Carry over pCO2
                    glycogenStore.push(glycogenStore[i - 1]);
                    carbGramMin.push(carbGramMin[i - 1]);
                    fatGramMin.push(fatGramMin[i - 1]);
                    wprimeBalance.push(wprimeBalance[i-1]);
                    mpaValues.push(mpaValues[i-1]);
                    strainRates.push(0);
                    strainRatesCP.push(0);
                    strainRatesWprime.push(0);
                    strainRatesPmax.push(0);
                    cumulativeStrainScore.push(cumulativeStrainScore[i-1]);
                    tau_off_values.push(tau_off_values[i-1] !== undefined ? tau_off_values[i-1] : tau_off_slider_value);
                    continue;
                }

                 // --- START: Determine current Tau_Off ---
                let current_tau_off;
                if (!use_dynamic_tau_off) {
                    current_tau_off = tau_off_slider_value; // Fixed value from slider
                } else {
                    // Dynamic calculation
                    // Use previous calculated tau or baseline for lookback window size
                    const tau_off_prev = (i > 1 && tau_off_values.length > i-1 && tau_off_values[i-1] !== undefined) ? tau_off_values[i-1] : tau_off_slider_value;
                    const lookback_duration = 4 * tau_off_prev; // Hier festlegen wie viel tau zurückgeschaut werden
                    const lookback_start_time = Math.max(timePoints[0], timePoints[i-1] - lookback_duration);
                    const lookback_end_time = timePoints[i-1]; // Look up to the previous point

                    let max_vo2_in_window = 0;
                    let intensity_percent = 0;

                    // Find max VO2 in the lookback window by iterating backwards from i-1
                    let found_max = false;
                    for (let j = i - 1; j >= 0; j--) {
                        if (timePoints[j] < lookback_start_time) {
                            break; // Stop if we go past the start time
                        }
                        if (timePoints[j] <= lookback_end_time) { // Ensure we are within the end time
                            if (vo2Actual[j] !== undefined) {
                                max_vo2_in_window = Math.max(max_vo2_in_window, vo2Actual[j]);
                                found_max = true;
                            }
                        }
                    }

                    // Calculate intensity percentage based on found max VO2
                    if (found_max) {
                        const currentEffVO2max_for_tau = effectiveVO2max[i] > 0 ? effectiveVO2max[i] : 1; // Avoid division by zero
                        intensity_percent = Math.max(0, Math.min(100, (max_vo2_in_window / currentEffVO2max_for_tau) * 100));
                    } else if (i > 0 && vo2Actual[i-1] !== undefined) {
                        // Fallback if no points in window -> use intensity at i-1
                        const currentEffVO2max_for_tau = effectiveVO2max[i] > 0 ? effectiveVO2max[i] : 1;
                        intensity_percent = Math.max(0, Math.min(100, (vo2Actual[i-1] / currentEffVO2max_for_tau) * 100));
                    } // Else intensity_percent remains 0

                    const tau_from_formula = 0.45 * intensity_percent + 10;
                    current_tau_off = Math.round(Math.max(10, tau_from_formula + tau_off_adjustment)); // Apply adjustment, ensure min 10, and round
                }
                tau_off_values.push(current_tau_off); // Store the calculated tau_off for this step's use next iteration
                // --- END: Determine current Tau_Off ---

            // --- VO2 Kinetics --- //
                const currentVo2_total = vo2Actual[i - 1];
                const baseVO2_current = effectiveVO2Base[i];
                const maxVO2_current = effectiveVO2max[i];
                const delay_idx_vo2 = Math.max(0, i - vo2_delay_steps);
                const targetVo2_final_delayed = vo2Target[delay_idx_vo2];
                const overall_target_diff = targetVo2_final_delayed - currentVo2_total;
                const timeConstant = (overall_target_diff >= 0) ? vo2UpTimeConstant : current_tau_off;
                const effectiveTimeConstant = Math.max(1, timeConstant);
                const vo2Change = overall_target_diff * (1 - Math.exp(-deltaT / effectiveTimeConstant));
                const nextVo2 = currentVo2_total + vo2Change;
                const vo2_constrained = Math.min(maxVO2_current, Math.max(baseVO2_current * 0.8, nextVo2));
                vo2Actual.push(vo2_constrained);

                // --- vLass Kinetics (pH dependent) ---
                const last_pHm = pHm[i-1]; // Get pH from previous step

                // Calculate pH-dependent PFK activity factor
                const H_plus_current_pfk = Math.pow(10, -last_pHm);
                const H_plus_50_pfk = Math.pow(10, -pH_50_pfk);
                let pfk_inhibition_factor = 1.0;
                if (H_plus_50_pfk > 1e-9) { // Avoid division by zero or near-zero
                    pfk_inhibition_factor = 1 / (1 + Math.pow(H_plus_current_pfk / H_plus_50_pfk, Hill_n_pH_pfk));
                }
                const pfk_activity_factor = Math.max(0.01, Math.min(1.1, pfk_inhibition_factor));

                // Determine effective vLamax for this step
                const current_base_vLamax = effectiveVLamax_input[i];
                const current_effective_vLamax = current_base_vLamax * pfk_activity_factor;

                // Calculate the target vLass using the pH-adjusted effective vLamax
                const maxVO2_for_vLass = effectiveVO2max[i];
                const denominator_vo2_vLass = Math.max(1, vo2Demand[i]);
                const vo2_term_vLass = Math.max(0, (maxVO2_for_vLass - denominator_vo2_vLass) / (ks1 * denominator_vo2_vLass));
                // Ensure the base of the power is non-negative and denominator > 0
                const power_base_vLass = Math.max(0, vo2_term_vLass);
                let target_vLass_now = 0;
                if (denominator_vo2_vLass > 0) {
                    target_vLass_now = current_effective_vLamax / (1 + ks2 * Math.pow(power_base_vLass, 3/2));
                }
                vLassTarget_effective.push(target_vLass_now);

                // Apply delay to the target for kinetics calculation
                const delay_idx_vlass = Math.max(0, i - vlass_delay_steps);
                const target_vLass_delayed = vLassTarget_effective[delay_idx_vlass];

                const vLass_target_diff = target_vLass_delayed - vLassActual[i - 1];
                const timeConstant_vLass = (vLass_target_diff >= 0) ? Math.max(1, appState.vLass_on_tau) : Math.max(1, appState.vLass_off_tau);
                const vLass_change = vLass_target_diff * (1 - Math.exp(-deltaT / timeConstant_vLass));
                const nextVLass = vLassActual[i - 1] + vLass_change;
                vLassActual.push(Math.max(0, nextVLass)); // Store vLass in mmol/l/s


                // --- Lactate Oxidation & Concentration ---
                const vLaox_current_s = (CELaO2 * vo2Actual[i]) / (VolLa * 60);
                vLaoxActual_s.push(vLaox_current_s);
                const netLaRate_s = vLassActual[i] - vLaox_current_s;
                const deltaLa = netLaRate_s * deltaT;
                LaConc.push(Math.max(laBase * 0.8, LaConc[i - 1] + deltaLa));


                // --- PCr, O2 Deficit --- (Calculated ALWAYS now)
                const deltaTMin = deltaT / 60;
                const o2MolarVolume = 22414; // ml/mol STPD
                const beta_O2_lactate_equiv = 3.0; // ml O2 / kg / mM
                const current_active_muscle_mass = appState.active_muscle_mass;

                const current_o2Deficit_rate = Math.max(0, vo2Target[i] - vo2Actual[i]);
                const current_o2Surplus_rate = Math.max(0, vo2Actual[i] - vo2Target[i]);
                const deficitMl_interval = current_o2Deficit_rate * deltaTMin;
                const surplusMl_interval = current_o2Surplus_rate * deltaTMin;

                //// <<<< ALT: Verwende Netto vLassActual
                // const netLaRate_s_prev = Math.max(0, vLassActual[i-1] - vLaoxActual_s[i-1]);
                // const o2EquivRateLa_ml_min_prev = netLaRate_s_prev * 60 * beta_O2_lactate_equiv * body_mass;
                // const o2EquivLa_ml_interval = o2EquivRateLa_ml_min_prev * deltaTMin;

                // Estimate O2 equivalent covered by GROSS lactate production *during* the interval
                // Using previous step's GROSS rate:
                // <<<< MODIFIZIERT: Verwende Brutto vLassActual Rate statt Netto Rate >>>>
                const grossLaRate_s_prev = vLassActual[i-1]; // Brutto-Rate aus dem vorherigen Schritt (ist bereits >= 0)
                const o2EquivRateLa_ml_min_prev = grossLaRate_s_prev * 60 * beta_O2_lactate_equiv * body_mass; // <<< Verwendet jetzt die Brutto-Rate
                const o2EquivLa_ml_interval = o2EquivRateLa_ml_min_prev * deltaTMin;


                // Remaining deficit to be covered by PCr
                // Use previous deficit *rate* to calculate amount over interval for PCr consumption
                const prev_o2Deficit_rate = (i > 1) ? Math.max(0, vo2Target[i-1] - vo2Actual[i-1]) : 0;
                const deficitMl_original_prev_rate = prev_o2Deficit_rate * deltaTMin;
                // <<<< MODIFIZIERT: Zieht jetzt den O2-Äquivalenzbeitrag der Brutto-Glykolyse ab >>>>
                const deficitMl_for_pcr = Math.max(0, deficitMl_original_prev_rate - o2EquivLa_ml_interval);;
                
                // Ensure active muscle mass is positive to avoid division by zero
                let pcrConsumption = 0;
                let pcrResynthesis = 0;
                if (current_active_muscle_mass > 0) {
                    const denominator_pcr = current_active_muscle_mass * o2MolarVolume; // Nenner für beide Berechnungen
                    if (denominator_pcr > 0) { // Zusätzliche Sicherheitsprüfung für den Nenner
                        pcrConsumption = (deficitMl_for_pcr * appState.p_o_ratio * 1000) / denominator_pcr;
                        // <<<< NEU: surplusMl_interval mit pcrResynthesisFactor multiplizieren >>>>
                        pcrResynthesis = (surplusMl_interval * pcrResynthesisFactor * appState.p_o_ratio * 1000) / denominator_pcr;
                    }
                }

                const nextPcr = pcrStore[i-1] - pcrConsumption + pcrResynthesis;
                pcrStore.push(Math.min(appState.pcr_init, Math.max(0, nextPcr))); // Store clamped PCr

                accumulatedO2Deficit.push(Math.max(0, accumulatedO2Deficit[i - 1] + deficitMl_interval - surplusMl_interval));

                // --- Calculate pHm for the *current* step i --- (Calculated ALWAYS now)
                // 1. Estimate Pi based on *current* PCr store
                let currentPi = Pi_min;
                const pcr_val = pcrStore[i]; // Get PCr for step i
                const pcr_range = PCr_max - PCr_min;
                if (pcr_range > 0) {
                    currentPi = Pi_min + (Pi_max - Pi_min) * Math.max(0, PCr_max - pcr_val) / pcr_range;
                    currentPi = Math.min(Pi_max, Math.max(Pi_min, currentPi));
                }
                Pi_est.push(currentPi); // Store Pi estimate for step i

                // 2. Get Lam (Muscle Lactate) for *current* step i
                const currentLam = LaConc[i];

                // 3. Estimate pCO2 based on *current* relative VO2 intensity
                const currentVO2 = vo2Actual[i];
                const currentEffVO2max = effectiveVO2max[i];
                let vo2Ratio = currentEffVO2max > 0 ? (currentVO2 / currentEffVO2max) : 0;
                let currentPCO2 = 40 + 55 * vo2Ratio; // Mader's empirical formula
                currentPCO2 = Math.max(40, Math.min(80, currentPCO2)); // Clamp pCO2
                pCO2_est.push(currentPCO2); // Store pCO2 estimate for step i

                // 4. Calculate pHm for *current* step i
                const logArg_pH = Math.max(1e-9, currentPCO2); // Ensure log10 argument > 0
                const pH_val_current = 7.85 + dbuff * (0.8 * currentPi - currentLam) - 0.55 * Math.log10(logArg_pH);
                pHm.push(Math.max(6.0, Math.min(7.4, pH_val_current))); // Store clamped pH for step i
                // --- END pH Calculation ---


                // --- Glycogen and Substrate Calculation ---
                const vLassMin_current = vLassActual[i] * 60;
                const vLaoxMin_current = vLaoxActual_s[i] * 60;
                const PD_current = vLaoxMin_current - vLassMin_current;

                let carbPerc_current = 0;
                if (vLaoxMin_current > 1e-6) { // Avoid division by zero
                    carbPerc_current = Math.min(100, Math.max(0, (vLassMin_current / vLaoxMin_current) * 100));
                }
                if (PD_current <= 0) { // Above MLSS approx.
                    carbPerc_current = 100;
                }

                const vo2L_min_current = vo2Actual[i] / 1000;
                // Use RQ-dependent caloric equivalent for better accuracy
                const currentRQ = calculateRQ(carbPerc_current);
                const currentKcalPerO2L = getKalorischesEquivalent(currentRQ).kcal_lO2;
                const totalKcalMin_current = vo2L_min_current * currentKcalPerO2L;

                const kcalPerGramCarb = 4.1;
                const carbKcalMin_current = totalKcalMin_current * (carbPerc_current / 100);
                const carbGramMin_current = carbKcalMin_current / kcalPerGramCarb;
                carbGramMin.push(carbGramMin_current);

                // Glycogen store update
                const glycogenConsumption = carbGramMin_current * deltaTMin;
                const carbIntakeGMin = appState.carb_intake_rate / 60;
                const glycogenIntake = carbIntakeGMin * deltaTMin;
                const nextGlycogen = glycogenStore[i-1] - glycogenConsumption + glycogenIntake;
                glycogenStore.push(Math.min(appState.glycogen_max, Math.max(0, nextGlycogen)));

                // Fat calculation
                const fatPerc_current = 100 - carbPerc_current;
                const fatKcalMin_current = totalKcalMin_current * (fatPerc_current / 100);
                const kcalPerGramFat = 9.45;
                const fatGramMin_current = fatKcalMin_current / kcalPerGramFat;
                fatGramMin.push(fatGramMin_current);


                // --- W' Balance, MPA, Strain Score ---
                const powerPrev = powerValues[i-1];
                const wPrimePrev = wprimeBalance[i-1];
                let wPrimeNext = wPrimePrev;

                if (powerPrev > cp) {
                    const wprimeExp = (powerPrev - cp) * deltaT;
                    wPrimeNext = wPrimePrev - wprimeExp;
                } else {
                    const dcp = cp - powerPrev;
                    const tauWPrime = 546 * Math.exp(-0.01 * dcp) + 316;
                    wPrimeNext = wprime * 1000 - (wprime * 1000 - wPrimePrev) * Math.exp(-deltaT / tauWPrime);
                }
                wPrimeNext = Math.min(wPrimeNext, wprime * 1000); // Cap at max W'
                wprimeBalance.push(wPrimeNext);

                // MPA calculation for the current step
                const wPrimeExpCurrent = wprime * 1000 - wPrimeNext; // W' expended up to *end* of step i
                // Ensure wprime denominator is not zero
                const wPrimeTotalJoules = wprime * 1000;
                let wPrimeRatioSquared = 0;
                if (wPrimeTotalJoules > 0) {
                    wPrimeRatioSquared = Math.pow((wPrimeExpCurrent / wPrimeTotalJoules), 2);
                }
                const mpa_current = appState.pmax - (appState.pmax - cp) * wPrimeRatioSquared;
                mpaValues.push(Math.max(cp, mpa_current)); // MPA cannot drop below CP

                // Strain Score calculation based on power in *previous* interval
                const mpaPrev = mpaValues[i-1]; // MPA at the beginning of the interval
                const sysStrainRates = calculateSystemStrainRates(powerPrev, mpaPrev, cp, appState.pmax);
                strainRates.push(sysStrainRates.total);
                strainRatesCP.push(sysStrainRates.CP);
                strainRatesWprime.push(sysStrainRates.Wprime);
                strainRatesPmax.push(sysStrainRates.Pmax);

                // Calculate current interval strain score contribution
                let intervalSS = 0;
                if (cp > 0) { // Avoid division by zero if CP is zero
                    const normalizationFactorSS = (appState.pmax / Math.pow(cp, 2)) * (100 / 3600);
                    intervalSS = sysStrainRates.total * deltaT * normalizationFactorSS;
                }
                cumulativeStrainScore.push(cumulativeStrainScore[i-1] + intervalSS);


                // --- Check Abort Conditions ---
                // Check only if simulation hasn't already been marked for abortion
                if (abortIdx === null) {
                    if (appState.use_lactate_abort && LaConc[i] >= laMax) {
                        abortIdx = i; abortPower = powerValues[i]; abortTime = timePoints[i]; abortReason = "lactate";
                    } else if (pcrStore[i] <= 0.1) { // Check PCr depletion *after* calculation for step i
                        abortIdx = i; abortPower = powerValues[i]; abortTime = timePoints[i]; abortReason = "pcr";
                    } else if (appState.use_w_prime_balance_abort && wprimeBalance[i] <= (appState.w_prime_balance_min * 1000)) { // Compare W' in Joules
                        abortIdx = i; abortPower = powerValues[i]; abortTime = timePoints[i]; abortReason = "wbalance";
                    } else if (glycogenStore[i] <= 0) {
                        abortIdx = i; abortPower = powerValues[i]; abortTime = timePoints[i]; abortReason = "glycogen";
                    }
                }

            } // End of main simulation loop

            // --- Prepare Results ---
            const finalVLassMin = vLassActual.map(v => v * 60);
            const finalVLaoxMin = vLaoxActual_s.map(v => v * 60);
            const finalPD = finalVLaoxMin.map((ox, idx) => ox - finalVLassMin[idx]);
            const finalWPrimeBalanceKJ = wprimeBalance.map(w => w / 1000); // Convert Joules to kJ

            // Trim arrays if simulation was aborted
            if (abortIdx !== null) {
                endIdx = abortIdx + 1; // Include the point where abortion occurred
                const trim = (arr) => arr ? arr.slice(0, endIdx) : null; // Helper to handle potentially null arrays

                // Create final cadence array based on settings
                let trimmedCadence = null;
                if (cadenceValues && appState.cadence_dependent_step && appState.use_file_cadence) {
                    trimmedCadence = trim(cadenceValues);
                } else if (appState.cadence_dependent_step) {
                    trimmedCadence = new Array(endIdx).fill(appState.cadence_step);
                }

                return {
                    time_sec: trim(timePoints),
                    power: trim(powerValues),
                    VO2: trim(vo2Actual),
                    vo2_demand: trim(vo2Demand),
                    vLass_min: trim(finalVLassMin),
                    vLaox_min: trim(finalVLaoxMin),
                    PD: trim(finalPD),
                    La_conc: trim(LaConc),
                    w_prime_bal: trim(finalWPrimeBalanceKJ), // Return kJ
                    glycogen_store: trim(glycogenStore),
                    carb_gram_min: trim(carbGramMin),
                    fat_gram_min: trim(fatGramMin),
                    abort_power: abortPower,
                    abort_time: abortTime,
                    abort_reason: abortReason,
                    cadence: trimmedCadence,
                    is_curvilinear: isCurvilinear,
                    a_opt: aOpt,
                    ce_range: CE_range,
                    pcr_store: trim(pcrStore),
                    accumulated_o2_deficit: trim(accumulatedO2Deficit),
                    pHm: trim(pHm), // <<< Return trimmed pHm
                    mpa: trim(mpaValues),
                    strain_rates: trim(strainRates),
                    strain_rates_cp: trim(strainRatesCP),
                    strain_rates_wprime: trim(strainRatesWprime),
                    strain_rates_pmax: trim(strainRatesPmax),
                    cumulative_strain_score: trim(cumulativeStrainScore),
                    pmax: appState.pmax
                };
            }

            // If not aborted, return full arrays
            // Create final cadence array based on settings
            let finalCadence = null;
            if (cadenceValues && appState.cadence_dependent_step && appState.use_file_cadence) {
                finalCadence = cadenceValues;
            } else if (appState.cadence_dependent_step) {
                finalCadence = new Array(timePoints.length).fill(appState.cadence_step);
            }

            return {
                time_sec: timePoints,
                power: powerValues,
                VO2: vo2Actual,
                vo2_demand: vo2Demand,
                vLass_min: finalVLassMin,
                vLaox_min: finalVLaoxMin,
                PD: finalPD,
                La_conc: LaConc,
                w_prime_bal: finalWPrimeBalanceKJ, // Return kJ
                glycogen_store: glycogenStore,
                carb_gram_min: carbGramMin,
                fat_gram_min: fatGramMin,
                abort_power: abortPower, // Will be null if not aborted
                abort_time: abortTime,   // Will be null
                abort_reason: abortReason,// Will be null
                cadence: finalCadence,
                is_curvilinear: isCurvilinear,
                a_opt: aOpt,
                ce_range: CE_range,
                pcr_store: pcrStore, // <<< Return full array
                accumulated_o2_deficit: accumulatedO2Deficit, // <<< Return full array
                pHm: pHm, // <<< Return calculated pHm
                mpa: mpaValues,
                strain_rates: strainRates,
                strain_rates_cp: strainRatesCP,
                strain_rates_wprime: strainRatesWprime,
                strain_rates_pmax: strainRatesPmax,
                cumulative_strain_score: cumulativeStrainScore,
                pmax: appState.pmax
            };
        }
    

    // Function to calculate and update exercise summary statistics
    function updateExerciseSummary(stepData) {
        if (!stepData || !stepData.power || stepData.power.length === 0) {
            return;
        }

        const timeSec = stepData.time_sec;
        const powerValues = stepData.power;
        const vo2Values = stepData.VO2;
        const wprimeBalance = stepData.w_prime_bal;
        const cp = appState.critical_power;
        const pmax = appState.pmax;
        
        // Calculate time deltas for weighted averages
        const deltaT = [];
        for (let i = 1; i < timeSec.length; i++) {
            deltaT.push(timeSec[i] - timeSec[i-1]);
        }
        
        // Calculate duration in seconds and hours
        const durationSec = timeSec[timeSec.length - 1] - timeSec[0];
        const durationHours = durationSec / 3600;
        
        // Calculate average power
        let totalPowerTimeProduct = 0;
        for (let i = 0; i < powerValues.length - 1; i++) {
            totalPowerTimeProduct += powerValues[i] * deltaT[i];
        }
        const avgPower = totalPowerTimeProduct / durationSec;
        
        // Calculate normalized power using the standard algorithm
        // First, calculate 30-second rolling average power
        const rollingWindowSize = 30; // 30 seconds
        const rollingAvgPower = [];
        
        for (let i = 0; i < powerValues.length; i++) {
            let windowStart = Math.max(0, i - rollingWindowSize + 1);
            let sum = 0;
            for (let j = windowStart; j <= i; j++) {
                sum += powerValues[j];
            }
            rollingAvgPower.push(sum / (i - windowStart + 1));
        }
        
        // Calculate the fourth power of the rolling average
        let sumFourthPower = 0;
        for (let i = 0; i < rollingAvgPower.length - 1; i++) {
            sumFourthPower += Math.pow(rollingAvgPower[i], 4) * deltaT[i];
        }
        
        // Take the fourth root of the average of the fourth powers
        const normPower = Math.pow(sumFourthPower / durationSec, 0.25);
        
        // Calculate W' Balance Drop
        const initialWprime = wprimeBalance[0];
        let minWprimeBalance = initialWprime;
        for (let i = 0; i < wprimeBalance.length; i++) {
            if (wprimeBalance[i] < minWprimeBalance) {
                minWprimeBalance = wprimeBalance[i];
            }
        }
        const wprimeBalanceDrop = initialWprime - minWprimeBalance;
        
        // Calculate total work in kJ
        let totalWork = 0;
        for (let i = 0; i < powerValues.length - 1; i++) {
            // Power * time (in seconds) / 1000 to get kJ
            totalWork += powerValues[i] * deltaT[i] / 1000;
        }
        
        // Calculate work above CP in kJ
        let workAboveCP = 0;
        for (let i = 0; i < powerValues.length - 1; i++) {
            if (powerValues[i] > cp) {
                // (Power - CP) * time (in seconds) / 1000 to get kJ
                workAboveCP += (powerValues[i] - cp) * deltaT[i] / 1000;
            }
        }
        
        // Calculate energy expenditure from VO2 and substrate utilization
        // We'll need the RQ value to estimate caloric equivalent
        const kcalPerO2L = 4.86; // Average value when RQ is around 0.85
        
        // First, convert ml/min to L for the entire exercise duration
        let totalO2Consumption = 0;
        for (let i = 0; i < vo2Values.length - 1; i++) {
            // VO2 (ml/min) * time (min) / 1000 to get L of O2
            totalO2Consumption += vo2Values[i] * (deltaT[i] / 60) / 1000;
        }
        
        // Calculate total energy in kcal
        const totalEnergyKcal = totalO2Consumption * kcalPerO2L;
        
        // Estimate carbohydrate and fat utilization based on average RQ
        // For demonstration, we'll use an RQ of 0.9 (70% CHO, 30% Fat)
        // In reality, this should be calculated from the actual RQ values
        const assumedRQ = 0.9;
        const assumedCHOPercentage = (assumedRQ - 0.7) / 0.3 * 100; // Linear interpolation between RQ 0.7 (0% CHO) and RQ 1.0 (100% CHO)
        
        // Calculate CHO and Fat utilization
        const choEnergyKcal = totalEnergyKcal * (assumedCHOPercentage / 100);
        const fatEnergyKcal = totalEnergyKcal - choEnergyKcal;
        
        // Convert to grams using caloric equivalents
        const kcalPerGramCHO = 4.1;
        const kcalPerGramFat = 9.45;
        
        const choGrams = choEnergyKcal / kcalPerGramCHO;
        const fatGrams = fatEnergyKcal / kcalPerGramFat;
        
        // Calculate strain scores according to Kontro et al. (2025)
        // Total strain score is already calculated in the stepData
        const totalStrainScore = stepData.cumulative_strain_score[stepData.cumulative_strain_score.length - 1] || 0;
        
        // Calculate strain scores for each energy system
        // Using the formulas from the Kontro paper
        let ssCP = 0;
        let ssWprime = 0;
        let ssPmax = 0;

        // Use MPA values and energy system contributions to calculate strain scores
        for (let i = 0; i < powerValues.length - 1; i++) {
            if (i >= stepData.mpa.length - 1) break;
            
            const power = powerValues[i];
            const mpa = stepData.mpa[i];
            
            // Skip calculations for zero power periods
            if (power <= 0) continue;
            
            // Calculate strain coefficient using formula from Kontro paper
            const kstrain = (pmax - mpa + cp) / (pmax - power + cp);
            
            // Calculate energy system contributions
            let pCP, pWprime, pPmax;
            
            if (power <= cp) {
                // All energy from aerobic system
                pCP = power;
                pWprime = 0;
                pPmax = 0;
            } else {
                // Calculate Pmax contribution 
                pPmax = Math.pow(power - cp, 2) / (pmax - cp);
                
                // Calculate W' contribution
                pWprime = power - cp - pPmax;
                
                // CP contribution is just CP
                pCP = cp;
            }
            
            // Calculate strain rates for each system
            const srCP = kstrain * pCP;
            const srWprime = kstrain * pWprime;
            const srPmax = kstrain * pPmax;
            
            // Calculate strain score increments (normalized by time)
            // Convert to strain score using the normalization factor
            const normalizationFactor = (pmax / Math.pow(cp, 2)) * (100 / 3600);
            
            ssCP += srCP * (deltaT[i] / 3600) * normalizationFactor;
            ssWprime += srWprime * (deltaT[i] / 3600) * normalizationFactor;
            ssPmax += srPmax * (deltaT[i] / 3600) * normalizationFactor;
        }
    
    // Update DOM elements with calculated values
    elements.avg_power.textContent = `${Math.round(avgPower)} W`;
    elements.norm_power.textContent = `${Math.round(normPower)} W`;
    elements.wprime_drop.textContent = `${wprimeBalanceDrop.toFixed(1)} kJ`;
    elements.total_work.textContent = `${Math.round(totalWork)} kJ`;
    elements.work_above_cp.textContent = `${Math.round(workAboveCP)} kJ`;
    elements.total_energy.textContent = `${Math.round(totalEnergyKcal)} kcal`;
    elements.cho_utilization.textContent = `${Math.round(choGrams)} g`;
    elements.fat_utilization.textContent = `${Math.round(fatGrams)} g`;
    elements.total_ss.textContent = `${Math.round(totalStrainScore)}`;
    elements.ss_cp.textContent = `${Math.round(ssCP)}`;
    elements.ss_wprime.textContent = `${Math.round(ssWprime)}`;
    elements.ss_pmax.textContent = `${Math.round(ssPmax)}`;
}
        
    
       // Function to update the step test plot in Tab 2
       function updateStepTestPlot() {
        // Speichere den aktuellen Sichtbarkeitsstatus aller Kurven, wenn ein Plot existiert
        const plotContainer = document.getElementById('steptest-plot-container');
        if (plotContainer && plotContainer._fullData) {
            const existingTraces = plotContainer._fullData || [];

            for (let i = 0; i < existingTraces.length; i++) {
                if (existingTraces[i].name) {
                    appState.traceVisibility[existingTraces[i].name] = existingTraces[i].visible !== 'legendonly';
                }
            }
        }

        const stepData = calculateStepTest();

        // Use time directly in seconds
        // Add checks for potentially undefined stepData or time_sec
        const timeSec = (stepData && stepData.time_sec) ? stepData.time_sec : [0];
        if (timeSec.length === 0) {
            console.warn("No time data available for step test plot.");
             // Optionally clear the plot or show a message
             Plotly.purge('steptest-plot-container');
             // Maybe display a message in the plot container
             document.getElementById('steptest-plot-container').innerHTML = '<p style="text-align:center; padding-top:50px;">No data to display. Load data or adjust parameters.</p>';
            return; // Exit if no time data
        }


        // Determine max time for X-Axis (110% of last valid time)
        const maxTimeValue = Math.max(...timeSec) * 1.10;

        // Calculate max power value for Y-Axis - use the greater of pmax or actual max power
        const maxPowerInData = (stepData.power && stepData.power.length > 0) ? Math.max(...stepData.power.filter(p => !isNaN(p))) : 0;
        const maxMPAInData = (stepData.mpa && stepData.mpa.length > 0) ? Math.max(...stepData.mpa.filter(p => !isNaN(p))) : 0;
        const maxPowerValue = Math.max(maxPowerInData, maxMPAInData, appState.pmax) * 1.05;


        // Set lactate Y-Axis max value (initial estimate for y2)
        const maxLaktatValue = appState.la_max + 5;

        // Find the minimum W' balance value (initial estimate for y2)
        const minWprimeValue = (stepData.w_prime_bal && stepData.w_prime_bal.length > 0) ? Math.min(...stepData.w_prime_bal.filter(w => !isNaN(w))) : 0;

        // Calculate min and max PD value for Y-Axis (initial estimate for y2)
        const minPDValue = (stepData.PD && stepData.PD.length > 0) ? Math.min(...stepData.PD.filter(pd => !isNaN(pd))) : 0;
        const maxPDValue = (stepData.PD && stepData.PD.length > 0) ? Math.max(...stepData.PD.filter(pd => !isNaN(pd))) : 0;

        // Calculate max values for glycogen Y-Axis
        // const maxGlycogenValue = Math.max(appState.glycogen_max, appState.glycogen_init) * 1.1; // Not used for y2 range directly

        // Set Y-Axis limits for W' balance / Lactate axis (y2) - Initial determination based on existing logic
        const wprimeYmin = Math.max(-10, Math.min(minWprimeValue, minPDValue)); // Start range estimation
        let wprimeYmax = Math.max(maxLaktatValue, appState.w_prime, maxPDValue) * 1.05;

        // Wenn PCr-Modell aktiviert ist, Y-Achse anpassen, um PCr-Werte einzuschließen
        if (appState.show_pcr_model && stepData.pcr_store) {
             const maxPcr = (stepData.pcr_store && stepData.pcr_store.length > 0) ? Math.max(...stepData.pcr_store.filter(pcr => !isNaN(pcr))) : appState.pcr_init;
             wprimeYmax = Math.max(wprimeYmax, maxPcr * 1.05);
        }

        // Use custom Y-Axis values if set, otherwise use calculated defaults
        const usePowerMax = appState.customize_y_axis ? appState.view_power_max : maxPowerValue;
        const useVO2Max = appState.customize_y_axis ? appState.view_vo2_max : (appState.use_tab1_params ? appState.VO2max * 1.05 : appState.VO2max_step * 1.05);

        // THESE VALUES ARE USED FOR THE Y2 AXIS RANGE IN THE LAYOUT BELOW
        const useLactateMin = appState.customize_y_axis ? appState.view_lactate_min : wprimeYmin;
        const useLactateMax = appState.customize_y_axis ? appState.view_lactate_max : wprimeYmax;

        // Create traces for the plot
        const traces = [];

        // --- NEU: pHm Trace hinzufügen ---
        if (stepData.pHm) { // Check if pH data exists (model always enabled) <-- Bedingung hier geändert
            traces.push({
                x: timeSec,
                y: stepData.pHm,
                name: "pH<sub>m</sub>", // Name for the legend
                type: 'scatter',
                mode: 'lines',
                yaxis: "y2", // Plot on the same axis as Lactate, PCr, W'
                line: {color: '#FFA000', width: 1.5, dash: 'dot', opacity: 0.8},
                showlegend: true
            });
        }
        // --- ENDE NEU ---

        // Power curve
        if (stepData.power) {
            traces.push({
                x: timeSec,
                y: stepData.power,
                name: "Power",
                type: 'scatter',
                mode: 'lines',
                yaxis: "y",
                line: {color: 'darkgrey', width: 1.5, opacity: 0.8},
                showlegend: true
            });
        }

        // Cadence data if available and dependency enabled
        if (stepData.cadence && appState.cadence_dependent_step) {
            traces.push({
                x: timeSec,
                y: stepData.cadence,
                name: "Cadence",
                type: 'scatter',
                mode: 'lines',
                yaxis: "y",
                line: {color: 'lightgray', dash: 'dash', width: 1.5, opacity: 0.8},
                showlegend: true
            });
        }

        // W' Balance curve - now using y2 axis shared with lactate
        if (stepData.w_prime_bal) {
            traces.push({
                x: timeSec,
                y: stepData.w_prime_bal,
                name: "W' Balance",
                type: 'scatter',
                mode: 'lines',
                yaxis: "y2",
                line: {color: '#42BA97', width: 2, opacity: 0.8},
                showlegend: true
            });
        }

        // MPA (Maximum Power Available) curve
        if (stepData.mpa) {
            traces.push({
                x: timeSec,
                y: stepData.mpa,
                name: "MPA",
                type: 'scatter',
                mode: 'lines',
                yaxis: "y",
                line: {color: '#607D8B', width: 1.5, dash: 'dash', opacity: 0.8},
                showlegend: true
            });
        }

        // Cumulative Strain Score
        if (stepData.cumulative_strain_score) {
            traces.push({
                x: timeSec,
                y: stepData.cumulative_strain_score,
                name: "Strain Score",
                type: 'scatter',
                mode: 'lines',
                yaxis: "y", // Plotting on primary Y axis (Power) for now
                line: {color: '#F06292', width: 1.5, opacity: 0.8},
                showlegend: true
            });
        }

        // VO2 curve
        if (stepData.VO2) {
            traces.push({
                x: timeSec,
                y: stepData.VO2,
                name: "V̇O<sub>2</sub>",
                type: 'scatter',
                mode: 'lines',
                yaxis: "y3",
                line: {color: '#2683C6', width: 1.5, opacity: 0.8},
                showlegend: true
            });
        }

        // VO2 demand curve and fill area, only if PCr model is enabled and VO2 demand display is checked
        if (appState.show_vo2_demand && stepData.vo2_demand && stepData.VO2) { // <-- Bedingung hier geändert
            // VO2 demand curve - dotted line with the same color as VO2
            traces.push({
                x: timeSec,
                y: stepData.vo2_demand,
                name: "V̇O<sub>2</sub> Demand",
                type: 'scatter',
                mode: 'lines',
                yaxis: "y3",
                line: {color: '#2683C6', dash: 'dot', width: 1.5},
                showlegend: true
            });

            // Area fill between VO2 demand and actual VO2
            traces.push({
                x: [...timeSec, ...timeSec.slice().reverse()],
                y: [...stepData.vo2_demand, ...stepData.VO2.slice().reverse()],
                name: "O<sub>2</sub> Deficit Area",
                type: 'scatter',
                mode: 'none',
                yaxis: "y3",
                fill: 'toself',
                fillcolor: 'rgba(38, 131, 198, 0.2)',
                line: {width: 0},
                showlegend: true
            });
        }

        // Lactate accumulation
        if (stepData.La_conc) {
            traces.push({
                x: timeSec,
                y: stepData.La_conc,
                name: "Lactate",
                type: 'scatter',
                mode: 'lines',
                yaxis: "y2",
                line: {color: '#C8133B', width: 2, opacity: 0.8},
                showlegend: true
            });
        }

        // vLass curve
        if (stepData.vLass_min) {
            traces.push({
                x: timeSec,
                y: stepData.vLass_min,
                name: "vLa<sub>SS</sub>",
                type: 'scatter',
                mode: 'lines',
                yaxis: "y2",
                line: {color: '#EF5350', dash: 'dash', width: 1.5, opacity: 0.8},
                showlegend: true
            });
        }

        // vLaox curve
        if (stepData.vLaox_min) {
            traces.push({
                x: timeSec,
                y: stepData.vLaox_min,
                name: "vLa<sub>ox</sub>",
                type: 'scatter',
                mode: 'lines',
                yaxis: "y2",
                line: {color: '#1CADE4', dash: 'dash', width: 1.5, opacity: 0.8},
                showlegend: true
            });
        }

        // Pyruvate deficit (PD) curve
        if (stepData.PD) {
            traces.push({
                x: timeSec,
                y: stepData.PD,
                name: "PD",
                type: 'scatter',
                mode: 'lines',
                yaxis: "y2",
                line: {color: '#9C85C0', width: 1.5, opacity: 0.8},
                showlegend: true
            });
        }

        // Glycogen Store Curve
        if (stepData.glycogen_store) {
            traces.push({
                x: timeSec,
                y: stepData.glycogen_store,
                name: "Glycogen Stores",
                type: 'scatter',
                mode: 'lines',
                yaxis: "y",
                line: {color: '#AD1457', dash: 'dot', width: 2, opacity: 0.8},
                showlegend: true
            });
        }

        // Add PCr and O2 deficit traces if data exists (model always enabled now)
        if (stepData.pcr_store && stepData.accumulated_o2_deficit) { // <-- Bedingung hier geändert
            // PCr store curve on y2 axis (same as lactate)
            traces.push({
                x: timeSec,
                y: stepData.pcr_store,
                name: "PCr Store",
                type: 'scatter',
                mode: 'lines',
                yaxis: "y2",
                line: {color: '#CDDC39', dash: 'dot', width: 2, opacity: 0.8},
                showlegend: true
            });

        // Accumulated O2 deficit on y3 axis (same as VO2)
        traces.push({
                x: timeSec,
                y: stepData.accumulated_o2_deficit,
                name: "Acc. O<sub>2</sub> Deficit",
                type: 'scatter',
                mode: 'lines',
                yaxis: "y3",
                line: {color: '#0097A7', dash: 'dot', width: 1.5, opacity: 0.8},
                showlegend: true
            });
        }

        // Zero line for W' balance reference
        if (timeSec.length > 0) {
            traces.push({
                x: [Math.min(...timeSec), Math.max(...timeSec)],
                y: [0, 0],
                name: "Zero Line",
                type: 'scatter',
                mode: 'lines',
                yaxis: "y2",
                line: {color: '#666666', dash: 'dot', width: 1, opacity: 0.4},
                showlegend: false
            });
        }

        // Annotations for abort criteria if reached
        const annotations = [];
        if (stepData.abort_power !== null) {
            let abortText = `Abort at ${Math.round(stepData.abort_power)} W, ${Math.floor(stepData.abort_time/60)}:${(stepData.abort_time % 60).toString().padStart(2, '0')} min:s`;

            annotations.push({
                x: stepData.abort_time,
                y: stepData.abort_power,
                yref: "y",
                text: abortText,
                showarrow: true,
                arrowhead: 2,
                arrowsize: 1,
                arrowwidth: 2,
                arrowcolor: '#666666',
                ax: 0,
                ay: -25
            });

            // Annotation for abort reason
            switch(stepData.abort_reason) {
                case "lactate":
                    annotations.push({
                        x: stepData.abort_time,
                        y: appState.la_max,
                        yref: "y2",
                        text: `Lactate: ${appState.la_max.toFixed(1)} mmol·l<sup>-1</sup>`,
                        showarrow: true,
                        arrowhead: 2,
                        arrowsize: 1,
                        arrowwidth: 2,
                        arrowcolor: '#C8133B',
                        ax: 20,
                        ay: 0
                    });
                    break;
                case "wbalance":
                    annotations.push({
                        x: stepData.abort_time,
                        y: appState.w_prime_balance_min,
                        yref: "y2",
                        text: `W' Balance: ${appState.w_prime_balance_min.toFixed(1)} kJ`,
                        showarrow: true,
                        arrowhead: 2,
                        arrowsize: 1,
                        arrowwidth: 2,
                        arrowcolor: '#42BA97',
                        ax: 20,
                        ay: 0
                    });
                    break;
                case "glycogen":
                    annotations.push({
                        x: stepData.abort_time,
                        y: 0,
                        yref: "y", // Changed to y-axis (primary) for glycogen
                        text: `Glycogen Depleted`,
                        showarrow: true,
                        arrowhead: 2,
                        arrowsize: 1,
                        arrowwidth: 2,
                        arrowcolor: '#AD1457',
                        ax: 20,
                        ay: -20 // Adjusted position slightly
                    });
                    break;
            }
        }

        // Formula text for CE relationship
        let formulaText = '';
        const effectiveVO2Base = appState.use_tab1_params ? appState.VO2Base : appState.VO2Base_step;

        if (stepData.is_curvilinear) {
            formulaText = `V̇O<sub>2,SS</sub> (P) = ${stepData.a_opt ? stepData.a_opt.toFixed(4) : 'N/A'} · P² + ${stepData.ce_range[0].toFixed(1)} · P + ${Math.round(effectiveVO2Base)}`;
        } else {
            const effectiveCE = appState.use_tab1_params ? appState.CEVO2 : appState.CEVO2_step;
            formulaText = `V̇O<sub>2,SS</sub> (P) = ${effectiveCE.toFixed(1)} · P + ${Math.round(effectiveVO2Base)}`;
        }

        // Add cadence info if cadence dependency is enabled
        if (appState.cadence_dependent_step) {
            // Determine which cadence to display (fixed or file-based)
            const cadenceSource = appState.use_file_cadence ? "file" : `${appState.cadence_step} rpm`;
             formulaText += `<br>(at cadence: ${cadenceSource})`;
        }

        // Add formula annotation only if data exists
        if (timeSec.length > 0) {
            annotations.push({
                x: (timeSec.length > 1 ? timeSec[Math.floor(timeSec.length * 0.1)] : timeSec[0]), // Position near start
                y: (appState.use_tab1_params ? appState.VO2max * 0.90 : appState.VO2max_step * 0.90), // Position high on VO2 axis
                text: formulaText,
                showarrow: false,
                font: {
                    family: "Arial",
                    size: 10, // Slightly smaller for potentially longer text
                    color: "#666666"
                },
                xanchor: "left",
                yanchor: "top",
                yref: "y3" // Referencing VO2 axis
            });
        }

        // Create layout for the plot
        let layout = {
            title: {
                text: "Exercise Simulation",
                font: {
                    size: 18,
                    color: '#2683C6'
                }
            },
            margin: {l: 80, r: 80, t: 90, b: 80},
            xaxis: {
                title: {
                    text: "Time (s)",
                    font: {
                        size: 14
                    }
                },
                range: [appState.customize_time_window ? appState.view_time_start : Math.min(...timeSec),
                        appState.customize_time_window ? appState.view_time_end : maxTimeValue],
                showgrid: true,
                gridcolor: 'rgba(200,200,200,0.2)'
            },
            yaxis: {
                title: {
                    text: "Power (W) / Cadence (rpm) / Glycogen (g) / MPA / SS", // Original Title
                    font: {
                        size: 12 // Original size or adjust if needed
                    }
                },
                range: [0, usePowerMax],
                showgrid: true,
                gridcolor: 'rgba(200,200,200,0.2)',
                side: 'left'
            },
            yaxis2: {
                title: {
                    text: "Lactate, Rates, PCr, W', pH<sub>m</sub>", // NEU: pHm im Titel
                    font: {
                         size: 12 // Ggf. Schriftgröße anpassen
                    }
                },
                overlaying: "y",
                side: "right",
                range: [useLactateMin, useLactateMax], // Originale Range-Berechnung beibehalten
                showgrid: false,
                 zeroline: true, // NEU: Explizite Nulllinie für y2
                 zerolinecolor: '#cccccc',
                 zerolinewidth: 1
            },
            yaxis3: {
                title: {
                    text: "V̇O<sub>2</sub> (ml·min⁻¹) & O<sub>2</sub> Deficit (ml)",
                    font: {
                        size: 14
                    }
                },
                overlaying: "y",
                side: "right",
                anchor: "free",
                position: 0.93, // Positioned slightly left of yaxis2
                range: [0, useVO2Max],
                showgrid: false
            },
            showlegend: true,
                legend: {
                x: 0.5,
                y: 1.10,
                xanchor: 'center',
                yanchor: 'top',
                orientation: 'h',
                bgcolor: 'rgba(255, 255, 255, 0)',
                bordercolor: 'rgba(0,0,0,0)',
                borderwidth: 0
            },
            annotations: annotations,
            paper_bgcolor: 'rgba(255,255,255,0)',
            plot_bgcolor: 'rgba(255,255,255,0.5)',
            hovermode: 'closest'
        };

        // Wende den gespeicherten Sichtbarkeitsstatus auf die neuen Traces an
        for (let i = 0; i < traces.length; i++) {
            if (traces[i].name && appState.traceVisibility[traces[i].name] === false) {
                traces[i].visible = 'legendonly';
            }
        }

        // Standardmäßig bestimmte Kurven ausblenden, wenn keine gespeicherten Einstellungen vorhanden sind
        if (Object.keys(appState.traceVisibility).length === 0) {
            // Liste der Kurven, die standardmäßig ausgeblendet sein sollen
            // NEU: pHm zur Liste hinzugefügt
            const hiddenTraces = ["PD", "Acc. O<sub>2</sub> Deficit", "Strain Score", "Glycogen Stores", "W' Balance", "MPA"]; // "vLa<sub>SS</sub>", "vLa<sub>ox</sub>", 
        
            for (let i = 0; i < traces.length; i++) {
                if (traces[i].name && hiddenTraces.includes(traces[i].name)) {
                    traces[i].visible = 'legendonly';
                    appState.traceVisibility[traces[i].name] = false; // Store initial hidden state
                } else if (traces[i].name && !(traces[i].name in appState.traceVisibility)) {
                     appState.traceVisibility[traces[i].name] = true; // Store initial visible state
                }
            }
        }

        // Erstelle den Plot mit den aktualisierten Traces
        Plotly.newPlot('steptest-plot-container', traces, layout, {
            displayModeBar: true,
            responsive: true
        });

        // Update exercise summary statistics
        updateExerciseSummary(stepData);
    }
    

    // Function to show notification
    function showNotification(message, type = 'info') {
        elements.notification.innerHTML = message;
        elements.notification.className = `notification ${type}`;
        elements.notification.style.display = 'block';
        
        // Hide after 3 seconds
        setTimeout(() => {
            elements.notification.style.display = 'none';
        }, 3000);
    }
    
    // Function to update Critical Power from MLSS
    function updateCriticalPowerFromMlss() {
        if (appState.use_mlss_as_cp && appState.mlss_value) {
            appState.critical_power = appState.mlss_value;
            elements.critical_power.value = appState.mlss_value;
            elements.critical_powerValue.textContent = appState.mlss_value;
            
            // Disable the slider if the checkbox is checked
            elements.critical_power.disabled = true;
        }
    }
    
    // Function to calculate delta efficiency (Δη) from CE value
    function calculateDeltaEfficiency(ceValue, rq = null) {
        if (rq !== null) {
            // If RQ is provided, use specific caloric equivalent
            const kalorischesEquivalent = getKalorischesEquivalent(rq);
            const eta = 1 / ((ceValue * kalorischesEquivalent.kJ_lO2) / 60);
            return {
                min: eta * 100,
                max: eta * 100
            };
        } else {
            // Without RQ, use the range approach
            // Caloric equivalent range based on RQ values
            const calorEquivalentMin = 21.131; // Lower bound
            const calorEquivalentMax = 19.619; // Upper bound
            
            // Calculate efficiency range (expressed as decimal)
            const etaMin = 1 / ((ceValue * calorEquivalentMin) / 60);
            const etaMax = 1 / ((ceValue * calorEquivalentMax) / 60);
            
            // Return range as percentage values
            return {
                min: etaMin * 100,
                max: etaMax * 100
            };
        }
    }

    // Function to calculate RQ based on carbohydrate percentage
    function calculateRQ(carbPercentage) {
        // Linear relationship: 0% CHO = 0.70 RQ, 100% CHO = 1.00 RQ
        return 0.70 + (carbPercentage / 100) * 0.30;
    }

    // Function to get caloric equivalent based on RQ using Stegemann's table
    function getKalorischesEquivalent(rq) {
        // Stegemann data (1990)
        const stegemann = {
            rq: [0.700, 0.710, 0.720, 0.730, 0.740, 0.750, 0.760, 0.770, 0.780, 0.790, 
                0.800, 0.810, 0.820, 0.830, 0.840, 0.850, 0.860, 0.870, 0.880, 0.890, 
                0.900, 0.910, 0.920, 0.930, 0.940, 0.950, 0.960, 0.970, 0.980, 0.990, 1.000],
            kJ_lO2: [19.619, 19.636, 19.686, 19.737, 19.791, 19.841, 19.887, 19.946, 20.009, 20.046, 
                    20.101, 20.151, 20.201, 20.256, 20.306, 20.356, 20.411, 20.461, 20.515, 20.561, 
                    20.616, 20.666, 20.716, 20.771, 20.821, 20.871, 20.926, 20.976, 21.026, 21.081, 21.131],
            kcal_lO2: [4.686, 4.690, 4.702, 4.714, 4.727, 4.739, 4.750, 4.764, 4.779, 4.788, 
                    4.801, 4.813, 4.825, 4.838, 4.850, 4.862, 4.875, 4.887, 4.900, 4.911, 
                    4.924, 4.936, 4.948, 4.961, 4.973, 4.985, 4.998, 5.010, 5.022, 5.035, 5.047]
        };
    
    // Ensure RQ is within valid range
    const boundedRQ = Math.max(0.70, Math.min(1.00, rq));
    
    // Find closest RQ value in table
    let closestIdx = 0;
    let minDiff = Math.abs(boundedRQ - stegemann.rq[0]);
    
    for (let i = 1; i < stegemann.rq.length; i++) {
        const diff = Math.abs(boundedRQ - stegemann.rq[i]);
        if (diff < minDiff) {
            minDiff = diff;
            closestIdx = i;
        }
    }
    
    // Return both kJ and kcal values
    return {
        kJ_lO2: stegemann.kJ_lO2[closestIdx],
        kcal_lO2: stegemann.kcal_lO2[closestIdx]
    };
}

// Function to calculate efficiency values
function calculateEfficiency(power, vo2, rq, vo2base) {
    // Get caloric equivalent based on RQ
    const kalorischesEquivalent = getKalorischesEquivalent(rq);
    
    // Power in watts = J/s
    const powerKJ_min = power * 0.06; // Convert W to kJ/min (W * 60s / 1000)
    
    // VO2 in L/min
    const vo2L_min = vo2 / 1000;
    
    // Energy expenditure in kJ/min
    const energyExpenditure = vo2L_min * kalorischesEquivalent.kJ_lO2;
    
    // Gross efficiency (η_gross): Power output / Total energy expenditure
    const grossEfficiency = (powerKJ_min / energyExpenditure) * 100;
    
    // Net efficiency (η_net): Power output / (Total energy expenditure - Resting energy expenditure)
    const vo2baseL_min = vo2base / 1000;
    const restingEnergy = vo2baseL_min * kalorischesEquivalent.kJ_lO2;
    const netEfficiency = (powerKJ_min / (energyExpenditure - restingEnergy)) * 100;
    
    return {
        gross: grossEfficiency,
        net: netEfficiency,
        delta: 1 / ((vo2L_min / (power / 60)) * kalorischesEquivalent.kJ_lO2 / 60) * 100
    };
}

    
    
    // Event handlers for Tab 1
    elements.CEVO2.addEventListener('input', function() {
        appState.CEVO2 = parseFloat(this.value);
        elements.CEVO2Value.textContent = appState.CEVO2.toFixed(1);
        
        // Calculate and update delta efficiency
        const deltaEta = calculateDeltaEfficiency(appState.CEVO2);
        document.getElementById('delta-eta-value').textContent = 
            `${deltaEta.min.toFixed(1)}-${deltaEta.max.toFixed(1)}%`;
        
        // Synchronize with Tab 2 if parameters are linked
        if (appState.use_tab1_params) {
            appState.CEVO2_step = appState.CEVO2;
            elements.CEVO2_step.value = appState.CEVO2;
            elements.CEVO2_stepValue.textContent = appState.CEVO2.toFixed(1);
        }
        
        // Update plot and critical power
        updatePlot();
        updateStepTestPlot();
    });
    
    elements.CE_range_start.addEventListener('input', function() {
        appState.CE_range[0] = parseFloat(this.value);
        elements.CE_range_startValue.textContent = appState.CE_range[0].toFixed(1);
        updatePlot();
        
        // Synchronize with Tab 2 if parameters are linked
        if (appState.use_tab1_params) {
            appState.CE_range_step[0] = appState.CE_range[0];
            elements.CE_range_start_step.value = appState.CE_range[0];
            elements.CE_range_start_stepValue.textContent = appState.CE_range[0].toFixed(1);
            updateStepTestPlot();
        }
    });
    
    elements.CE_range_end.addEventListener('input', function() {
        appState.CE_range[1] = parseFloat(this.value);
        elements.CE_range_endValue.textContent = appState.CE_range[1].toFixed(1);
        updatePlot();
        
        // Synchronize with Tab 2 if parameters are linked
        if (appState.use_tab1_params) {
            appState.CE_range_step[1] = appState.CE_range[1];
            elements.CE_range_end_step.value = appState.CE_range[1];
            elements.CE_range_end_stepValue.textContent = appState.CE_range[1].toFixed(1);
            updateStepTestPlot();
        }
    });
    
    elements.VO2max.addEventListener('input', function() {
        appState.VO2max = parseFloat(this.value);
        elements.VO2maxValue.textContent = appState.VO2max.toFixed(0);
        // Update relative VO2max
        appState.VO2max_kg = appState.VO2max / appState.body_mass;
        elements.VO2max_kgValue.textContent = appState.VO2max_kg.toFixed(2);
        
        // Synchronize with Tab 2 if parameters are linked
        if (appState.use_tab1_params) {
            appState.VO2max_step = appState.VO2max;
            elements.VO2max_step.value = appState.VO2max;
            elements.VO2max_stepValue.textContent = appState.VO2max.toFixed(0);
        }
        
        updatePlot();
        updateStepTestPlot();
    });
    
    elements.VO2max_kg.addEventListener('input', function() {
        appState.VO2max_kg = parseFloat(this.value);
        elements.VO2max_kgValue.textContent = appState.VO2max_kg.toFixed(2);
        // Update absolute VO2max
        appState.VO2max = appState.VO2max_kg * appState.body_mass;
        elements.VO2max.value = appState.VO2max;
        elements.VO2maxValue.textContent = appState.VO2max.toFixed(0);
        
        // Synchronize with Tab 2 if parameters are linked
        if (appState.use_tab1_params) {
            appState.VO2max_step = appState.VO2max;
            elements.VO2max_step.value = appState.VO2max;
            elements.VO2max_stepValue.textContent = appState.VO2max.toFixed(0);
        }
        
        updatePlot();
        updateStepTestPlot();
    });
    
    elements.VO2Base.addEventListener('input', function() {
        appState.VO2Base = parseFloat(this.value);
        elements.VO2BaseValue.textContent = appState.VO2Base.toFixed(0);
        
        // Synchronize with Tab 2 if parameters are linked
        if (appState.use_tab1_params) {
                    appState.VO2Base_step = appState.VO2Base;
                    elements.VO2Base_step.value = appState.VO2Base;
                    elements.VO2Base_stepValue.textContent = appState.VO2Base.toFixed(0);

                    // *** NEU START ***
                    // Update vo2_start slider constraints and clamp value
                    const base = appState.VO2Base;
                    const maxVal = appState.VO2max;
                    elements.vo2_start.min = base;
                    elements.vo2_start.max = maxVal; // Max bleibt gleich, nur Base ändert sich hier
                    if (appState.vo2_start < base) {
                        appState.vo2_start = base;
                        elements.vo2_start.value = appState.vo2_start;
                        elements.vo2_startValue.textContent = appState.vo2_start;
                    }
                    // *** NEU ENDE ***
                }

                updatePlot();
                updateStepTestPlot();
            });
    
    elements.vLamax.addEventListener('input', function() {
        appState.vLamax = parseFloat(this.value);
        elements.vLamaxValue.textContent = appState.vLamax.toFixed(2);
        
        // Synchronize with Tab 2 if parameters are linked
        if (appState.use_tab1_params) {
            appState.vLamax_step = appState.vLamax;
            elements.vLamax_step.value = appState.vLamax;
            elements.vLamax_stepValue.textContent = appState.vLamax.toFixed(2);
        }
        
        updatePlot();
        updateStepTestPlot();
    });
    
    elements.body_mass.addEventListener('input', function() {
        appState.body_mass = parseFloat(this.value);
        elements.body_massValue.textContent = appState.body_mass.toFixed(1);
        
        // Update relative VO2max if weight changes
        appState.VO2max_kg = appState.VO2max / appState.body_mass;
        elements.VO2max_kg.value = appState.VO2max_kg;
        elements.VO2max_kgValue.textContent = appState.VO2max_kg.toFixed(2);
        
        // Synchronize with Tab 2 if parameters are linked
        if (appState.use_tab1_params) {
            appState.body_mass_step = appState.body_mass;
            elements.body_mass_step.value = appState.body_mass;
            elements.body_mass_stepValue.textContent = appState.body_mass.toFixed(1);
        }
        
        updatePlot();
        updateStepTestPlot();
    });
    
    elements.age.addEventListener('input', function() {
        appState.age = parseInt(this.value);
        elements.ageValue.textContent = appState.age;
    });
    
    elements.height.addEventListener('input', function() {
        appState.height = parseInt(this.value);
        elements.heightValue.textContent = appState.height;
    });
    
    elements.male.addEventListener('change', function() {
        if (this.checked) {
            appState.gender = 'Male';
        }
    });
    
    elements.female.addEventListener('change', function() {
        if (this.checked) {
            appState.gender = 'Female';
        }
    });
    
    elements.curvilinear.addEventListener('change', function() {
        appState.curvilinear = this.checked;
        
        // Only show/hide CE controls if cadence dependency is not enabled
        if (!appState.cadence_dependent) {
            elements.linearCeControl.style.display = this.checked ? 'none' : 'block';
        } else {
            elements.linearCeControl.style.display = 'none'; // Always hidden when cadence dependency is on
        }
        
        elements.curvilinearCeControl.style.display = this.checked ? 'block' : 'none';
        
        // Synchronize with Tab 2 if parameters are linked
        if (appState.use_tab1_params) {
            appState.curvilinear_step = appState.curvilinear;
            elements.curvilinear_step.checked = appState.curvilinear;
            elements.linearCeControlStep.style.display = appState.curvilinear ? 'none' : 'block';
            elements.curvilinearCeControlStep.style.display = appState.curvilinear ? 'block' : 'none';
        }
        
        updatePlot();
        updateStepTestPlot();
    });
    
    // Substrate Utilization Event Handlers
    elements.show_substrate.addEventListener('change', function() {
        appState.show_substrate = this.checked;
        elements.substrate_plot_container.style.display = this.checked ? 'block' : 'none';
        elements.substrate_controls.style.display = this.checked ? 'block' : 'none';
        elements.substrate_info.style.display = this.checked ? 'block' : 'none';
        updatePlot();
        
        if (this.checked) {
            // Show notification about substrate feature
            showNotification("Substrate utilization visualization enabled. Additional plot shows the percentage breakdown between fat and carbohydrate usage.", 'info');
        }
    });
    
    elements.energy_unit.addEventListener('change', function() {
        appState.energy_unit = this.value;
        updatePlot();
        updateSubstratePlot();
    });
    
    elements.show_kh_adjust.addEventListener('change', function() {
        appState.show_kh_adjust = this.checked;
        elements.kh_adjust_control.style.display = this.checked ? 'block' : 'none';
        updatePlot();
        updateSubstratePlot();
    });
    
    elements.rest_kh_percentage.addEventListener('input', function() {
        appState.rest_kh_percentage = parseFloat(this.value);
        elements.rest_kh_percentageValue.textContent = appState.rest_kh_percentage;
        updatePlot();
        updateSubstratePlot();
    });
    
    // Swap axes event handler removed as per request
    // The functionality still exists in the code but is not accessible from UI
    
    elements.cadence_dependent.addEventListener('change', function() {
        appState.cadence_dependent = this.checked;
        elements.cadenceControls.style.display = appState.cadence_dependent ? 'block' : 'none';
        
        // Show/hide the linear CE control based on both cadence and curvilinear settings
        if (this.checked) {
            elements.linearCeControl.style.display = 'none';
        } else if (!appState.curvilinear) {
            elements.linearCeControl.style.display = 'block';
        }
        
        updatePlot();
        
        if (this.checked) {
            // Show notification about cadence dependency
            showNotification(`Cadence dependency enabled at ${appState.cadence} rpm. Using model from Dunst et al. (2025) with CE = ${calculateCadenceDependentCEVO2(appState.cadence).toFixed(2)} ml·min⁻¹·W⁻¹ and V̇O<sub>2,Base</sub> = ${Math.round(calculateCadenceDependentVO2Base(appState.cadence))} ml·min⁻¹`, 'info');
        }
    });
    
    elements.cadence.addEventListener('input', function() {
        appState.cadence = parseInt(this.value);
        elements.cadenceValue.textContent = appState.cadence;
        
        // Update delta efficiency value based on cadence-dependent CE
        if (appState.cadence_dependent) {
            const effectiveCE = calculateCadenceDependentCEVO2(appState.cadence);
            const deltaEta = calculateDeltaEfficiency(effectiveCE);
            document.getElementById('delta-eta-value').textContent = 
                `${deltaEta.min.toFixed(1)}-${deltaEta.max.toFixed(1)}%`;
        }
        
        updatePlot();
    });
    
    elements.vo2max_dependent.addEventListener('change', function() {
        appState.vo2max_dependent = this.checked;
        updatePlot();
        
        if (this.checked && appState.cadence_dependent) {
            showNotification(`V̇O<sub>2,max</sub> cadence dependency enabled. This feature is based on Fig.4 from Dunst et al. (2025).`, 'info');
        }
    });
    
    elements.vlamax_dependent.addEventListener('change', function() {
        appState.vlamax_dependent = this.checked;
        updatePlot();
        
        if (this.checked && appState.cadence_dependent) {
            showNotification(`vLa<sub>max</sub> cadence dependency enabled. The paper suggests this may reflect testing methodology rather than true physiological changes.`, 'warning');
        }
    });
    
    elements.weight_based.addEventListener('change', function() {
        appState.weight_based = this.checked;
        updatePlot();
        updateStepTestPlot();
    });
    
    elements.lock_y_axis.addEventListener('change', function() {
        appState.lock_y_axis = this.checked;
        updatePlot();
    });
    
    elements.lock_x_axis.addEventListener('change', function() {
        appState.lock_x_axis = this.checked;
        updatePlot();
    });
    
    elements.calculate_vo2base.addEventListener('click', function() {
        // Calculate BMR in kcal/day
        const bmr = calculateBMR(appState.gender, appState.body_mass, appState.height, appState.age);
        
        // Convert to VO2 in ml/min
        const calculatedVO2Base = calculateVO2Base(bmr, appState.gender);
        appState.calculated_vo2base = calculatedVO2Base;
        
        // Update VO2Base value
        appState.VO2Base = Math.round(calculatedVO2Base);
        elements.VO2Base.value = appState.VO2Base;
        elements.VO2BaseValue.textContent = appState.VO2Base.toFixed(0);
        
        // Synchronize with Tab 2 if parameters are linked
        if (appState.use_tab1_params) {
            appState.VO2Base_step = appState.VO2Base;
            elements.VO2Base_step.value = appState.VO2Base;
            elements.VO2Base_stepValue.textContent = appState.VO2Base.toFixed(0);
        }
        
        // Show notification
        showNotification(`V̇O<sub>2,Base</sub> calculated: ${Math.round(calculatedVO2Base)} ml·min⁻¹`, 'info');
        
        // Update plot and critical power
        updatePlot();
        updateStepTestPlot();
    });
    
    // Auto-calculate glycogen values based on muscle mass
    elements.auto_glycogen.addEventListener('change', function() {
        appState.auto_glycogen = this.checked;
        
        if (this.checked) {
            // Calculate recommended glycogen values
            const glycogenValues = calculateGlycogenValues();
            
            // Update glycogen values
            appState.glycogen_init = glycogenValues.initialGlycogen;
            appState.glycogen_max = glycogenValues.maxGlycogen;
            
            // Update UI
            elements.glycogen_init.value = appState.glycogen_init;
            elements.glycogen_initValue.textContent = appState.glycogen_init;
            elements.glycogen_max.value = appState.glycogen_max;
            elements.glycogen_maxValue.textContent = appState.glycogen_max;
            
            showNotification(`Glycogen values calculated: Initial ${glycogenValues.initialGlycogen}g, Max ${glycogenValues.maxGlycogen}g based on ${appState.active_muscle_mass.toFixed(1)}kg muscle mass`, 'info');
            
            updateStepTestPlot();
        }
    });
    
    // Tab 2 Event Handlers - Step Test Simulation
    elements.step_watt.addEventListener('input', function() {
        appState.step_watt = parseFloat(this.value);
        elements.step_wattValue.textContent = appState.step_watt;
        updateStepTestPlot();
    });
    
    elements.step_duration.addEventListener('input', function() {
        appState.step_duration = parseFloat(this.value);
        elements.step_durationValue.textContent = appState.step_duration;
        updateStepTestPlot();
    });
    
    elements.max_power_step.addEventListener('input', function() {
        appState.max_power_step = parseFloat(this.value);
        elements.max_power_stepValue.textContent = appState.max_power_step;
        updateStepTestPlot();
    });
    
    elements.vo2_up_time_constant.addEventListener('input', function() {
        appState.vo2_up_time_constant = parseFloat(this.value);
        elements.vo2_up_time_constantValue.textContent = appState.vo2_up_time_constant;
        updateStepTestPlot(); 
    });
    
    elements.vo2_down_time_constant.addEventListener('input', function() {
        appState.vo2_down_time_constant = parseFloat(this.value);
        elements.vo2_down_time_constantValue.textContent = appState.vo2_down_time_constant;
            updateStepTestPlot();
    });

    elements.vo2_down_time_constant.addEventListener('input', function() {
        appState.vo2_down_time_constant = parseFloat(this.value);
        elements.vo2_down_time_constantValue.textContent = appState.vo2_down_time_constant;
        // No need to change behavior here, calculateStepTest handles the logic
        updateStepTestPlot();
    });

    // --- START: Listener for Dynamic Tau_Off Checkbox ---
    elements.dynamic_tau_off.addEventListener('change', function() {
        appState.dynamic_tau_off = this.checked;

        if (this.checked) {
            // Set slider to default value for 50% intensity (0.45*50+10 = 32.5, rounded to 33)
            const default_tau_at_50 = 33;
            appState.vo2_down_time_constant = default_tau_at_50;
            elements.vo2_down_time_constant.value = default_tau_at_50;
            elements.vo2_down_time_constantValue.textContent = default_tau_at_50;
            showNotification("Intensity-dependent τ_off enabled. Slider sets τ_off at 50% intensity.", 'info');
        } else {
            showNotification("Intensity-dependent τ_off disabled. Slider sets fixed τ_off.", 'info');
            // Keep the current slider value when disabling, no action needed on value itself
        }
        updateStepTestPlot(); // Recalculate with new mode
    });
    
    elements.la_max.addEventListener('input', function() {
        appState.la_max = parseFloat(this.value);
        elements.la_maxValue.textContent = appState.la_max.toFixed(1);
        updateStepTestPlot();
    });
    
    elements.la_base.addEventListener('input', function() {
        appState.la_base = parseFloat(this.value);
        elements.la_baseValue.textContent = appState.la_base.toFixed(1);
        updateStepTestPlot();
    });

    elements.vLass_on_tau.addEventListener('input', function() {
        appState.vLass_on_tau = parseFloat(this.value);
        elements.vLass_on_tauValue.textContent = appState.vLass_on_tau;
        updateStepTestPlot(); // Recalculate simulation
    });

    elements.vLass_off_tau.addEventListener('input', function() {
        appState.vLass_off_tau = parseFloat(this.value);
        elements.vLass_off_tauValue.textContent = appState.vLass_off_tau;
        updateStepTestPlot(); // Recalculate simulation
    });
    
    // Glycogen Storage Event Handlers
    elements.glycogen_init.addEventListener('input', function() {
        appState.glycogen_init = parseFloat(this.value);
        elements.glycogen_initValue.textContent = appState.glycogen_init;
        updateStepTestPlot();
    });
    
    elements.glycogen_max.addEventListener('input', function() {
        appState.glycogen_max = parseFloat(this.value);
        elements.glycogen_maxValue.textContent = appState.glycogen_max;
        updateStepTestPlot();
    });
    
    elements.carb_intake_rate.addEventListener('input', function() {
        appState.carb_intake_rate = parseFloat(this.value);
        elements.carb_intake_rateValue.textContent = appState.carb_intake_rate;
        updateStepTestPlot();
    });
    
    elements.critical_power.addEventListener('input', function() {
        // Only update if not linked to MLSS
        if (!appState.use_mlss_as_cp) {
            appState.critical_power = parseFloat(this.value);
            elements.critical_powerValue.textContent = appState.critical_power;
            updateStepTestPlot();
        } else {
            // Reset to MLSS value if linked
            this.value = appState.mlss_value;
            showNotification("CP is linked to MLSS. Uncheck option to change manually.", 'info');
        }
    });
    
    elements.w_prime.addEventListener('input', function() {
        appState.w_prime = parseFloat(this.value);
        elements.w_primeValue.textContent = appState.w_prime.toFixed(1);
        updateStepTestPlot();
    });

    elements.pmax.addEventListener('input', function() {
    appState.pmax = parseFloat(this.value);
    elements.pmaxValue.textContent = appState.pmax;
    updateStepTestPlot();
    });
    
    elements.w_prime_balance_min.addEventListener('input', function() {
        appState.w_prime_balance_min = parseFloat(this.value);
        elements.w_prime_balance_minValue.textContent = appState.w_prime_balance_min.toFixed(1);
        updateStepTestPlot();
    });
    
    elements.use_w_prime_balance_abort.addEventListener('change', function() {
        appState.use_w_prime_balance_abort = this.checked;
        updateStepTestPlot();
    });
    
// PCr Model Event Handlers


    elements.pcr_init.addEventListener('input', function() {
        appState.pcr_init = parseFloat(this.value);
        elements.pcr_initValue.textContent = appState.pcr_init.toFixed(1);
        if (appState.show_pcr_model) {
            updateStepTestPlot();
        }
    });
    
    elements.p_o_ratio.addEventListener('input', function() {
        appState.p_o_ratio = parseFloat(this.value);
        elements.p_o_ratioValue.textContent = appState.p_o_ratio.toFixed(2);
        if (appState.show_pcr_model) {
            updateStepTestPlot();
        }
    });
    
    elements.active_muscle_mass.addEventListener('input', function() {
        appState.active_muscle_mass = parseFloat(this.value);
        elements.active_muscle_massValue.textContent = appState.active_muscle_mass.toFixed(1);
        
        // If auto-calculate glycogen is enabled, update glycogen values
        if (appState.auto_glycogen) {
            const glycogenValues = calculateGlycogenValues();
            appState.glycogen_init = glycogenValues.initialGlycogen;
            appState.glycogen_max = glycogenValues.maxGlycogen;
            elements.glycogen_init.value = appState.glycogen_init;
            elements.glycogen_initValue.textContent = appState.glycogen_init;
            elements.glycogen_max.value = appState.glycogen_max;
            elements.glycogen_maxValue.textContent = appState.glycogen_max;
        }
        
        if (appState.show_pcr_model) {
            updateStepTestPlot();
        }
    });
    
    elements.show_vo2_demand.addEventListener('change', function() {
        appState.show_vo2_demand = this.checked;
        if (appState.show_pcr_model) {
            updateStepTestPlot();
        }
    });
    
    elements.use_lactate_abort.addEventListener('change', function() {
        appState.use_lactate_abort = this.checked;
        updateStepTestPlot();
    });
    
    elements.use_mlss_as_cp.addEventListener('change', function() {
        appState.use_mlss_as_cp = this.checked;
        
        if (this.checked && appState.mlss_value) {
            // Update CP to MLSS value
            appState.critical_power = appState.mlss_value;
            elements.critical_power.value = appState.mlss_value;
            elements.critical_powerValue.textContent = appState.mlss_value;
            
            // Disable the Critical Power slider
            elements.critical_power.disabled = true;
            showNotification("Critical Power linked to MLSS: " + Math.round(appState.mlss_value) + " W", 'info');
        } else {
            // Enable the Critical Power slider
            elements.critical_power.disabled = false;
        }
        
        updateStepTestPlot();
    });
    
    elements.power_scale.addEventListener('input', function() {
        appState.power_scale = parseFloat(this.value);
        elements.power_scaleValue.textContent = appState.power_scale;
        updateStepTestPlot();
    });
    
    // Cadence Dependency Event Handlers for Tab 2
    elements.cadence_dependent_step.addEventListener('change', function() {
        appState.cadence_dependent_step = this.checked;
        elements.cadenceControlsStep.style.display = appState.cadence_dependent_step ? 'block' : 'none';
        updateStepTestPlot();
        
        if (this.checked) {
            // Show notification about cadence dependency
            showNotification(`Exercise simulation cadence dependency enabled at ${appState.cadence_step} rpm. This will modify the metabolic parameters based on cadence.`, 'info');
        }
    });
    
    elements.cadence_step.addEventListener('input', function() {
        appState.cadence_step = parseInt(this.value);
        elements.cadence_stepValue.textContent = appState.cadence_step;
        updateStepTestPlot();
    });
    
    elements.vo2max_dependent_step.addEventListener('change', function() {
        appState.vo2max_dependent_step = this.checked;
        updateStepTestPlot();
    });
    
    elements.vlamax_dependent_step.addEventListener('change', function() {
        appState.vlamax_dependent_step = this.checked;
        updateStepTestPlot();
    });
    
    elements.use_file_cadence.addEventListener('change', function() {
        appState.use_file_cadence = this.checked;
        
        if (this.checked) {
            // Check if we have cadence data in the current file
            const powerData = createPowerData();
            if (powerData.cadence) {
                showNotification("Using cadence data from file for simulation.", 'info');
            } else {
                showNotification("No cadence data available in current file. Fixed cadence will be used.", 'warning');
                this.checked = false;
                appState.use_file_cadence = false;
            }
        }
        
        updateStepTestPlot();
    });
    
    // Event handlers for curvilinear CE relationship in Tab 2
    elements.curvilinear_step.addEventListener('change', function() {
        appState.curvilinear_step = this.checked;
        elements.linearCeControlStep.style.display = this.checked ? 'none' : 'block';
        elements.curvilinearCeControlStep.style.display = this.checked ? 'block' : 'none';
        updateStepTestPlot();
    });
    
    elements.CE_range_start_step.addEventListener('input', function() {
        appState.CE_range_step[0] = parseFloat(this.value);
        elements.CE_range_start_stepValue.textContent = appState.CE_range_step[0].toFixed(1);
        updateStepTestPlot();
    });
    
    elements.CE_range_end_step.addEventListener('input', function() {
        appState.CE_range_step[1] = parseFloat(this.value);
        elements.CE_range_end_stepValue.textContent = appState.CE_range_step[1].toFixed(1);
        updateStepTestPlot();
    });
    
    elements.use_tab1_params.addEventListener('change', function() {
        appState.use_tab1_params = this.checked;
        elements.individual_params.style.display = 'block'; // Always display, regardless of checkbox status
        
        // If parameters are linked, update the parameters accordingly
        if (this.checked) {
            // Synchronize Tab 2 parameters with Tab 1
            appState.CEVO2_step = appState.CEVO2;
            appState.VO2max_step = appState.VO2max;
            appState.VO2Base_step = appState.VO2Base;
            appState.vLamax_step = appState.vLamax;
            appState.body_mass_step = appState.body_mass;
            
            // Synchronize curvilinear settings
            appState.curvilinear_step = appState.curvilinear;
            appState.CE_range_step = [...appState.CE_range];
            
            // Update displayed values
            elements.CEVO2_step.value = appState.CEVO2;
            elements.CEVO2_stepValue.textContent = appState.CEVO2.toFixed(1);
            elements.VO2max_step.value = appState.VO2max;
            elements.VO2max_stepValue.textContent = appState.VO2max.toFixed(0);
            elements.VO2Base_step.value = appState.VO2Base;
            elements.VO2Base_stepValue.textContent = appState.VO2Base.toFixed(0);
            elements.vLamax_step.value = appState.vLamax;
            elements.vLamax_stepValue.textContent = appState.vLamax.toFixed(2);
            elements.body_mass_step.value = appState.body_mass;
            elements.body_mass_stepValue.textContent = appState.body_mass.toFixed(1);
            
            // Update curvilinear controls
            elements.curvilinear_step.checked = appState.curvilinear;
            elements.CE_range_start_step.value = appState.CE_range[0];
            elements.CE_range_start_stepValue.textContent = appState.CE_range[0].toFixed(1);
            elements.CE_range_end_step.value = appState.CE_range[1];
            elements.CE_range_end_stepValue.textContent = appState.CE_range[1].toFixed(1);
            
            // Display correct CE controls based on curvilinear setting
            elements.linearCeControlStep.style.display = appState.curvilinear ? 'none' : 'block';
            elements.curvilinearCeControlStep.style.display = appState.curvilinear ? 'block' : 'none';
            
            // Synchronize MLSS value if checkbox is active
            updateCriticalPowerFromMlss();
            
            showNotification("Parameters synchronized with Tab 1", 'info');
        }
        
        updateStepTestPlot();
    });
    
elements.smooth_power.addEventListener('click', function() {
    // Get current power data
    const powerData = createPowerData();
    
    if (powerData && powerData.power && powerData.power.length > 5) {
        // Apply 5-point window smoothing
        appState.power_data.power = smoothData(powerData.power, 5);
        showNotification("Power curve smoothed with 5-point window", 'info');
        updateStepTestPlot();
    } else {
        showNotification("Not enough data points to smooth", 'warning');
    }
});
    
    elements.has_header.addEventListener('change', function() {
        appState.has_header = this.checked;
    });

    elements.gap_handling_last.addEventListener('change', function() {
        if (this.checked) {
            appState.gap_handling = 'last';
        }
    });

    elements.gap_handling_zero.addEventListener('change', function() {
        if (this.checked) {
            appState.gap_handling = 'zero';
        }
    });
    
    elements.CEVO2_step.addEventListener('input', function() {
        appState.CEVO2_step = parseFloat(this.value);
        elements.CEVO2_stepValue.textContent = appState.CEVO2_step.toFixed(1);
        
        // Synchronize with Tab 1 if parameters are linked
        if (appState.use_tab1_params) {
            appState.CEVO2 = appState.CEVO2_step;
            elements.CEVO2.value = appState.CEVO2;
            elements.CEVO2Value.textContent = appState.CEVO2.toFixed(1);
            updatePlot();
            updateCriticalPowerFromMlss();
        }
        
        updateStepTestPlot();
    });
    
    elements.VO2max_step.addEventListener('input', function() {
        appState.VO2max_step = parseFloat(this.value);
        elements.VO2max_stepValue.textContent = appState.VO2max_step.toFixed(0);
        
        // Synchronize with Tab 1 if parameters are linked
        if (appState.use_tab1_params) {
            appState.VO2max = appState.VO2max_step;
            elements.VO2max.value = appState.VO2max;
            elements.VO2maxValue.textContent = appState.VO2max.toFixed(0);
            // Update relative VO2max
            appState.VO2max_kg = appState.VO2max / appState.body_mass;
            elements.VO2max_kg.value = appState.VO2max_kg;
            elements.VO2max_kgValue.textContent = appState.VO2max_kg.toFixed(2);
            updatePlot();
            updateCriticalPowerFromMlss();
        }
        
        updateStepTestPlot();
    });
    
    elements.VO2Base_step.addEventListener('input', function() {
        appState.VO2Base_step = parseFloat(this.value);
        elements.VO2Base_stepValue.textContent = appState.VO2Base_step.toFixed(0);
        
        // Synchronize with Tab 1 if parameters are linked
        if (appState.use_tab1_params) {
            appState.VO2Base = appState.VO2Base_step;
            elements.VO2Base.value = appState.VO2Base;
            elements.VO2BaseValue.textContent = appState.VO2Base.toFixed(0);
            updatePlot();
            updateCriticalPowerFromMlss();
        }
        
        updateStepTestPlot();
    });
    
    elements.vLamax_step.addEventListener('input', function() {
        appState.vLamax_step = parseFloat(this.value);
        elements.vLamax_stepValue.textContent = appState.vLamax_step.toFixed(2);
        
        // Synchronize with Tab 1 if parameters are linked
        if (appState.use_tab1_params) {
            appState.vLamax = appState.vLamax_step;
            elements.vLamax.value = appState.vLamax;
            elements.vLamaxValue.textContent = appState.vLamax.toFixed(2);
            updatePlot();
            updateCriticalPowerFromMlss();
        }
        
        updateStepTestPlot();
    });
    
    elements.body_mass_step.addEventListener('input', function() {
        appState.body_mass_step = parseFloat(this.value);
        elements.body_mass_stepValue.textContent = appState.body_mass_step.toFixed(1);
        
        // Synchronize with Tab 1 if parameters are linked
        if (appState.use_tab1_params) {
            appState.body_mass = appState.body_mass_step;
            elements.body_mass.value = appState.body_mass;
            elements.body_massValue.textContent = appState.body_mass.toFixed(1);
            
            // Update relative VO2max if weight changes
            appState.VO2max_kg = appState.VO2max / appState.body_mass;
            elements.VO2max_kg.value = appState.VO2max_kg;
            elements.VO2max_kgValue.textContent = appState.VO2max_kg.toFixed(2);
            
            updatePlot();
            updateCriticalPowerFromMlss();
        }
        
        updateStepTestPlot();
    });

    // --- NEW: Event Listeners for Delay Sliders ---
    elements.vo2_delay.addEventListener('input', function() {
        appState.vo2_delay = parseInt(this.value);
        elements.vo2_delayValue.textContent = appState.vo2_delay;
        updateStepTestPlot(); // Recalculate simulation with new delay
    });

    elements.vlass_delay.addEventListener('input', function() {
        appState.vlass_delay = parseInt(this.value);
        elements.vlass_delayValue.textContent = appState.vlass_delay;
        updateStepTestPlot(); // Recalculate simulation with new delay
    });
    
    // Load sample interval data
    elements.load_interval_example.addEventListener('click', function() {
        // Sample interval data
        appState.interval_data = [
        { time_s: 0, power: 0, cadence: 80 },      // Start: 0 Watt for 2 minutes
        { time_s: 120, power: 200, cadence: 80 },  // 2 minutes at 200 Watts
        { time_s: 240, power: 250, cadence: 80 },  // Intervals start - 2 minutes at 250 Watts
        { time_s: 360, power: 200, cadence: 80 },  // 2 minutes recovery at 200 Watts
        { time_s: 480, power: 300, cadence: 90 },  // 2 minutes at 300 Watts
        { time_s: 600, power: 200, cadence: 80 },  // 2 minutes recovery at 200 Watts
        { time_s: 720, power: 350, cadence: 90 },  // 2 minutes at 350 Watts
        { time_s: 840, power: 200, cadence: 80 },  // 2 minutes recovery at 200 Watts
        { time_s: 960, power: 400, cadence: 90 },  // 2 minutes at 400 Watts
        { time_s: 1080, power: 200, cadence: 80 }, // 2 minutes recovery at 200 Watts
        { time_s: 1200, power: 450, cadence: 90 }, // 2 minutes at 450 Watts
        { time_s: 1320, power: 200, cadence: 80 }, // 2 minutes recovery at 200 Watts
        { time_s: 1440, power: 500, cadence: 90 }, // 2 minutes at 500 Watts
        { time_s: 1560, power: 200, cadence: 80 }, // 5 minutes at 200 Watts to cool down
        { time_s: 1860, power: 100, cadence: 80 }, // 5 minutes at 100 Watts to finish
        { time_s: 2160, power: 0, cadence: 80 }    // End of program
        ];
        
// Clear any file upload data
appState.power_data = null;
elements.fileName.textContent = "";
elements.power_data.value = "";

// Show notification
showNotification("Example interval data loaded with cadence values", 'info');

// Update plot
updateStepTestPlot();

// Update time window sliders for example data
if (appState.interval_data && appState.interval_data.length > 0) {
    const timePoints = appState.interval_data.map(d => d.time_s);
    const minTime = Math.min(...timePoints);
    const maxTime = Math.max(...timePoints);
    
    // Update slider ranges
    elements.view_time_start.min = minTime;
    elements.view_time_start.max = maxTime;
    elements.view_time_start.value = minTime;
    appState.view_time_start = minTime;
    elements.view_time_startValue.textContent = minTime;
    
    elements.view_time_end.min = minTime;
    elements.view_time_end.max = maxTime;
    elements.view_time_end.value = maxTime;
    appState.view_time_end = maxTime;
    elements.view_time_endValue.textContent = maxTime;
}
});


// Helper function to normalize column name
function normalizeColumnName(name) {
    if (!name) return "";
    
    // Convert to string, trim whitespace and convert to lowercase
    const normalizedName = String(name).toLowerCase().trim();
    
    // Time column identifiers
    if (/^time$|^t_s$|^t$|^time_s$|^timestamp$|^time_seconds$/.test(normalizedName)) {
        return "time";
    }
    
    // Power column identifiers
    if (/^power$|^watts$|^watt$/.test(normalizedName)) {
        return "power";
    }
    
    // Cadence column identifiers
    if (/^cadence$|^rpm$|^cad$/.test(normalizedName)) {
        return "cadence";
    }
    
    // Return original normalized name if no match
    return normalizedName;
}

// Helper function to find column indices in headers
function findColumnIndices(headers) {
    // Ensure headers is an array and convert items to strings
    const cleanHeaders = Array.isArray(headers) ? 
        headers.map(h => h !== null && h !== undefined ? String(h) : "") : 
        [];
    
    // Normalize headers
    const normalizedHeaders = cleanHeaders.map(h => normalizeColumnName(h));
    
    // Debug: log the normalized headers
    console.log("Normalized headers:", normalizedHeaders);
    
    // Find time/timestamp column
    let timeIdx = normalizedHeaders.indexOf("time");
    
    // Find power column
    let powerIdx = normalizedHeaders.indexOf("power");
    
    // Find cadence column
    let cadenceIdx = normalizedHeaders.indexOf("cadence");
    
    console.log("Column indices - Time:", timeIdx, "Power:", powerIdx, "Cadence:", cadenceIdx);
    
    return { timeIdx, powerIdx, cadenceIdx };
}

// Helper function to validate power value
function validatePower(value) {
    if (value === null || value === undefined || isNaN(value)) return null;
    
    // Filter out invalid power values (negative or too high)
    if (value < 0 || value > 2500 || value === 65535) return null;
    
    return value;
}

// Helper function to validate cadence value
function validateCadence(value) {
    if (value === null || value === undefined || isNaN(value)) return null;
    
    // Filter out invalid cadence values (negative or too high)
    if (value < 0 || value > 250) return null;
    
    return value;
}

// Function to process CSV data
function processCSVData(contents) {

    // Detect delimiter (try to be smarter about it)
    let delimiter = ';';
    const firstLine = contents.split('\n')[0];
    
    // Count occurrences of potential delimiters
    const commaCount = (firstLine.match(/,/g) || []).length;
    const semicolonCount = (firstLine.match(/;/g) || []).length;
    const tabCount = (firstLine.match(/\t/g) || []).length;
    
    if (commaCount > semicolonCount && commaCount > tabCount) {
        delimiter = ',';
    } else if (tabCount > semicolonCount && tabCount > commaCount) {
        delimiter = '\t';
    }
    
    console.log("Detected delimiter:", delimiter);
    
    const rows = contents.split('\n');
    return { rows, delimiter };
}

// Function to process XLSX data
function processXLSXData(file, callback) {
    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const data = new Uint8Array(e.target.result);
            const workbook = XLSX.read(data, { type: 'array' });
            
            // Get the first sheet
            const firstSheetName = workbook.SheetNames[0];
            const worksheet = workbook.Sheets[firstSheetName];
            
            // Convert to JSON
            const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
            
            callback(jsonData);
        } catch (error) {
            console.error("Error processing XLSX file:", error);
            showNotification("Error processing XLSX file", 'warning');
        }
    };
    reader.readAsArrayBuffer(file);
}

// Helper function to parse timestamp into seconds
function parseTimestamp(timestamp) {
    if (!timestamp) return NaN;
    
    try {
        // Check if it's already in seconds format
        const asNumber = parseFloat(String(timestamp).replace(',', '.'));
        if (!isNaN(asNumber)) {
            return asNumber;
        }
        
        // Check if it's a date object (from Excel)
        if (timestamp instanceof Date) {
            return timestamp.getHours() * 3600 + timestamp.getMinutes() * 60 + timestamp.getSeconds();
        }
        
        // Try to parse ISO format timestamp (2025-03-21T05:07:03)
        const timestampStr = String(timestamp).trim();
        const date = new Date(timestampStr);
        if (!isNaN(date.getTime())) {
            // Return seconds since midnight
            return date.getHours() * 3600 + date.getMinutes() * 60 + date.getSeconds();
        }
    } catch (e) {
        console.error("Error parsing timestamp:", e, "Value:", timestamp);
    }
    return NaN;
}

// File upload handling with improved data handling
elements.power_data.addEventListener('change', function(e) {
    const file = e.target.files[0];
    if (!file) return;
    
    // Display the file name
    elements.fileName.textContent = file.name;
    
    // Clear any interval data
    appState.interval_data = null;
    
    // Process based on file type
    const fileExtension = file.name.split('.').pop().toLowerCase();
    
    if (fileExtension === 'xlsx' || fileExtension === 'xls') {
        // Process Excel file
        processXLSXData(file, function(rows) {
            processFileData(rows, null, file.name);
        });
    } else {
        // Process CSV, TXT file
        const reader = new FileReader();
        reader.onload = function(e) {
            const contents = e.target.result;
            const { rows, delimiter } = processCSVData(contents);
            processFileData(rows, delimiter, file.name);
        };
        reader.readAsText(file);
    }
});

// Function to process file data regardless of source
function processFileData(rows, delimiter, fileName) {
    try {
        console.log("Processing file:", fileName);
        console.log("First few rows:", rows.slice(0, 3));
        
        // Temporary arrays to store parsed data points before interpolation
        const dataPoints = [];
        let hasCadenceData = false;
        
        const hasHeader = appState.has_header && rows.length > 1;
        const startRow = hasHeader ? 1 : 0;
        
        let timeIdx = 0, powerIdx = 1, cadenceIdx = 2;
        let firstTimestamp = null;
        
        // If we have headers, try to identify the columns
        if (hasHeader) {
            // Handle different formats for headers
            let headers;
            if (delimiter) {
                // For CSV files
                headers = rows[0].split(delimiter);
            } else {
                // For XLSX files
                headers = rows[0];
            }
            
            const indices = findColumnIndices(headers);
            
            if (indices.timeIdx !== -1) timeIdx = indices.timeIdx;
            if (indices.powerIdx !== -1) powerIdx = indices.powerIdx;
            if (indices.cadenceIdx !== -1) cadenceIdx = indices.cadenceIdx;
            
        }
        
        console.log("Using columns - Time:", timeIdx, "Power:", powerIdx, "Cadence:", cadenceIdx);
        
        // Parse the data rows
        for (let i = startRow; i < rows.length; i++) {
            if (!rows[i]) continue;
            
            let cells;
            if (delimiter) {
                // For CSV files
                const row = rows[i].trim();
                if (row === '') continue;
                cells = row.split(delimiter);
            } else {
                // For XLSX files
                cells = rows[i];
            }
            
            if (!cells || cells.length <= Math.max(timeIdx, powerIdx)) continue;
            
            // Parse time and power values
            const timeValue = cells[timeIdx];
            let powerValue = cells[powerIdx];

            // Handle GOTOES special case where power might be 65535 (invalid value)
            if (powerValue === 65535 || powerValue === "65535") {
                continue; // Skip invalid power data
            }

            // Try to convert power to number if it's not already
            if (typeof powerValue === 'string') {
                powerValue = parseFloat(powerValue.replace(',', '.'));
            }

            // Validate power value
            powerValue = validatePower(powerValue);

            if (!powerValue) continue; // Skip invalid power data

            if (!firstTimestamp && timeValue) firstTimestamp = timeValue;

            // Convert timestamp to seconds
            let timeSeconds = parseTimestamp(timeValue);
            if (isNaN(timeSeconds)) continue;

            // If using ISO timestamps, make time relative to first timestamp
            if (typeof timeValue === 'string' && 
                (timeValue.includes('T') || timeValue.includes('-'))) {
                const firstTimeSeconds = parseTimestamp(firstTimestamp);
                if (!isNaN(firstTimeSeconds)) {
                    timeSeconds = timeSeconds - firstTimeSeconds;
                }
            }
            
            const dataPoint = { time_s: timeSeconds, power: powerValue };
            
            // Check if we have cadence data
            if (cadenceIdx !== -1 && cells.length > cadenceIdx) {
                let cadence = cells[cadenceIdx];
                
                // Try to convert cadence to number if it's not already
                if (typeof cadence === 'string') {
                    cadence = parseFloat(cadence.replace(',', '.'));
                }
                
                // Validate cadence value
                cadence = validateCadence(cadence);
                
                if (cadence !== null) {
                    dataPoint.cadence = cadence;
                    hasCadenceData = true;
                }
            }
            
            dataPoints.push(dataPoint);
        }
        
        console.log("Parsed data points:", dataPoints.length);
        console.log("First few data points:", dataPoints.slice(0, 3));
        
        if (dataPoints.length > 0) {
            // Sort data points by time
            dataPoints.sort((a, b) => a.time_s - b.time_s);
            
            // Create arrays for 1-second interpolated data
            const time_s = [];
            const power = [];
            const cadence = hasCadenceData ? [] : null;
            
            // Get min and max time from data
            const minTime = Math.floor(dataPoints[0].time_s);
            const maxTime = Math.ceil(dataPoints[dataPoints.length - 1].time_s);
            
            console.log("Time range:", minTime, "to", maxTime);
            
            // Create data point for every second
            for (let t = minTime; t <= maxTime; t++) {
                time_s.push(t);
                
                // Find the data point with largest time <= t
                let prevIdx = -1;
                let nextIdx = -1;
                for (let i = 0; i < dataPoints.length; i++) {
                    if (dataPoints[i].time_s <= t) {
                        prevIdx = i;
                    } else {
                        nextIdx = i;
                        break;
                    }
                }

                // Determine if there's a significant time gap
                const isTimeGap = prevIdx >= 0 && nextIdx >= 0 && 
                    (dataPoints[nextIdx].time_s - dataPoints[prevIdx].time_s > 1);

                if (appState.gap_handling === 'zero' && isTimeGap) {
                    // If gap handling is set to zero and there's a time gap, use zero values
                    power.push(0);
                    if (hasCadenceData) {
                        cadence.push(0);
                    }
                } else if (prevIdx >= 0) {
                    // Otherwise use power from the previous data point (default behavior)
                    power.push(dataPoints[prevIdx].power);
                    if (hasCadenceData) {
                        cadence.push(dataPoints[prevIdx].cadence || null);
                    }
                } else {
                    // If no previous point, use the first point's values
                    power.push(dataPoints[0].power);
                    if (hasCadenceData) {
                        cadence.push(dataPoints[0].cadence || null);
                    }
                }
            }
            
            appState.power_data = {
                time_s: time_s,
                power: power,
                cadence: cadence
            };
            
            // Update time window sliders
            if (appState.power_data && appState.power_data.time_s && appState.power_data.time_s.length > 0) {
                const minTime = Math.min(...appState.power_data.time_s);
                const maxTime = Math.max(...appState.power_data.time_s);
                
                // Update slider ranges
                elements.view_time_start.min = minTime;
                elements.view_time_start.max = maxTime;
                elements.view_time_start.value = minTime;
                appState.view_time_start = minTime;
                elements.view_time_startValue.textContent = minTime;
                
                elements.view_time_end.min = minTime;
                elements.view_time_end.max = maxTime;
                elements.view_time_end.value = maxTime;
                appState.view_time_end = maxTime;
                elements.view_time_endValue.textContent = maxTime;
            }

            // Show notification
            let message = `${time_s.length} data points loaded and interpolated to 1-second intervals`;
            if (hasCadenceData) {
                message += " with cadence data";
                // Enable the use file cadence option if cadence data is available
                if (appState.cadence_dependent_step) {
                    elements.use_file_cadence.disabled = false;
                    elements.use_file_cadence.checked = true;
                    appState.use_file_cadence = true;
                }
            } else {
                // Disable the use file cadence option if no cadence data is available
                elements.use_file_cadence.disabled = true;
                appState.use_file_cadence = false;
                elements.use_file_cadence.checked = false;
            }
            
            showNotification(message, 'info');
            
            // Update plot
            updateStepTestPlot();
        } else {
            showNotification("No valid data found in the file", 'warning');
        }
    } catch (error) {
        console.error("Error processing file:", error);
        showNotification("Error processing the file: " + error.message, 'warning');
    }
}
    
    // Initialize with default values
    // Update controls with initial values
    elements.CEVO2Value.textContent = appState.CEVO2.toFixed(1);
    elements.CE_range_startValue.textContent = appState.CE_range[0].toFixed(1);
    elements.CE_range_endValue.textContent = appState.CE_range[1].toFixed(1);
    elements.VO2maxValue.textContent = appState.VO2max.toFixed(0);
    elements.VO2max_kgValue.textContent = appState.VO2max_kg.toFixed(2);
    elements.VO2BaseValue.textContent = appState.VO2Base.toFixed(0);
    elements.vLamaxValue.textContent = appState.vLamax.toFixed(2);
    elements.body_massValue.textContent = appState.body_mass.toFixed(1);
    elements.ageValue.textContent = appState.age;
    elements.heightValue.textContent = appState.height;
    elements.cadenceValue.textContent = appState.cadence;
    
    elements.cadence_stepValue.textContent = appState.cadence_step;
    elements.CEVO2_stepValue.textContent = appState.CEVO2_step.toFixed(1);
    elements.VO2max_stepValue.textContent = appState.VO2max_step.toFixed(0);
    elements.VO2Base_stepValue.textContent = appState.VO2Base_step.toFixed(0);
    elements.vLamax_stepValue.textContent = appState.vLamax_step.toFixed(2);
    elements.body_mass_stepValue.textContent = appState.body_mass_step.toFixed(1);
    elements.critical_powerValue.textContent = appState.critical_power;
    elements.w_primeValue.textContent = appState.w_prime.toFixed(1);
    elements.w_prime_balance_minValue.textContent = appState.w_prime_balance_min.toFixed(1);
    elements.pmaxValue.textContent = appState.pmax;
    elements.CE_range_start_stepValue.textContent = appState.CE_range_step[0].toFixed(1);
    elements.CE_range_end_stepValue.textContent = appState.CE_range_step[1].toFixed(1);
    elements.glycogen_initValue.textContent = appState.glycogen_init;
    elements.glycogen_maxValue.textContent = appState.glycogen_max;
    elements.carb_intake_rateValue.textContent = appState.carb_intake_rate;
    elements.rest_kh_percentageValue.textContent = appState.rest_kh_percentage;
    elements.vo2_delayValue.textContent = appState.vo2_delay;
    elements.vlass_delayValue.textContent = appState.vlass_delay;
    
    // Set initial visibility of cadence controls
    elements.cadenceControls.style.display = 'none';
    elements.cadenceControlsStep.style.display = 'none';
    
    // Set initial visibility of substrate controls
    elements.substrate_controls.style.display = 'none';
    elements.substrate_plot_container.style.display = 'none';
    elements.substrate_info.style.display = 'none';
    elements.kh_adjust_control.style.display = 'none';
    
    // Individual params area displayed by default
    elements.individual_params.style.display = 'block';
    
    // Initialize plots
    updatePlot();
    
    // Handle page resize events
    window.addEventListener('resize', function() {
        // Redraw all plots on resize
        updatePlot();
        if (document.getElementById('belastungssimulation-tab').classList.contains('active')) {
            updateStepTestPlot();
        }
    });
    
    // Calculate MLSS and set CP when loading the page
    updatePlot();
    
    // Set the use_mlss_as_cp checkbox to checked
    elements.use_mlss_as_cp.checked = appState.use_mlss_as_cp;
    elements.use_w_prime_balance_abort.checked = appState.use_w_prime_balance_abort;
    // Set PCr model to checked - Zeile entfernt

    // Immediately synchronize CP slider with current MLSS value
    if (appState.use_mlss_as_cp && appState.mlss_value) {
        appState.critical_power = appState.mlss_value;
        elements.critical_power.value = appState.mlss_value;
        elements.critical_powerValue.textContent = appState.mlss_value;
        elements.critical_power.disabled = true;
    }
    
    // Disable CP slider if use_mlss_as_cp is activated
    if (appState.use_mlss_as_cp) {
        elements.critical_power.disabled = true;
    }
    
    // Initialize delta efficiency value
    const initialDeltaEta = calculateDeltaEfficiency(appState.CEVO2);
    document.getElementById('delta-eta-value').textContent = 
        `${initialDeltaEta.min.toFixed(1)}-${initialDeltaEta.max.toFixed(1)}%`;

    // Add initialization for vLass_tauValue
    elements.vLass_on_tauValue.textContent = appState.vLass_on_tau;
    elements.vLass_off_tauValue.textContent = appState.vLass_off_tau;
    updateStepTestPlot();

    // Event Listeners für Zeitfenster-Slider
    elements.view_time_start.addEventListener('input', function() {
        appState.view_time_start = parseInt(this.value);
        // Ensure start time is less than end time
        if (appState.view_time_start >= appState.view_time_end) {
            appState.view_time_start = appState.view_time_end - 1;
            this.value = appState.view_time_start;
        }
        elements.view_time_startValue.textContent = appState.view_time_start;
        updateStepTestPlot();
    });

    elements.view_time_end.addEventListener('input', function() {
        appState.view_time_end = parseInt(this.value);
        // Ensure end time is greater than start time
        if (appState.view_time_end <= appState.view_time_start) {
            appState.view_time_end = appState.view_time_start + 1;
            this.value = appState.view_time_end;
        }
        elements.view_time_endValue.textContent = appState.view_time_end;
        updateStepTestPlot();
    });

    // Event Listeners für die Achsen-Anpassungen
    elements.customize_time_window.addEventListener('change', function() {
        appState.customize_time_window = this.checked;
        elements.time_window_sliders.style.display = this.checked ? 'block' : 'none';
        updateStepTestPlot();
    });

    elements.customize_y_axis.addEventListener('change', function() {
        appState.customize_y_axis = this.checked;
        elements.y_axis_sliders.style.display = this.checked ? 'block' : 'none';
        updateStepTestPlot();
    });

    elements.view_power_max.addEventListener('input', function() {
        appState.view_power_max = parseInt(this.value);
        elements.view_power_maxValue.textContent = appState.view_power_max;
        updateStepTestPlot();
    });

    elements.view_vo2_max.addEventListener('input', function() {
        appState.view_vo2_max = parseInt(this.value);
        elements.view_vo2_maxValue.textContent = appState.view_vo2_max;
        updateStepTestPlot();
    });

    elements.view_lactate_min.addEventListener('input', function() {
        appState.view_lactate_min = parseFloat(this.value);
        elements.view_lactate_minValue.textContent = appState.view_lactate_min;
        // Ensure minimum is less than maximum
        if (appState.view_lactate_min >= appState.view_lactate_max) {
            appState.view_lactate_min = appState.view_lactate_max - 1;
            this.value = appState.view_lactate_min;
            elements.view_lactate_minValue.textContent = appState.view_lactate_min;
        }
        updateStepTestPlot();
    });

    elements.view_lactate_max.addEventListener('input', function() {
        appState.view_lactate_max = parseFloat(this.value);
        elements.view_lactate_maxValue.textContent = appState.view_lactate_max;
        // Ensure maximum is greater than minimum
        if (appState.view_lactate_max <= appState.view_lactate_min) {
            appState.view_lactate_max = appState.view_lactate_min + 1;
            this.value = appState.view_lactate_max;
            elements.view_lactate_maxValue.textContent = appState.view_lactate_max;
        }
        updateStepTestPlot();
    });
    
    // Update plot once more to ensure everything is correct
    updateStepTestPlot();
</script>