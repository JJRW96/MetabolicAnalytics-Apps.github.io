<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced 3D Metabolic Simulator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>

    <style>
        :root {
            --primary-color: #2683C6; /* Blau */
            --secondary-color: #9C85C0; /* Lila */
            --accent-color: #EF5350; /* Rot */
            --light-color: #f8f9fa;
            --dark-color: #343a40;
            --border-color: #dee2e6;
            --cho-color: #FFC107; /* Gelb/Orange für CHO */
            --pcr-color: #4CAF50; /* Grün für PCr */
            --lactate-color: #F44336; /* Rot für Laktat */
            --wprime-color: #2196F3; /* Hellblau für W' */
            --atp-color: #FF9800; /* Orange für ATP-Level-Indikation */
            --ph-color: #64b5f6;
        }

        body {
            font-family: 'Roboto', sans-serif;
            margin: 0;
            padding: 0;
            background-color: var(--light-color);
            color: var(--dark-color);
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }

        .container {
            display: flex;
            flex-grow: 1;
            overflow: hidden;
        }

        .sidebar {
            width: 380px;
            padding: 20px;
            background-color: #fff;
            box-shadow: 2px 0 5px rgba(0,0,0,0.1);
            overflow-y: auto;
            border-right: 1px solid var(--border-color);
        }

        .main-content {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        #simulation-canvas-container {
            flex-grow: 1;
            position: relative;
            background-color: #2c3e50;
        }

        #simulationCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .controls-header {
            text-align: center;
            color: var(--primary-color);
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--border-color);
            font-size: 1.4em;
        }

        .control-group {
            margin-bottom: 18px;
            padding: 12px;
            background-color: #fdfdfd;
            border-radius: 6px;
            border: 1px solid var(--border-color);
        }
        .control-group h3 {
            margin-top: 0;
            margin-bottom: 12px;
            font-size: 1.1em;
            color: var(--secondary-color);
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
        }

        .slider-container {
            margin-bottom: 12px;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            font-size: 0.9em;
            margin-bottom: 4px;
        }
        .slider-label span:first-child { color: #555; }

        .slider-value {
            font-weight: bold;
            color: var(--primary-color);
        }

        input[type="range"] {
            width: 100%;
            cursor: pointer;
            accent-color: var(--primary-color);
        }
        input[type="number"] { /* Style für direkte Number-Inputs (falls hinzugefügt) */
            width: 70px;
            padding: 5px;
            border: 1px solid var(--border-color);
            border-radius: 3px;
            font-size: 0.9em;
        }


        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
            transition: background-color 0.3s;
            width: 100%;
            margin-top: 10px;
            font-size: 1em;
        }
        button:hover {
            background-color: #1a6eae;
        }
        button.reset-btn {
            background-color: var(--accent-color);
        }
        button.reset-btn:hover {
            background-color: #d32f2f;
        }

        .file-upload {
            border: 2px dashed var(--border-color);
            border-radius: 5px;
            padding: 10px;
            text-align: center;
            cursor: pointer;
            margin-bottom: 10px;
            background-color: #f9f9f9;
        }
        .file-upload:hover {
            border-color: var(--primary-color);
            background-color: #f1f8ff;
        }
        .file-upload input { display: none; }
        #fileNameDisplay { font-size: 0.8em; color: #666; margin-top: 5px; text-align: center;}

        #hud {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background-color: rgba(40,40,50,0.75);
            color: white;
            padding: 12px;
            border-radius: 8px;
            font-size: 0.85em;
            z-index: 10;
            min-width: 220px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }
        #hud p { margin: 4px 0; }
        #hud strong { color: #aaa; font-weight: normal;}
        #hud span { font-weight: bold; color: #fff;}

        .hud-bar-container {
            display: flex;
            align-items: center;
            margin: 5px 0;
        }
        .hud-bar-label {
            width: 70px;
            font-size: 0.9em;
            color: #ccc;
        }
        .hud-bar {
            height: 12px;
            background-color: #555;
            border-radius: 4px;
            overflow: hidden;
            flex-grow: 1;
            min-width: 120px;
            border: 1px solid #444;
        }
        .hud-bar-fill {
            height: 100%;
            width: 100%;
            background-color: var(--primary-color);
            transition: width 0.15s linear, background-color 0.15s linear;
            border-radius: 3px;
        }
        #simulationTimeDisplayTop {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0,0,0,0.7);
            color: white;
            padding: 8px 15px;
            border-radius: 5px;
            font-size: 1.3em;
            z-index: 10;
            font-weight: bold;
            box-shadow: 0 1px 5px rgba(0,0,0,0.2);
        }
    </style>
</head>
<body>
    <div class="container">
        <aside class="sidebar">
            <h2 class="controls-header">Metabolic Simulator</h2>

            <div class="control-group">
                <h3>Athlete Physiology</h3>
                <div class="slider-container">
                    <div class="slider-label"><span>VO2max (ml/min/kg):</span><span id="vo2maxValDisp" class="slider-value">60</span></div>
                    <input type="range" id="vo2maxInp" min="30" max="90" value="60" step="1">
                </div>
                <div class="slider-container">
                    <div class="slider-label"><span>VLamax (mmol/s/kg wm):</span><span id="vlamaxValDisp" class="slider-value">0.50</span></div>
                    <input type="range" id="vlamaxInp" min="0.1" max="1.2" value="0.5" step="0.01">
                </div>
                <div class="slider-container">
                    <div class="slider-label"><span>Body Mass (kg):</span><span id="bodyMassValDisp" class="slider-value">70</span></div>
                    <input type="range" id="bodyMassInp" min="40" max="120" value="70" step="1">
                </div>
                <div class="slider-container">
                    <div class="slider-label"><span>CP (W):</span><span id="cpValDisp" class="slider-value">250</span></div>
                    <input type="range" id="cpInp" min="100" max="500" value="250" step="5">
                </div>
                <div class="slider-container">
                    <div class="slider-label"><span>W' (kJ):</span><span id="wPrimeValDisp" class="slider-value">20</span></div>
                    <input type="range" id="wPrimeInp" min="5" max="50" value="20" step="1">
                </div>
            </div>

            <div class="control-group">
                <h3>Initial Stores & Buffering</h3>
                 <div class="slider-container">
                    <div class="slider-label"><span>Glycogen (g):</span><span id="glycogenRestValDisp" class="slider-value">400</span></div>
                    <input type="range" id="glycogenRestInp" min="100" max="800" value="400" step="10">
                </div>
                <div class="slider-container">
                    <div class="slider-label"><span>Total Adenylates (S[A] mmol/kg):</span><span id="sumAdenylatesValDisp" class="slider-value">7.5</span></div>
                    <input type="range" id="sumAdenylatesInp" min="5" max="10" value="7.5" step="0.1">
                </div>
                <div class="slider-container">
                    <div class="slider-label"><span>Total Cr+PCr+Pi (S[C] mmol/kg):</span><span id="sumCrPiValDisp" class="slider-value">45</span></div>
                    <input type="range" id="sumCrPiInp" min="30" max="60" value="45" step="1">
                </div>
                 <div class="slider-container">
                    <div class="slider-label"><span>Resting PCr (mmol/kg):</span><span id="pcrRestValDisp" class="slider-value">25</span></div>
                    <input type="range" id="pcrRestInp" min="10" max="40" value="25" step="1">
                </div>
                 <div class="slider-container">
                    <div class="slider-label"><span>Muscle Buffer (dbuff mval/L/pH):</span><span id="dbuffValDisp" class="slider-value">54</span></div>
                    <input type="range" id="dbuffInp" min="30" max="70" value="54" step="1">
                </div>
            </div>

            <div class="control-group">
                <h3>Simulation Input</h3>
                <label for="powerInputTypeSelect" style="font-size:0.9em; margin-bottom:5px; display:block;">Input Type:</label>
                <select id="powerInputTypeSelect" style="width:100%; padding:8px; font-size:0.9em; margin-bottom:10px;">
                    <option value="constant">Constant Power</option>
                    <option value="file">Race Data File (CSV)</option>
                </select>

                <div id="constantPowerControlsDiv">
                    <div class="slider-container">
                        <div class="slider-label"><span>Constant Power (W):</span><span id="constPowerValDisp" class="slider-value">200</span></div>
                        <input type="range" id="constPowerInp" min="50" max="700" value="200" step="5">
                    </div>
                    <div class="slider-container">
                         <div class="slider-label"><span>Duration (min):</span><span id="constDurationValDisp" class="slider-value">10</span></div>
                        <input type="range" id="constDurationInp" min="1" max="120" value="10" step="1">
                    </div>
                </div>

                <div id="fileUploadControlsDiv" style="display:none;">
                    <label for="raceDataFileInp" class="file-upload">
                        Upload CSV (time_s, power)
                        <input type="file" id="raceDataFileInp" accept=".csv">
                    </label>
                    <div id="fileNameDisplay">No file chosen</div>
                </div>
            </div>

             <div class="control-group">
                <h3>Simulation Speed</h3>
                <div class="slider-container">
                    <div class="slider-label"><span>Speed Multiplier:</span><span id="simSpeedValDisp" class="slider-value">1x</span></div>
                    <input type="range" id="simSpeedInp" min="1" max="100" value="1" step="1">
                </div>
            </div>

            <button id="startSimButton">Start Simulation</button>
            <button id="resetSimButton" class="reset-btn" style="margin-top:8px;">Reset</button>
        </aside>

        <main class="main-content">
            <div id="simulation-canvas-container">
                <canvas id="simulationCanvas"></canvas>
            </div>
             <div id="hud">
                <p><strong>Time:</strong> <span id="hudTime">00:00:00</span></p>
                <p><strong>Power:</strong> <span id="hudPowerDisp">0</span> W</p>
                <hr style="border-color: #555; margin: 6px 0;">
                <p><strong>VO2:</strong> <span id="hudVO2Disp">0.0</span> ml/min/kg</p>
                <p><strong>Lactate (m):</strong> <span id="hudLactateDisp">1.0</span> mmol/L</p>
                <p><strong>pH (m):</strong> <span id="hudPHDisp">7.10</span></p>
                <hr style="border-color: #555; margin: 6px 0;">
                <div class="hud-bar-container">
                    <span class="hud-bar-label">Glycogen:</span>
                    <div class="hud-bar"><div id="hudGlycogenBarFill" class="hud-bar-fill"></div></div>
                </div>
                <div class="hud-bar-container">
                    <span class="hud-bar-label">PCr:</span>
                    <div class="hud-bar"><div id="hudPCrBarFill" class="hud-bar-fill"></div></div>
                </div>
                 <div class="hud-bar-container">
                    <span class="hud-bar-label">ATP:</span>
                    <div class="hud-bar"><div id="hudATPBarFill" class="hud-bar-fill"></div></div>
                </div>
                <div class="hud-bar-container">
                    <span class="hud-bar-label">W':</span>
                    <div class="hud-bar"><div id="hudWPrimeBarFill" class="hud-bar-fill" ></div></div>
                </div>
            </div>
            <div id="simulationTimeDisplayTop">Time: 00:00:00</div>
        </main>
    </div>

    <script>
        // --- Three.js Setup ---
        let scene, camera, renderer;
        let athleteMesh, vo2Aura, powerCylinder;
        let pcrSparklesMaterial, pcrSparklesGeometry, pcrSparklesMesh;
        let lactateMaterial;

        // --- Simulation State & Parameters ---
        let simConfig = {};
        let simState = {};
        let simDataBuffer = [];
        let uploadedRaceData = null;
        let simulationIsRunning = false;
        let animationFrameHandle;
        let currentSimDataIndex = 0;
        let simSpeedFactor = 1;

        // --- Cached CSS Variable Values ---
        const cssColors = {};

        // --- Mader-inspired Constants (and others) ---
        const VO2_REST_PER_KG = 3.5;
        const ATP_REST_TURNOVER_PER_KG_MUSCLE_WM = 0.005;
        const LACTATE_REST_MUSCLE = 1.0;
        const PH_REST_MUSCLE = 7.1;
        const TAU_VO2_RISE = 20;
        const TAU_VO2_FALL = 30;
        const M2_CK_EQUILIBRIUM_L_MOL = 1.66e9;
        const M3_AK_EQUILIBRIUM = 1.05;
        const DG0_ATP_HYDROLYSIS_KJ_MOL = -30.6;
        const GAS_CONSTANT_R_KJ_MOL_K = 8.314e-3;
        const TEMPERATURE_KELVIN = 273.15 + 37;
        const KM_PFK_ADPxAMP = 3e-5;
        const PFK_HILL_N_ADPxAMP = 1.5;
        const KS3_PFK_H_CUBED_INV = 1 / Math.pow(10, -6.75 * 3);
        const KM_ADP_OXPHOS_MMOL_KG = 0.025;
        const NOX_HILL_OXPHOS = 1.8;
        const DG_OX_CONST_KJ_MOL = -72.5;
        const KS1_DG_OXPHOS_FACTOR_PER_KJ = 0.0005;
        const KEL_OX_LACTATE_SQ_MMOL_L_SQ = Math.pow(1.45, 2);
        const LACTATE_OX_PER_ML_O2 = 0.021 * 0.75;
        const MUSCLE_WATER_FRACTION_KG_PER_KGWM = 0.75;
        const ACTIVE_MUSCLE_MASS_RATIO_OF_BODY = 0.3;
        const ATP_PER_LACTATE_FROM_GLYCOLYSIS = 1.4;
        const P_O_RATIO_EFFECTIVE_ATP_PER_O2 = 5.0;
        const MOL_O2_PER_ML_O2_STPD = 1 / 22400;
        const JOULES_PER_MOL_ATP_HYDROLYSIS = 50000;
        const EFFICIENCY_ATP_TO_WORK = 0.25;

        const dom = {};

        function mapAndCacheDOMElements() {
            const ids = [
                'vo2maxInp', 'vlamaxInp', 'bodyMassInp', 'cpInp', 'wPrimeInp',
                'glycogenRestInp', 'sumAdenylatesInp', 'sumCrPiInp', 'pcrRestInp', 'dbuffInp',
                'constPowerInp', 'constDurationInp', 'powerInputTypeSelect', 'raceDataFileInp',
                'startSimButton', 'resetSimButton', 'simSpeedInp',
                'vo2maxValDisp', 'vlamaxValDisp', 'bodyMassValDisp', 'cpValDisp', 'wPrimeValDisp',
                'glycogenRestValDisp', 'sumAdenylatesValDisp', 'sumCrPiValDisp', 'pcrRestValDisp', 'dbuffValDisp',
                'constPowerValDisp', 'constDurationValDisp', 'simSpeedValDisp',
                'fileNameDisplay', 'hudTime', 'hudPowerDisp', 'hudVO2Disp', 'hudLactateDisp', 'hudPHDisp',
                'hudGlycogenBarFill', 'hudPCrBarFill', 'hudATPBarFill', 'hudWPrimeBarFill',
                'simulationTimeDisplayTop', 'constantPowerControlsDiv', 'fileUploadControlsDiv',
                'simulationCanvas'
            ];
            ids.forEach(id => {
                dom[id] = document.getElementById(id);
                if (!dom[id]) console.warn(`DOM element with ID "${id}" not found!`);
            });
        }

        function cacheCSSColors() {
            const rootStyle = getComputedStyle(document.documentElement);
            cssColors.choColor = rootStyle.getPropertyValue('--cho-color').trim();
            cssColors.pcrColor = rootStyle.getPropertyValue('--pcr-color').trim();
            cssColors.atpColor = rootStyle.getPropertyValue('--atp-color').trim();
            cssColors.wprimeColor = rootStyle.getPropertyValue('--wprime-color').trim();
            cssColors.primaryColor = rootStyle.getPropertyValue('--primary-color').trim();
            cssColors.lactateColor = rootStyle.getPropertyValue('--lactate-color').trim();
            cssColors.phColor = rootStyle.getPropertyValue('--ph-color').trim();
            cssColors.accentColor = rootStyle.getPropertyValue('--accent-color').trim();

            // Set initial bar colors using cached values
            if (dom.hudGlycogenBarFill) dom.hudGlycogenBarFill.style.backgroundColor = cssColors.choColor;
            if (dom.hudPCrBarFill) dom.hudPCrBarFill.style.backgroundColor = cssColors.pcrColor;
            if (dom.hudATPBarFill) dom.hudATPBarFill.style.backgroundColor = cssColors.atpColor;
            if (dom.hudWPrimeBarFill) dom.hudWPrimeBarFill.style.backgroundColor = cssColors.wprimeColor;
        }


        function initThreeJS() {
            const container = document.getElementById('simulation-canvas-container');
             if (!container || !dom.simulationCanvas) {
                console.error("Canvas container or canvas element not found! Three.js cannot initialize.");
                return;
            }

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x2c3e50);

            camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(0, 2.5, 7);
            camera.lookAt(0, 1, 0);

            renderer = new THREE.WebGLRenderer({ canvas: dom.simulationCanvas, antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
            dirLight.position.set(8, 15, 10);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 1024; dirLight.shadow.mapSize.height = 1024;
            scene.add(dirLight);

            const groundGeo = new THREE.PlaneGeometry(30, 30);
            const groundMat = new THREE.MeshStandardMaterial({ color: 0x34495e, roughness: 0.8 });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            const athleteGeo = new THREE.CapsuleGeometry(0.4, 1.3, 6, 20);
            // Use cached CSS color for initial material if available, otherwise default
            const initialAthleteColor = cssColors.primaryColor ? new THREE.Color(cssColors.primaryColor) : new THREE.Color(0x2683C6);
            lactateMaterial = new THREE.MeshStandardMaterial({ color: initialAthleteColor, roughness: 0.5, metalness: 0.2, emissive: 0x000000 });
            athleteMesh = new THREE.Mesh(athleteGeo, lactateMaterial);
            athleteMesh.position.y = (1.3/2) + 0.4;
            athleteMesh.castShadow = true;
            scene.add(athleteMesh);

            const auraGeo = new THREE.SphereGeometry(1.1, 32, 16);
            const auraMat = new THREE.MeshBasicMaterial({ color: 0x87CEFA, transparent: true, opacity: 0.05, depthWrite: false });
            vo2Aura = new THREE.Mesh(auraGeo, auraMat);
            vo2Aura.position.y = athleteMesh.position.y;
            scene.add(vo2Aura);

            const cylinderGeo = new THREE.CylinderGeometry(0.15, 0.15, 0.1, 16);
            const cylinderMat = new THREE.MeshStandardMaterial({color: 0xffaa00, emissive: 0xffaa00, emissiveIntensity: 0, transparent: true, opacity: 0.7});
            powerCylinder = new THREE.Mesh(cylinderGeo, cylinderMat);
            powerCylinder.position.set(athleteMesh.position.x, athleteMesh.position.y - 0.8, athleteMesh.position.z);
            powerCylinder.scale.y = 1;
            scene.add(powerCylinder);

             const particleCount = 100;
             pcrSparklesGeometry = new THREE.BufferGeometry();
             const positions = new Float32Array(particleCount * 3);
             for (let i = 0; i < particleCount; i++) {
                 positions[i * 3 + 0] = (Math.random() - 0.5) * 1.5;
                 positions[i * 3 + 1] = (Math.random() - 0.5) * 1.5 + athleteMesh.position.y;
                 positions[i * 3 + 2] = (Math.random() - 0.5) * 1.5;
             }
             pcrSparklesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
             const initialPcrSparkleColor = cssColors.pcrColor ? new THREE.Color(cssColors.pcrColor) : new THREE.Color(0x4CAF50);
             pcrSparklesMaterial = new THREE.PointsMaterial({
                 color: initialPcrSparkleColor,
                 size: 0.08,
                 transparent: true,
                 opacity: 0,
                 sizeAttenuation: true,
                 blending: THREE.AdditiveBlending,
                 depthWrite: false
             });
             pcrSparklesMesh = new THREE.Points(pcrSparklesGeometry, pcrSparklesMaterial);
             scene.add(pcrSparklesMesh);

            window.addEventListener('resize', onThreeJSWindowResize, false);
            renderThreeJSAnimationLoop();
        }

        function onThreeJSWindowResize() {
            const container = document.getElementById('simulation-canvas-container');
             if (!container || !renderer || !camera) return;
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        function renderThreeJSAnimationLoop() {
            if(renderer && scene && camera) renderer.render(scene, camera);
            requestAnimationFrame(renderThreeJSAnimationLoop);
        }

        function updateAllSliderValueDisplays() {
             if (!dom || Object.keys(dom).length === 0) return;
            Object.keys(dom).forEach(key => {
                if (key.endsWith('Inp') && dom[key] && dom[key].type === 'range') {
                    const valDispKey = key.replace('Inp', 'ValDisp');
                    if (dom[valDispKey]) {
                        let value = parseFloat(dom[key].value);
                        if (isNaN(value)) { // Handle cases where slider value might not parse initially
                            value = parseFloat(dom[key].defaultValue) || 0;
                        }
                        if (key === 'vlamaxInp' || key === 'sumAdenylatesInp') value = value.toFixed(2);
                        else value = Math.round(value);
                        dom[valDispKey].textContent = value + (key === 'simSpeedInp' ? 'x' : '');
                    } else {
                        // console.warn(`Display element ${valDispKey} not found for slider ${key}`);
                    }
                }
            });
        }

        function setupAllEventListeners() {
             if (!dom || Object.keys(dom).length === 0) return;
            Object.keys(dom).forEach(key => {
                if (key.endsWith('Inp') && dom[key] && dom[key].type === 'range') {
                    dom[key].addEventListener('input', updateAllSliderValueDisplays);
                }
            });

            if (dom.powerInputTypeSelect) {
                dom.powerInputTypeSelect.addEventListener('change', (e) => {
                    dom.constantPowerControlsDiv.style.display = (e.target.value === 'constant') ? 'block' : 'none';
                    dom.fileUploadControlsDiv.style.display = (e.target.value === 'file') ? 'block' : 'none';
                });
            }

            if (dom.raceDataFileInp) dom.raceDataFileInp.addEventListener('change', handleRaceFileUpload);
            if (dom.startSimButton) dom.startSimButton.addEventListener('click', toggleSimulation);
            if (dom.resetSimButton) dom.resetSimButton.addEventListener('click', fullResetSimulation);
        }

        function handleRaceFileUpload(event) {
            const file = event.target.files[0];
            if (!dom.fileNameDisplay) return;

            if (file) {
                dom.fileNameDisplay.textContent = `Loading ${file.name}...`;
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const csv = e.target.result;
                        const lines = csv.split(/[\r\n]+/).map(line => line.trim()).filter(line => line && !line.startsWith('#'));

                        if (lines.length < 2) throw new Error("CSV file must have at least a header and one data row.");

                        const headerLine = lines[0].toLowerCase();
                        const possibleTimeHeaders = ["time_s", "time(s)", "time", "t_s", "t", "seconds", "zeit", "time[s]"];
                        const possiblePowerHeaders = ["power", "watts", "p", "leistung", "power[w]"];

                        let timeIdx = -1, powerIdx = -1;
                        const headers = headerLine.split(/[,;\t]/).map(h => h.trim().replace(/"/g, ''));

                        for (const th of possibleTimeHeaders) {
                            const idx = headers.indexOf(th);
                            if (idx !== -1) { timeIdx = idx; break;}
                        }
                        for (const ph of possiblePowerHeaders) {
                            const idx = headers.indexOf(ph);
                            if (idx !== -1) { powerIdx = idx; break; }
                        }

                        if (timeIdx === -1 || powerIdx === -1) {
                             throw new Error(`CSV must contain time (e.g., "time_s") and power (e.g., "power") columns. Found headers: ${headers.join(', ')}. Indices T:${timeIdx}, P:${powerIdx}`);
                        }

                        let rawData = lines.slice(1).map(line => {
                            const values = line.split(/[,;\t]/);
                            if (values.length <= Math.max(timeIdx, powerIdx)) return null;
                            return {
                                time: parseFloat(values[timeIdx]),
                                power: parseFloat(values[powerIdx])
                            };
                        }).filter(row => row && !isNaN(row.time) && !isNaN(row.power) && row.power >= 0);

                        if (rawData.length === 0) throw new Error("No valid numeric data rows found in CSV.");

                        uploadedRaceData = [];
                        if (rawData.length > 0) {
                            rawData.sort((a,b) => a.time - b.time);
                            const timeOffset = rawData[0].time;
                            rawData.forEach(d => d.time -= timeOffset);

                            const firstTime = 0;
                            const lastTime = Math.ceil(rawData[rawData.length - 1].time);

                            let rawDataIdx = 0;
                            for (let t_sec = firstTime; t_sec <= lastTime; t_sec++) {
                                while (rawDataIdx < rawData.length - 1 && rawData[rawDataIdx + 1].time <= t_sec) {
                                    rawDataIdx++;
                                }
                                let currentPower = rawData[rawDataIdx].power;
                                if (rawDataIdx < rawData.length - 1 && rawData[rawDataIdx].time < t_sec) {
                                    const t1 = rawData[rawDataIdx].time; const p1 = rawData[rawDataIdx].power;
                                    const t2 = rawData[rawDataIdx+1].time; const p2 = rawData[rawDataIdx+1].power;
                                    if (t2 > t1) { currentPower = p1 + (p2 - p1) * (t_sec - t1) / (t2 - t1); }
                                }
                                uploadedRaceData.push({ time: t_sec, power: currentPower });
                            }
                        }
                        const durationMinutes = uploadedRaceData.length > 0 ? Math.round(uploadedRaceData[uploadedRaceData.length-1].time/60) : 0;
                        dom.fileNameDisplay.textContent = `${file.name} (${uploadedRaceData.length}s loaded, ${durationMinutes} min)`;
                        console.log("Processed race data:", uploadedRaceData.length, "points.");

                    } catch (error) {
                        console.error("Error processing CSV:", error);
                        alert("Error processing CSV file: " + error.message);
                        uploadedRaceData = null;
                        dom.fileNameDisplay.textContent = "Error loading file.";
                    }
                };
                reader.onerror = (e) => {
                     alert("Error reading file."); console.error("File reader error:", e);
                     uploadedRaceData = null; dom.fileNameDisplay.textContent = "Error reading file.";
                }
                reader.readAsText(file);
            } else {
                dom.fileNameDisplay.textContent = "No file chosen"; uploadedRaceData = null;
            }
        }


        function collectSimConfig() {
             simConfig = {
                vo2max_ml_min_kg: parseFloat(dom.vo2maxInp.value),
                vlamax_mmol_s_kg_wm: parseFloat(dom.vlamaxInp.value),
                bodyMass_kg: parseFloat(dom.bodyMassInp.value),
                cp_W: parseFloat(dom.cpInp.value),
                wPrime_J: parseFloat(dom.wPrimeInp.value) * 1000,
                initialGlycogen_g: parseFloat(dom.glycogenRestInp.value),
                s_adenylates_mmol_kg_wm: parseFloat(dom.sumAdenylatesInp.value),
                s_cr_pi_pool_mmol_kg_wm: parseFloat(dom.sumCrPiInp.value),
                initialPCr_mmol_kg_wm: parseFloat(dom.pcrRestInp.value),
                muscleBufferCapacity_mval_L_pH: parseFloat(dom.dbuffInp.value),
                inputType: dom.powerInputTypeSelect.value,
                constPower_W: parseFloat(dom.constPowerInp.value),
                constDuration_s: parseFloat(dom.constDurationInp.value) * 60,
            };

             if (simConfig.initialPCr_mmol_kg_wm >= simConfig.s_cr_pi_pool_mmol_kg_wm) {
                 simConfig.initialPCr_mmol_kg_wm = simConfig.s_cr_pi_pool_mmol_kg_wm * 0.95;
                 dom.pcrRestInp.value = simConfig.initialPCr_mmol_kg_wm.toFixed(1);
                 updateAllSliderValueDisplays();
                 console.warn("Resting PCr adjusted: cannot equal or exceed S[C] pool.");
             }
             if (isNaN(simConfig.vo2max_ml_min_kg)) { // Check one crucial value
                console.error("SimConfig contains NaN. Check slider parsing. Defaulting sliders.");
                // Potentially reset all sliders to default if this happens often
                alert("Error reading slider values. Please reset and try again.");
                return false; // Indicate failure
             }

            simConfig.vo2max_ml_min_abs = simConfig.vo2max_ml_min_kg * simConfig.bodyMass_kg;
            simConfig.vo2max_ml_s_abs = simConfig.vo2max_ml_min_abs / 60;
            simConfig.vo2_rest_ml_s_abs = (VO2_REST_PER_KG * simConfig.bodyMass_kg) / 60;
            simConfig.activeMuscleMass_kg = simConfig.bodyMass_kg * ACTIVE_MUSCLE_MASS_RATIO_OF_BODY;
            simSpeedFactor = parseInt(dom.simSpeedInp.value) || 1;
            return true; // Indicate success
        }

        function initializeSimState() {
            simState = {};
            simState.time_s = 0;
            simState.power_W = 0;
            simState.vo2_ml_s_abs = simConfig.vo2_rest_ml_s_abs;
            simState.vo2_target_ss_ml_s_abs = simConfig.vo2_rest_ml_s_abs;
            simState.pcr_mmol_kg_wm = simConfig.initialPCr_mmol_kg_wm;
            simState.pi_mmol_kg_wm = Math.max(0.1, simConfig.s_cr_pi_pool_mmol_kg_wm - simState.pcr_mmol_kg_wm);
            let initial_atp_guess = simConfig.s_adenylates_mmol_kg_wm * 0.85;
            const initialChelates = calculateCHEPEquilibrium(
                simConfig.s_adenylates_mmol_kg_wm, simConfig.s_cr_pi_pool_mmol_kg_wm,
                simState.pcr_mmol_kg_wm, PH_REST_MUSCLE,
                initial_atp_guess, simState.pi_mmol_kg_wm
            );
            simState.atp_mmol_kg_wm = initialChelates.atp;
            simState.adp_mmol_kg_wm = initialChelates.adp;
            simState.amp_mmol_kg_wm = initialChelates.amp;
            simState.pi_mmol_kg_wm = initialChelates.pi;
            simState.lactate_m_mmol_L_water = LACTATE_REST_MUSCLE;
            simState.pH_m = PH_REST_MUSCLE;
            simState.glycogen_g = simConfig.initialGlycogen_g;
            simState.wPrime_J = simConfig.wPrime_J;
            simState.dg_atp_cyt_kj_mol = calculateDGATPcyt(simState.atp_mmol_kg_wm, simState.adp_mmol_kg_wm, simState.pi_mmol_kg_wm);
            simState.pcr_prev_mmol_kg_wm = simState.pcr_mmol_kg_wm;
        }

        function precomputeSimulationData() {
            if (!collectSimConfig()) return false; // Stop if config collection failed
            initializeSimState();
            simDataBuffer = [ { ...simState } ];

            let powerProfile = [];
            if (simConfig.inputType === 'constant') {
                for (let t = 1; t <= simConfig.constDuration_s; t++) {
                    powerProfile.push({ time: t, power: simConfig.constPower_W });
                }
            } else {
                if (!uploadedRaceData || uploadedRaceData.length === 0) {
                    alert("Please upload valid race data or select constant power.");
                    return false;
                }
                powerProfile = uploadedRaceData;
            }

            if (powerProfile.length === 0) {
                 console.warn("Power profile is empty for precomputation."); return false;
            }
            console.log(`Precomputing for ${powerProfile.length} seconds...`);

            for (let i = 0; i < powerProfile.length; i++) {
                const prevSimStateFromBuffer = simDataBuffer[simDataBuffer.length - 1];
                let currentIterState = { ...prevSimStateFromBuffer };
                const targetTime = powerProfile[i].time;
                const targetPower = powerProfile[i].power;
                const dt_s = (i > 0 && powerProfile[i-1]) ? (targetTime - powerProfile[i-1].time) : targetTime;


                if (dt_s <= 0 && i > 0) {
                    console.warn(`Skipping step ${i} in precompute: dt=${dt_s}s. Power profile time: ${targetTime}`);
                    simDataBuffer.push({...currentIterState, time_s: targetTime, power_W: targetPower});
                    continue;
                }
                currentIterState.time_s = targetTime;
                currentIterState.power_W = targetPower;
                try {
                    runSingleSimulationStep(currentIterState, simConfig, dt_s);
                } catch (e) {
                    console.error(`Error in runSingleSimulationStep at t=${currentIterState.time_s}s:`, e.stack); // Added .stack for more details
                    alert(`Simulation error at t=${currentIterState.time_s}s. Check console.`);
                    return false;
                }
                simDataBuffer.push(currentIterState);
            }
            console.log("Precomputation finished. Buffer size:", simDataBuffer.length);
            return true;
        }


        function runSingleSimulationStep(currentState, config, dt) {
             const active_muscle_kg = config.activeMuscleMass_kg;
             if (active_muscle_kg <= 0 || dt <= 0) { return; }

             let vo2_rel_for_pco2 = Math.min(1, Math.max(0, (currentState.vo2_ml_s_abs / (config.vo2max_ml_s_abs + 1e-9) )));
             let pco2_mmhg = 40.0 + 55.0 * vo2_rel_for_pco2;
             pco2_mmhg = Math.max(35, Math.min(85, pco2_mmhg));
             let pi_for_ph_mmol_L_water = currentState.pi_mmol_kg_wm / MUSCLE_WATER_FRACTION_KG_PER_KGWM;
             let log_pco2_term = (pco2_mmhg > 0) ? Math.log10(pco2_mmhg) : Math.log10(0.1);
             currentState.pH_m = 7.85 + (config.muscleBufferCapacity_mval_L_pH / 1000) * (0.8 * pi_for_ph_mmol_L_water - currentState.lactate_m_mmol_L_water) - 0.55 * log_pco2_term;
             currentState.pH_m = Math.max(6.0, Math.min(7.4, currentState.pH_m));

            const chepValues = calculateCHEPEquilibrium(
                config.s_adenylates_mmol_kg_wm, config.s_cr_pi_pool_mmol_kg_wm,
                currentState.pcr_mmol_kg_wm, currentState.pH_m,
                currentState.atp_mmol_kg_wm, currentState.pi_mmol_kg_wm
            );
             currentState.adp_mmol_kg_wm = chepValues.adp;
             currentState.amp_mmol_kg_wm = chepValues.amp;
             currentState.dg_atp_cyt_kj_mol = calculateDGATPcyt(chepValues.atp, currentState.adp_mmol_kg_wm, currentState.pi_mmol_kg_wm); // Use chep.atp for current DG

             let fdg_adp_equivalent_mmol_kg = KS1_DG_OXPHOS_FACTOR_PER_KJ * Math.max(0, (DG_OX_CONST_KJ_MOL - currentState.dg_atp_cyt_kj_mol));
             let effective_adp_for_oxphos_mmol_kg = currentState.adp_mmol_kg_wm + fdg_adp_equivalent_mmol_kg;
             let vo2_ss_target_kg_s = (config.vo2max_ml_min_kg / 60) / (1 + Math.pow(KM_ADP_OXPHOS_MMOL_KG / Math.max(1e-6, effective_adp_for_oxphos_mmol_kg), NOX_HILL_OXPHOS));
             currentState.vo2_target_ss_ml_s_abs = vo2_ss_target_kg_s * config.bodyMass_kg;
             currentState.vo2_target_ss_ml_s_abs = Math.max(config.vo2_rest_ml_s_abs, currentState.vo2_target_ss_ml_s_abs);

             let tau_vo2_eff_s = (currentState.vo2_target_ss_ml_s_abs >= currentState.vo2_ml_s_abs) ? TAU_VO2_RISE : TAU_VO2_FALL;
             currentState.vo2_ml_s_abs += (currentState.vo2_target_ss_ml_s_abs - currentState.vo2_ml_s_abs) * (1 - Math.exp(-dt / Math.max(1, tau_vo2_eff_s)));
             currentState.vo2_ml_s_abs = Math.max(config.vo2_rest_ml_s_abs * 0.9, Math.min(currentState.vo2_ml_s_abs, config.vo2max_ml_s_abs * 1.02));

             let h_plus_mol_L = Math.pow(10, -currentState.pH_m);
             let vla_max_ph_mmol_s_kg_wm = config.vlamax_mmol_s_kg_wm / (1 + Math.pow(h_plus_mol_L, 3) * KS3_PFK_H_CUBED_INV);
             vla_max_ph_mmol_s_kg_wm = Math.max(0, vla_max_ph_mmol_s_kg_wm);
             let adp_amp_product = currentState.adp_mmol_kg_wm * currentState.amp_mmol_kg_wm;
             let vla_prod_mmol_s_kg_wm = vla_max_ph_mmol_s_kg_wm / (1 + Math.pow(KM_PFK_ADPxAMP / Math.max(1e-9, adp_amp_product), PFK_HILL_N_ADPxAMP) );
             if (currentState.glycogen_g <= 0.1) vla_prod_mmol_s_kg_wm *= (currentState.glycogen_g / 0.1);
             vla_prod_mmol_s_kg_wm = Math.max(0, vla_prod_mmol_s_kg_wm);

             let vo2_a_ml_s_kg_active_muscle = (currentState.vo2_ml_s_abs / (active_muscle_kg + 1e-9));
             let la_m_for_ox_mmol_L = Math.max(0.1, currentState.lactate_m_mmol_L_water);
             let vla_ox_mmol_s_kg_wm = (LACTATE_OX_PER_ML_O2 * vo2_a_ml_s_kg_active_muscle) / (1 + KEL_OX_LACTATE_SQ_MMOL_L_SQ / (la_m_for_ox_mmol_L * la_m_for_ox_mmol_L));
             vla_ox_mmol_s_kg_wm = Math.max(0, vla_ox_mmol_s_kg_wm);

             let net_lactate_rate_mmol_s_kg_wm = vla_prod_mmol_s_kg_wm - vla_ox_mmol_s_kg_wm;
             currentState.lactate_m_mmol_L_water += (net_lactate_rate_mmol_s_kg_wm / MUSCLE_WATER_FRACTION_KG_PER_KGWM) * dt;
             currentState.lactate_m_mmol_L_water = Math.max(LACTATE_REST_MUSCLE * 0.5, currentState.lactate_m_mmol_L_water);

             let atp_demand_work_mmol_s_kg_wm = 0;
             if (currentState.power_W > 0 && EFFICIENCY_ATP_TO_WORK > 0 && JOULES_PER_MOL_ATP_HYDROLYSIS > 0 && active_muscle_kg > 0) {
                 atp_demand_work_mmol_s_kg_wm = (currentState.power_W / active_muscle_kg) / (JOULES_PER_MOL_ATP_HYDROLYSIS * EFFICIENCY_ATP_TO_WORK);
             }
             let atp_demand_total_mmol_s_kg_wm = atp_demand_work_mmol_s_kg_wm + ATP_REST_TURNOVER_PER_KG_MUSCLE_WM;
             let atp_from_oxphos_mmol_s_kg_wm = vo2_a_ml_s_kg_active_muscle * MOL_O2_PER_ML_O2_STPD * P_O_RATIO_EFFECTIVE_ATP_PER_O2 * 1000;
             let atp_from_glycolysis_mmol_s_kg_wm = vla_prod_mmol_s_kg_wm * ATP_PER_LACTATE_FROM_GLYCOLYSIS;
             let net_atp_production_mmol_s_kg_wm = atp_from_oxphos_mmol_s_kg_wm + atp_from_glycolysis_mmol_s_kg_wm - atp_demand_total_mmol_s_kg_wm;

             currentState.pcr_prev_mmol_kg_wm = currentState.pcr_mmol_kg_wm;
             let pcr_change_mmol_kg_wm = net_atp_production_mmol_s_kg_wm * dt;
             currentState.pcr_mmol_kg_wm += pcr_change_mmol_kg_wm;
             currentState.pcr_mmol_kg_wm = Math.max(0.1, Math.min(currentState.pcr_mmol_kg_wm, config.s_cr_pi_pool_mmol_kg_wm - 0.1));
             currentState.pi_mmol_kg_wm = config.s_cr_pi_pool_mmol_kg_wm - currentState.pcr_mmol_kg_wm;

             const finalChep = calculateCHEPEquilibrium(
                 config.s_adenylates_mmol_kg_wm, config.s_cr_pi_pool_mmol_kg_wm,
                 currentState.pcr_mmol_kg_wm, currentState.pH_m,
                 currentState.atp_mmol_kg_wm, currentState.pi_mmol_kg_wm
             );
             currentState.atp_mmol_kg_wm = finalChep.atp;
             currentState.adp_mmol_kg_wm = finalChep.adp;
             currentState.amp_mmol_kg_wm = finalChep.amp;

             let gluc_units_from_glycolysis_mmol_s_kg_wm = vla_prod_mmol_s_kg_wm / 2;
             let cho_fraction_for_oxphos = 0.3 + 0.7 * vo2_rel_for_pco2;
             if (currentState.glycogen_g < 50) cho_fraction_for_oxphos = Math.min(cho_fraction_for_oxphos, 0.1 + 0.2 * (currentState.glycogen_g / 50));
             let atp_needed_by_oxphos_mmol_s_kg_wm = Math.max(0, atp_demand_total_mmol_s_kg_wm - atp_from_glycolysis_mmol_s_kg_wm);
             let atp_from_cho_oxphos_mmol_s_kg_wm = atp_needed_by_oxphos_mmol_s_kg_wm * cho_fraction_for_oxphos;
             let gluc_units_from_oxphos_mmol_s_kg_wm = atp_from_cho_oxphos_mmol_s_kg_wm / (30 * ATP_PER_LACTATE_FROM_GLYCOLYSIS / 1.4);
             let total_gluc_units_consumed_mmol_s_kg_wm = gluc_units_from_glycolysis_mmol_s_kg_wm + gluc_units_from_oxphos_mmol_s_kg_wm;
             let glycogen_consumed_g_s_kg_wm = total_gluc_units_consumed_mmol_s_kg_wm * 162.14 / 1000;
             if (active_muscle_kg > 0) { // Prevent NaN if active_muscle_kg is somehow 0
                currentState.glycogen_g -= glycogen_consumed_g_s_kg_wm * active_muscle_kg * dt;
             }
             currentState.glycogen_g = Math.max(0, currentState.glycogen_g);

            if (currentState.power_W > config.cp_W) {
                currentState.wPrime_J -= (currentState.power_W - config.cp_W) * dt;
            } else {
                const wPrimeDeficit_J = config.wPrime_J - currentState.wPrime_J;
                const dcp_W = config.cp_W - currentState.power_W;
                let tau_w_prime_rec_s = 300 + 300 * (1 - Math.max(0, dcp_W / (config.cp_W * 0.5 + 1e-9)));
                currentState.wPrime_J += wPrimeDeficit_J * (1 - Math.exp(-dt / Math.max(10, tau_w_prime_rec_s)));
            }
            currentState.wPrime_J = Math.max(0, Math.min(currentState.wPrime_J, config.wPrime_J));
        }


        function calculateCHEPEquilibrium(S_A_mmol_kg, S_C_mmol_kg, pcr_curr_mmol_kg, pH_curr, atp_guess_mmol_kg, pi_guess_mmol_kg) {
            S_A_mmol_kg = Number(S_A_mmol_kg); S_C_mmol_kg = Number(S_C_mmol_kg);
            pcr_curr_mmol_kg = Number(pcr_curr_mmol_kg); pH_curr = Number(pH_curr);
            atp_guess_mmol_kg = Number(atp_guess_mmol_kg); pi_guess_mmol_kg = Number(pi_guess_mmol_kg);

            let pi_mmol_kg = Math.max(0.1, S_C_mmol_kg - pcr_curr_mmol_kg);
            pcr_curr_mmol_kg = Math.max(0.1, pcr_curr_mmol_kg);
            let H_plus_mol_L = Math.pow(10, -pH_curr);

            // Mader's M1 definition implicitly uses molar conc. for the constant.
            // M1 = [ATP][Pi] / ([ADP][PCr]) where M1_eff = M2_CK_EQUILIBRIUM_L_MOL * H_plus_mol_L
            // The ratio term_ATP_div_ADP = ([ATP]/[ADP]) should be unitless.
            // So, M1_eff * [PCr] / [Pi] should give this unitless ratio.
            // If [PCr] and [Pi] are in mmol/kg_wm, their ratio is unitless.
            // Thus M1_eff (L/mol) needs to be adjusted if we are not careful with units throughout.
            // For now, assume the direct use of M2*H with mmol/kg_wm proxies molar ratios within the muscle context.
            let term_ATP_div_ADP = (M2_CK_EQUILIBRIUM_L_MOL * H_plus_mol_L * pcr_curr_mmol_kg) / Math.max(1e-6, pi_mmol_kg);

            if (isNaN(term_ATP_div_ADP) || !isFinite(term_ATP_div_ADP) || term_ATP_div_ADP <= 0) {
                term_ATP_div_ADP = (S_A_mmol_kg * 0.8) / (S_A_mmol_kg * 0.1 + 1e-9);
            }
            let term_ADP_div_ATP = 1.0 / term_ATP_div_ADP;

            let denominator = term_ATP_div_ADP + 1 + M3_AK_EQUILIBRIUM * term_ADP_div_ATP;
            if (denominator <= 1e-6) denominator = 1e-6;

            let adp_mmol_kg = S_A_mmol_kg / denominator;
            let atp_mmol_kg = term_ATP_div_ADP * adp_mmol_kg;
            let amp_mmol_kg = M3_AK_EQUILIBRIUM * adp_mmol_kg * adp_mmol_kg / Math.max(1e-6, atp_mmol_kg);

            atp_mmol_kg = Math.max(0, atp_mmol_kg); adp_mmol_kg = Math.max(0, adp_mmol_kg); amp_mmol_kg = Math.max(0, amp_mmol_kg);
            let sumCheck = atp_mmol_kg + adp_mmol_kg + amp_mmol_kg;
            if (sumCheck > 1e-6) {
                const factor = S_A_mmol_kg / sumCheck;
                atp_mmol_kg *= factor; adp_mmol_kg *= factor; amp_mmol_kg *= factor;
            } else {
                atp_mmol_kg = S_A_mmol_kg; adp_mmol_kg = 0; amp_mmol_kg = 0;
            }
            return { adp: adp_mmol_kg, amp: amp_mmol_kg, atp: atp_mmol_kg, pi: pi_mmol_kg };
        }


        function calculateDGATPcyt(atp_mmol_kg, adp_mmol_kg, pi_mmol_kg) {
            const atp_M = (atp_mmol_kg / MUSCLE_WATER_FRACTION_KG_PER_KGWM) / 1000;
            const adp_M = (adp_mmol_kg / MUSCLE_WATER_FRACTION_KG_PER_KGWM) / 1000;
            const pi_M  = (pi_mmol_kg  / MUSCLE_WATER_FRACTION_KG_PER_KGWM) / 1000;
            if (adp_M < 1e-9 || pi_M < 1e-9 || atp_M < 1e-9) { return DG0_ATP_HYDROLYSIS_KJ_MOL - 20; }
            const ratio = atp_M / (adp_M * pi_M);
            return DG0_ATP_HYDROLYSIS_KJ_MOL + GAS_CONSTANT_R_KJ_MOL_K * TEMPERATURE_KELVIN * Math.log(Math.max(1e-9, ratio));
        }


        function toggleSimulation() {
            if (!simulationIsRunning) {
                if (currentSimDataIndex === 0 || simDataBuffer.length <= 1) {
                    console.log("Attempting to start new simulation precomputation...");
                    const success = precomputeSimulationData();
                    if (!success || simDataBuffer.length <= 1) {
                        alert("Failed to prepare simulation data. Check parameters or file, and console for errors.");
                        return;
                    }
                    console.log("Precomputation successful. Starting animation.");
                    currentSimDataIndex = 0;
                } else {
                    console.log("Resuming simulation from index", currentSimDataIndex);
                }

                if (currentSimDataIndex < simDataBuffer.length -1) {
                    simulationIsRunning = true;
                    dom.startSimButton.textContent = "Pause Simulation";
                    dom.startSimButton.style.backgroundColor = cssColors.secondaryColor || '#9C85C0'; // Fallback color
                    runLiveSimulationAnimation();
                } else {
                     dom.startSimButton.textContent = "Finished";
                }

            } else {
                simulationIsRunning = false;
                dom.startSimButton.textContent = "Resume Simulation";
                dom.startSimButton.style.backgroundColor = cssColors.primaryColor || '#2683C6'; // Fallback color
                if (animationFrameHandle) cancelAnimationFrame(animationFrameHandle);
                console.log("Simulation paused at index", currentSimDataIndex);
            }
        }

        function fullResetSimulation() {
            simulationIsRunning = false;
            if (animationFrameHandle) cancelAnimationFrame(animationFrameHandle);
            simDataBuffer = []; currentSimDataIndex = 0;
            dom.startSimButton.textContent = "Start Simulation";
            dom.startSimButton.style.backgroundColor = cssColors.primaryColor || '#2683C6';
            if(dom.raceDataFileInp) dom.raceDataFileInp.value = "";
            if(dom.fileNameDisplay) dom.fileNameDisplay.textContent = "No file chosen";
            uploadedRaceData = null;

            if (!collectSimConfig()) { // Ensure config is collected before initializing state
                alert("Error in configuration. Please check sliders.");
                return;
            }
            initializeSimState();
            updateAllHUDs(simState);
            updateAll3DVisuals(simState, true);
            if(dom.simulationTimeDisplayTop) dom.simulationTimeDisplayTop.textContent = "Time: 00:00:00";
            if(dom.hudTime) dom.hudTime.textContent = "00:00:00";
            console.log("Simulator fully reset.");
        }

        function runLiveSimulationAnimation() {
            if (!simulationIsRunning || currentSimDataIndex >= simDataBuffer.length) {
                simulationIsRunning = false;
                dom.startSimButton.textContent = (currentSimDataIndex >= simDataBuffer.length && simDataBuffer.length > 0) ? "Finished" : "Resume Simulation";
                dom.startSimButton.style.backgroundColor = cssColors.primaryColor || '#2683C6';
                if (animationFrameHandle) cancelAnimationFrame(animationFrameHandle);
                if(currentSimDataIndex >= simDataBuffer.length && simDataBuffer.length > 0) console.log("Animation reached end of buffer.");
                return;
            }

            const dataPoint = simDataBuffer[currentSimDataIndex];
            if (!dataPoint) {
                 console.error("Invalid data point at index", currentSimDataIndex, ". Halting animation.");
                 simulationIsRunning = false; return;
            }

            updateAllHUDs(dataPoint);
            updateAll3DVisuals(dataPoint);

            const displayTime = dataPoint.time_s;
            const hours = Math.floor(displayTime / 3600);
            const minutes = Math.floor((displayTime % 3600) / 60);
            const seconds = Math.floor(displayTime % 60);
            const timeString = `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            if(dom.simulationTimeDisplayTop) dom.simulationTimeDisplayTop.textContent = `Time: ${timeString}`;
            if(dom.hudTime) dom.hudTime.textContent = timeString;

            currentSimDataIndex += simSpeedFactor;
            currentSimDataIndex = Math.min(currentSimDataIndex, simDataBuffer.length - 1);
            animationFrameHandle = requestAnimationFrame(runLiveSimulationAnimation);
        }

        function updateAllHUDs(state) {
            if (!dom.hudPowerDisp || !simConfig || !simConfig.bodyMass_kg) return;
            dom.hudPowerDisp.textContent = state.power_W.toFixed(0);
            dom.hudVO2Disp.textContent = (state.vo2_ml_s_abs / (simConfig.bodyMass_kg + 1e-9) * 60).toFixed(1);
            dom.hudLactateDisp.textContent = state.lactate_m_mmol_L_water.toFixed(1);
            dom.hudPHDisp.textContent = state.pH_m.toFixed(2);

            const glycogenPercent = (state.glycogen_g / (simConfig.initialGlycogen_g + 1e-9)) * 100;
            dom.hudGlycogenBarFill.style.width = `${Math.max(0, glycogenPercent)}%`;
            dom.hudGlycogenBarFill.style.backgroundColor = getColorForResource(glycogenPercent, cssColors.choColor || '#FFC107');

            const pcrPercent = (state.pcr_mmol_kg_wm / (simConfig.initialPCr_mmol_kg_wm + 1e-9)) * 100;
            dom.hudPCrBarFill.style.width = `${Math.max(0, pcrPercent)}%`;
            // PCr bar color is static green, defined by CSS, no need to change here unless desired

            const atpPercentOfTotalAdenylates = (state.atp_mmol_kg_wm / (simConfig.s_adenylates_mmol_kg_wm + 1e-9)) * 100;
            dom.hudATPBarFill.style.width = `${Math.max(0, Math.min(100, atpPercentOfTotalAdenylates))}%`;
            dom.hudATPBarFill.style.backgroundColor = getColorForResource(atpPercentOfTotalAdenylates, cssColors.atpColor || '#FF9800', true);

            const wPrimePercent = (state.wPrime_J / (simConfig.wPrime_J + 1e-9)) * 100;
            dom.hudWPrimeBarFill.style.width = `${Math.max(0, wPrimePercent)}%`;
            // W' bar color is static blue, defined by CSS
        }


        function getColorForResource(percentage, baseColorHex, isAtp = false) {
            const baseColor = new THREE.Color(baseColorHex);
            const criticalColor = new THREE.Color(cssColors.accentColor || '#EF5350'); // Fallback
            percentage = Math.max(0, Math.min(100, percentage));
            let factor = 1;

            if (isAtp) {
                if (percentage < 85) factor = Math.max(0, (percentage - 70)) / 15;
            } else if (baseColorHex === (cssColors.choColor || '#FFC107')) { // Glycogen
                if (percentage < 30) factor = Math.max(0, percentage) / 30;
            }
            const finalColor = new THREE.Color().lerpColors(criticalColor, baseColor, factor);
            return `rgb(${Math.round(finalColor.r*255)}, ${Math.round(finalColor.g*255)}, ${Math.round(finalColor.b*255)})`;
        }

        function updateAll3DVisuals(state, immediate = false) {
            if (!lactateMaterial || !vo2Aura || !powerCylinder || !pcrSparklesMaterial || !simConfig) return;

            const animDuration = immediate ? 0 : Math.max(50, 150 / simSpeedFactor);

            const phNormalized = Math.min(1, Math.max(0, (state.pH_m - 6.0) / (PH_REST_MUSCLE - 6.0)));
            const athleteColorTarget = new THREE.Color().lerpColors(new THREE.Color(cssColors.lactateColor || '#F44336'), new THREE.Color(cssColors.phColor || '#64b5f6'), phNormalized);
            anime({ targets: lactateMaterial.color, r: athleteColorTarget.r, g: athleteColorTarget.g, b: athleteColorTarget.b, duration: animDuration, easing: 'linear' });
            lactateMaterial.emissive.set(athleteColorTarget).multiplyScalar( (1 - phNormalized) * 0.7 ); // Emissive stronger at low pH


            const vo2RelFraction = Math.max(0, (state.vo2_ml_s_abs - simConfig.vo2_rest_ml_s_abs) / (simConfig.vo2max_ml_s_abs - simConfig.vo2_rest_ml_s_abs + 1e-6));
            const auraTargetOpacity = 0.05 + vo2RelFraction * 0.4;
            const auraScale = 1.0 + vo2RelFraction * 0.7;
            anime.remove(vo2Aura.material); anime.remove(vo2Aura.scale);
            anime({ targets: vo2Aura.material, opacity: auraTargetOpacity, duration: animDuration*1.5, easing: 'linear' });
            anime({ targets: vo2Aura.scale, x: auraScale, y: auraScale, z: auraScale, duration: animDuration*2, easing: 'easeOutQuad' });

            const powerNorm = Math.min(1.5, Math.max(0, state.power_W / (simConfig.cp_W +1e-6)));
            const cylinderTargetHeightFactor = 0.1 + powerNorm * 1.5;
            const cylinderTargetIntensity = powerNorm * 1.2;
            anime({ targets: powerCylinder.scale, y: cylinderTargetHeightFactor, duration: animDuration*0.8, easing: 'linear' });
            anime({ targets: powerCylinder.material, emissiveIntensity: cylinderTargetIntensity, duration: animDuration*0.8, easing: 'linear' });

            const pcrDelta = state.pcr_mmol_kg_wm - state.pcr_prev_mmol_kg_wm;
            const pcrUsageRateAbs = Math.abs(pcrDelta);
            const pcrThreshold = 0.05 / (simSpeedFactor || 1);


            if (pcrUsageRateAbs > pcrThreshold && pcrDelta < 0) { // Only sparkle on PCr USAGE (negative delta)
                const sparkleIntensity = Math.min(1, pcrUsageRateAbs / (pcrThreshold * 10));
                pcrSparklesMaterial.opacity = sparkleIntensity;
                pcrSparklesMaterial.size = 0.05 + sparkleIntensity * 0.05;
                anime.remove(pcrSparklesMaterial);
                anime({
                    targets: pcrSparklesMaterial,
                    opacity: 0,
                    size: 0.05,
                    duration: Math.max(200, 400 / simSpeedFactor),
                    easing: 'linear'
                });
            } else {
                if (pcrSparklesMaterial.opacity > 0 && !anime.get(pcrSparklesMaterial, 'opacity', 'count')) {
                     pcrSparklesMaterial.opacity = Math.max(0, pcrSparklesMaterial.opacity - 0.05 / (simSpeedFactor || 1) );
                }
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM Content Loaded. Initializing Simulator...");
            mapAndCacheDOMElements();
            cacheCSSColors(); // Cache colors after DOM is ready
            initThreeJS();
            updateAllSliderValueDisplays(); // Call this AFTER caching DOM elements
            setupAllEventListeners();
            fullResetSimulation();
            console.log("Simulator Initialized and Reset.");
        });

    </script>
</body>
</html>