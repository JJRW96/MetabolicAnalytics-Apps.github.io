<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lactate-Power Model</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #2683C6;
            --secondary-color: #9C85C0;  
            --accent-color: #EF5350;
            --light-color: #f8f9fa;
            --dark-color: #343a40;
            --border-color: #dee2e6;
            --gradient-start: #f1f8ff;
            --gradient-end: #ffffff;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Roboto', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: #f5f5f5;
            color: var(--dark-color);
            line-height: 1.6;
            overflow: hidden;
        }
        
        .container {
            display: flex;
            height: 100vh;
            max-width: 100%;
        }
        
        .sidebar {
            width: 350px;
            flex-shrink: 0; /* Prevent sidebar from shrinking */
            background: linear-gradient(to bottom, var(--gradient-start), var(--gradient-end));
            padding: 20px;
            box-shadow: 2px 0 5px rgba(0,0,0,0.1);
            overflow-y: auto; /* Add scrollbar to sidebar */
            border-right: 1px solid var(--border-color);
            max-height: 100vh;
            position: relative;
            z-index: 10;
        }
        
        .main-content {
            flex: 1;
            padding: 20px;
            display: flex;
            flex-direction: column;
            background-color: #fff;
            overflow-y: auto;
        }
        
        h1 {
            color: var(--primary-color);
            margin-bottom: 20px;
            font-size: 1.8rem;
            text-align: center;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--border-color);
        }
        
        .control-group {
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid var(--border-color);
            background-color: white;
            border-radius: 6px;
            padding: 15px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        
        .control-group:last-child {
            border-bottom: none;
        }
        
        .control-label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: var(--dark-color);
        }
        
        .slider-container {
            margin-bottom: 15px;
        }
        
        .slider-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
        }
        
        .slider-label label {
            flex-grow: 1;
        }
        
        .slider-value {
            min-width: 60px;
            text-align: right;
            font-weight: bold;
            color: var(--primary-color);
        }
        
        .range-slider {
            -webkit-appearance: none;
            width: 100%;
            height: 8px;
            border-radius: 5px;
            background: linear-gradient(to right, #ddd, var(--primary-color));
            outline: none;
            margin: 10px 0;
        }
        
        .range-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--primary-color);
            cursor: pointer;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        
        .range-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--primary-color);
            cursor: pointer;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        
        .checkbox-container {
            display: flex;
            align-items: center;
            margin: 10px 0;
            cursor: pointer;
        }
        
        .checkbox-container input {
            margin-right: 10px;
            cursor: pointer;
        }
        
        .radio-group {
            margin: 10px 0;
        }
        
        .radio-option {
            margin: 5px 0;
            display: flex;
            align-items: center;
            cursor: pointer;
        }
        
        .radio-option input {
            margin-right: 10px;
            cursor: pointer;
        }
        
        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
            margin-top: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        button:hover {
            background-color: #1a6eae;
            transform: translateY(-1px);
            box-shadow: 0 3px 5px rgba(0,0,0,0.15);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        #plot-container, #steptest-plot-container {
            height: 600px; /* Fixed height to match original */
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.08);
            margin-bottom: 20px;
            padding: 5px;
        }
        
        #values-container {
            background-color: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.08);
            font-family: monospace;
            white-space: pre-wrap;
            height: 220px;
            overflow-y: auto;
            color: #444;
            font-size: 0.92rem;
            border-left: 4px solid var(--primary-color);
        }
        
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background-color: white;
            padding: 10px 15px;
            border-radius: 5px;
            box-shadow: 0 2px 15px rgba(0,0,0,0.2);
            display: none;
            max-width: 300px;
            z-index: 1000;
            animation: fadeIn 0.3s;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .notification.warning {
            border-left: 4px solid #42BA97; 
        }
        
        .notification.info {
            border-left: 4px solid var(--primary-color);
        }
        
        h4 {
            margin-top: 15px;
            color: var(--primary-color);
        }
        
        hr {
            border: 0;
            height: 1px;
            background-color: var(--border-color);
            margin: 15px 0;
        }
        
        .dual-slider-container {
            position: relative;
            margin-bottom: 15px;
        }
        
        .dual-slider {
            -webkit-appearance: none;
            width: 100%;
            height: 8px;
            border-radius: 5px;
            background: linear-gradient(to right, #ddd, var(--primary-color));
            outline: none;
            margin: 10px 0;
        }
        
        .dual-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--primary-color);
            cursor: pointer;
            z-index: 2;
        }
        
        .dual-slider-values {
            display: flex;
            justify-content: space-between;
            font-size: 0.9rem;
        }
        
        .header-section {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .info-icon {
            color: var(--primary-color);
            cursor: pointer;
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background-color: rgba(38, 131, 198, 0.1);
        }
        
        .tooltip {
            position: relative;
            display: inline-block;
        }
        
        .tooltip .tooltiptext {
            visibility: hidden;
            width: 200px;
            background-color: #555;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 10px;
            position: absolute;
            z-index: 100;
            right: -20px;
            top: 30px;
            margin-left: -100px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.9rem;
            line-height: 1.4;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        
        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }
        
        .axis-controls {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            padding: 10px;
            background-color: rgba(38, 131, 198, 0.05);
            border-radius: 4px;
        }
        
        .card-title {
            margin-bottom: 10px;
            font-weight: 600;
            font-size: 1.1rem;
            color: var(--primary-color);
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 5px;
        }
        
        .fancy-checkbox {
            display: inline-block;
            position: relative;
            padding-left: 30px;
            cursor: pointer;
            font-size: 0.9rem;
            user-select: none;
        }
        
        .fancy-checkbox input {
            position: absolute;
            opacity: 0;
            cursor: pointer;
            height: 0;
            width: 0;
        }
        
        .checkmark {
            position: absolute;
            top: 0;
            left: 0;
            height: 20px;
            width: 20px;
            background-color: #eee;
            border-radius: 3px;
            transition: all 0.2s;
        }
        
        .fancy-checkbox:hover input ~ .checkmark {
            background-color: #ccc;
        }
        
        .fancy-checkbox input:checked ~ .checkmark {
            background-color: var(--primary-color);
        }
        
        .checkmark:after {
            content: "";
            position: absolute;
            display: none;
        }
        
        .fancy-checkbox input:checked ~ .checkmark:after {
            display: block;
        }
        
        .fancy-checkbox .checkmark:after {
            left: 7px;
            top: 3px;
            width: 5px;
            height: 10px;
            border: solid white;
            border-width: 0 2px 2px 0;
            transform: rotate(45deg);
        }
        
        .small-text {
            font-size: 0.85rem;
            color: #666;
            margin-top: 5px;
        }
        
        .model-info {
            font-size: 0.9rem;
            color: #666;
            margin: 10px 0;
            padding: 10px;
            border-left: 3px solid var(--secondary-color);
            background-color: rgba(66, 186, 151, 0.05);
        }
        
        .badge {
            display: inline-block;
            padding: 3px 7px;
            font-size: 0.75rem;
            font-weight: 600;
            border-radius: 12px;
            margin-left: 5px;
            vertical-align: middle;
        }
        
        .badge-primary {
            background-color: var(--primary-color);
            color: white;
        }
        
        .badge-secondary {
            background-color: var(--secondary-color);
            color: white;
        }
        
        .badge-accent {
            background-color: var(--accent-color);
            color: white;
        }
        
        .parameter-row {
            margin-bottom: 12px;
            display: flex;
            align-items: center;
        }
        
        .parameter-label {
            flex-grow: 1;
            font-size: 0.9rem;
        }

        /* Customize scrollbar for the sidebar */
        .sidebar::-webkit-scrollbar {
            width: 8px;
        }
        
        .sidebar::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }
        
        .sidebar::-webkit-scrollbar-thumb {
            background: #bbb;
            border-radius: 10px;
        }
        
        .sidebar::-webkit-scrollbar-thumb:hover {
            background: #999;
        }
        
        /* Tab Styling */
        .tabs {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .tab {
            padding: 10px 20px;
            cursor: pointer;
            transition: all 0.3s;
            border-bottom: 3px solid transparent;
            font-weight: 500;
        }
        
        .tab.active {
            color: var(--primary-color);
            border-bottom: 3px solid var(--primary-color);
        }
        
        .tab:hover:not(.active) {
            background-color: rgba(38, 131, 198, 0.05);
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        /* File Upload Styling */
        .file-upload {
            border: 2px dashed #ccc;
            border-radius: 5px;
            padding: 15px;
            margin: 10px 0;
            text-align: center;
            background-color: #f9f9f9;
            transition: all 0.3s;
            cursor: pointer;
        }
        
        .file-upload:hover {
            border-color: var(--primary-color);
            background-color: rgba(38, 131, 198, 0.05);
        }
        
        .file-upload input {
            display: none;
        }
        
        .file-upload-label {
            display: block;
            font-weight: 500;
            margin-bottom: 10px;
            color: #555;
        }
        
        .file-upload-info {
            font-size: 0.8rem;
            color: #777;
            margin-top: 10px;
        }
        
        .file-name {
            font-weight: 500;
            color: var(--primary-color);
            margin-top: 10px;
            word-break: break-all;
        }
        
        .swap-axes-container {
            margin: 15px 0;
            padding: 10px;
            background-color: rgba(38, 131, 198, 0.05);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="sidebar" id="sidebar">
            <h1>Lactate-Power Model</h1>
            
            <div class="tabs">
                <div class="tab active" data-tab="leistungsdiagramm">Power Diagram</div>
                <div class="tab" data-tab="belastungssimulation">Exercise Simulation</div>
            </div>
            
            <!-- Tab 1: Power Diagram Controls -->
            <div class="tab-content active" id="leistungsdiagramm-content">
                <div class="control-group" id="ce-controls">
                    <div class="header-section">
                        <div class="control-label">Oxygen Demand Settings</div>
                        <div class="tooltip info-icon">ⓘ
                            <span class="tooltiptext">Defines how oxygen demand changes with power output.</span>
                        </div>
                    </div>
                    
                    <div class="checkbox-container">
                        <label class="fancy-checkbox">
                            <input type="checkbox" id="curvilinear" name="curvilinear">
                            <span class="checkmark"></span>
                            Curvilinear CE relationship
                            <div class="tooltip info-icon" style="margin-left: 5px;">ⓘ
                                <span class="tooltiptext">Based on the curvilinear relationship between power output and energy consumption.</span>
                            </div>
                        </label>
                    </div>
                    
                    <div id="linear-ce-control" class="slider-container">
                        <div class="slider-label">
                            <label for="CEVO2">CE (ml·min<sup>-1</sup>·W<sup>-1</sup>):</label>
                            <span id="CEVO2-value" class="slider-value">11.0</span>
                        </div>
                        <input type="range" id="CEVO2" class="range-slider" min="8" max="15" value="11" step="0.1">
                    </div>
                    
                    <div id="curvilinear-ce-control" class="slider-container" style="display:none;">
                        <div class="slider-label">
                            <label for="CE_range_start">CE Start (ml·min<sup>-1</sup>·W<sup>-1</sup>):</label>
                            <span id="CE_range_start-value" class="slider-value">11.0</span>
                        </div>
                        <input type="range" id="CE_range_start" class="range-slider" min="8" max="15" value="11" step="0.1">
                        
                        <div class="slider-label">
                            <label for="CE_range_end">CE Target (ml·min<sup>-1</sup>·W<sup>-1</sup>):</label>
                            <span id="CE_range_end-value" class="slider-value">12.0</span>
                        </div>
                        <input type="range" id="CE_range_end" class="range-slider" min="8" max="15" value="12" step="0.1">
                    </div>
                </div>
                
                <div class="control-group">
                    <div class="header-section">
                        <div class="control-label">Cadence Dependency</div>
                        <div class="tooltip info-icon">ⓘ
                            <span class="tooltiptext">Incorporate cycling cadence effects as described in Dunst et al. (2025). This modifies metabolic parameters based on the pedaling rate.</span>
                        </div>
                    </div>
                    
                    <div class="checkbox-container">
                        <label class="fancy-checkbox">
                            <input type="checkbox" id="cadence_dependent" name="cadence_dependent">
                            <span class="checkmark"></span>
                            Enable Cadence Dependency
                        </label>
                    </div>
                    
                    <div id="cadence-controls" style="display:none;">
                        <div id="cadence-control" class="slider-container">
                            <div class="slider-label">
                                <label for="cadence">Cadence (rpm):</label>
                                <span id="cadence-value" class="slider-value">80</span>
                            </div>
                            <input type="range" id="cadence" class="range-slider" min="20" max="200" value="80" step="1">
                        </div>
                        
                        <div class="parameter-row">
                            <div class="parameter-label">CE (CEVO<sub>2</sub>) Dependency:</div>
                            <div class="tooltip info-icon">ⓘ
                                <span class="tooltiptext">Formula: CEVO<sub>2</sub>(rpm) = 0.0004 · rpm² - 0.094 · rpm + 16.857. Research shows a U-shaped relationship between cadence and oxygen demand per watt.</span>
                            </div>
                            <span class="slider-value">✓</span>
                        </div>
                        
                        <div class="parameter-row">
                            <div class="parameter-label">VO<sub>2,Base</sub> Dependency:</div>
                            <div class="tooltip info-icon">ⓘ
                                <span class="tooltiptext">Formula: VO<sub>2,Base</sub>(rpm) = 0.172 · rpm² - 14.460 · rpm + 548.039. Research shows a U-shaped relationship between cadence and resting oxygen uptake.</span>
                            </div>
                            <span class="slider-value">✓</span>
                        </div>
                        
                        <div class="checkbox-container">
                            <label class="fancy-checkbox">
                                <input type="checkbox" id="vo2max_dependent" name="vo2max_dependent">
                                <span class="checkmark"></span>
                                Include VO<sub>2,max</sub> Dependency
                            </label>
                            <div class="tooltip info-icon">ⓘ
                                <span class="tooltiptext">Based on Fig.4 from the paper, VO<sub>2,max</sub> might also be slightly cadence-dependent, with optimal values around 80-90 rpm. This is an experimental feature.</span>
                            </div>
                        </div>
                        
                        <div class="checkbox-container">
                            <label class="fancy-checkbox">
                                <input type="checkbox" id="vlamax_dependent" name="vlamax_dependent">
                                <span class="checkmark"></span>
                                Include vLa<sub>max</sub> Dependency (Experimental)
                            </label>
                            <div class="tooltip info-icon">ⓘ
                                <span class="tooltiptext">Formula: vLa<sub>max</sub>(rpm) = -0.0002 · rpm² + 0.00931 · rpm. The paper suggests this may not reflect true physiological processes but rather testing methodology limitations.</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="small-text">Based on the research from Dunst et al. (2025) showing how metabolic parameters vary with cycling cadence.</div>
                </div>
                
                <div class="control-group">
                    <div class="header-section">
                        <div class="control-label">Physiological Parameters</div>
                        <div class="tooltip info-icon">ⓘ
                            <span class="tooltiptext">Important physiological values in Mader's metabolism model.</span>
                        </div>
                    </div>
                    
                    <div class="slider-container">
                        <div class="slider-label">
                            <label for="VO2max">V̇O<sub>2,max</sub> (ml·min<sup>-1</sup>):</label>
                            <span id="VO2max-value" class="slider-value">6000</span>
                        </div>
                        <input type="range" id="VO2max" class="range-slider" min="2000" max="7500" value="6000" step="10">
                    </div>
                    
                    <div class="slider-container">
                        <div class="slider-label">
                            <label for="VO2max_kg">V̇O<sub>2,max</sub> (ml·min<sup>-1</sup>·kg<sup>-1</sup>):</label>
                            <span id="VO2max_kg-value" class="slider-value">66.67</span>
                        </div>
                        <input type="range" id="VO2max_kg" class="range-slider" min="30" max="100" value="66.67" step="0.01">
                    </div>
                    
                    <div class="slider-container">
                        <div class="slider-label">
                            <label for="VO2Base">V̇O<sub>2,Base</sub> (ml·min<sup>-1</sup>):</label>
                            <span id="VO2Base-value" class="slider-value">400</span>
                        </div>
                        <input type="range" id="VO2Base" class="range-slider" min="200" max="800" value="400" step="10">
                    </div>
                    
                    <div class="slider-container">
                        <div class="slider-label">
                            <label for="vLamax">vLa<sub>max</sub> (mmol·l<sup>-1</sup>·s<sup>-1</sup>):</label>
                            <span id="vLamax-value" class="slider-value">0.80</span>
                        </div>
                        <input type="range" id="vLamax" class="range-slider" min="0.2" max="1.5" value="0.8" step="0.05">
                    </div>
                    
                    <div class="checkbox-container">
                        <label class="fancy-checkbox">
                            <input type="checkbox" id="weight_based" name="weight_based">
                            <span class="checkmark"></span>
                            Weight-based values
                        </label>
                    </div>
                    </div>
                
                <div class="control-group">
                    <div class="header-section">
                        <div class="control-label">V̇O<sub>2,Base</sub> Calculation</div>
                        <div class="tooltip info-icon">ⓘ
                            <span class="tooltiptext">Calculation of resting oxygen consumption based on anthropometric data.</span>
                        </div>
                    </div>
                    
                    <div class="radio-group">
                        <div class="control-label">Gender:</div>
                        <div class="radio-option">
                            <input type="radio" id="male" name="gender" value="Male" checked>
                            <label for="male">Male</label>
                        </div>
                        <div class="radio-option">
                            <input type="radio" id="female" name="gender" value="Female">
                            <label for="female">Female</label>
                        </div>
                    </div>
                    
                    <div class="slider-container">
                        <div class="slider-label">
                            <label for="body_mass">Body Mass (kg):</label>
                            <span id="body_mass-value" class="slider-value">90.0</span>
                        </div>
                        <input type="range" id="body_mass" class="range-slider" min="40" max="120" value="90" step="0.1">
                    </div>
                    
                    <div class="slider-container">
                        <div class="slider-label">
                            <label for="age">Age (years):</label>
                            <span id="age-value" class="slider-value">28</span>
                        </div>
                        <input type="range" id="age" class="range-slider" min="18" max="100" value="28" step="1">
                    </div>
                    
                    <div class="slider-container">
                        <div class="slider-label">
                            <label for="height">Height (cm):</label>
                            <span id="height-value" class="slider-value">193</span>
                        </div>
                        <input type="range" id="height" class="range-slider" min="140" max="220" value="193" step="1">
                    </div>
                    
                    <button id="calculate_vo2base" type="button">Calculate VO2Base</button>
                    
                    <div class="small-text">Uses the Harris-Benedict equation to estimate basal metabolic rate, which is then converted to oxygen consumption.</div>
                </div>
                
                <div class="control-group">
                    <div class="axis-controls">
                        <div class="card-title">Plot Settings</div>
                        <div>
                            <label class="fancy-checkbox">
                                <input type="checkbox" id="lock_y_axis" name="lock_y_axis" checked>
                                <span class="checkmark"></span>
                                Lock Y-axis
                            </label>
                        </div>
                        <div>
                            <label class="fancy-checkbox">
                                <input type="checkbox" id="lock_x_axis" name="lock_x_axis" checked>
                                <span class="checkmark"></span>
                                Lock X-axis
                            </label>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Tab 2: Exercise Simulation Controls -->
            <div class="tab-content" id="belastungssimulation-content">
                <div class="control-group">
                    <div class="header-section">
                        <div class="control-label">Step Test Simulation Parameters</div>
                        <div class="tooltip info-icon">ⓘ
                            <span class="tooltiptext">Parameters for the step test or exercise simulation.</span>
                        </div>
                    </div>
                    
                    <div class="slider-container">
                        <div class="slider-label">
                            <label for="step_watt">Step Increment (Watts):</label>
                            <span id="step_watt-value" class="slider-value">20</span>
                        </div>
                        <input type="range" id="step_watt" class="range-slider" min="10" max="50" value="20" step="5">
                    </div>
                    
                    <div class="slider-container">
                        <div class="slider-label">
                            <label for="step_duration">Step Duration (s):</label>
                            <span id="step_duration-value" class="slider-value">180</span>
                        </div>
                        <input type="range" id="step_duration" class="range-slider" min="10" max="3600" value="180" step="10">
                    </div>
                    
                    <div class="slider-container">
                        <div class="slider-label">
                            <label for="max_power_step">Maximum Power (Watts):</label>
                            <span id="max_power_step-value" class="slider-value">400</span>
                        </div>
                        <input type="range" id="max_power_step" class="range-slider" min="200" max="600" value="400" step="20">
                    </div>
                    
                    <button id="load_interval_example" type="button">Load Example Exercise Data</button>
                    
                    <div class="file-upload" style="margin-top: 20px;">
                        <label for="power_data" class="file-upload-label">Insert .csv-file with t_s;power;cadence colums</label>
                        <input type="file" id="power_data" accept=".csv,.txt">
                        <div class="file-upload-info">Supported file formats: CSV, TXT</div>
                        <div id="file-name" class="file-name"></div>
                    </div>
                    
                    <div class="checkbox-container">
                        <label class="fancy-checkbox">
                            <input type="checkbox" id="has_header" name="has_header" checked>
                            <span class="checkmark"></span>
                            CSV has headers
                        </label>
                    </div>
                    
                    <div class="checkbox-container">
                        <label class="fancy-checkbox">
                            <input type="checkbox" id="smooth_power" name="smooth_power">
                            <span class="checkmark"></span>
                            Smooth power curve (15-point window)
                        </label>
                    </div>
                </div>
                
                <div class="control-group">
                    <div class="header-section">
                        <div class="control-label">Cadence Dependency</div>
                        <div class="tooltip info-icon">ⓘ
                            <span class="tooltiptext">Incorporate cycling cadence effects for the exercise simulation. This modifies metabolic parameters based on the pedaling rate.</span>
                        </div>
                    </div>
                    
                    <div class="checkbox-container">
                        <label class="fancy-checkbox">
                            <input type="checkbox" id="cadence_dependent_step" name="cadence_dependent_step">
                            <span class="checkmark"></span>
                            Enable Cadence Dependency
                        </label>
                    </div>
                    
                    <div id="cadence-controls-step" style="display:none;">
                        <div class="slider-container">
                            <div class="slider-label">
                                <label for="cadence_step">Fixed Cadence (rpm):</label>
                                <span id="cadence_step-value" class="slider-value">90</span>
                            </div>
                            <input type="range" id="cadence_step" class="range-slider" min="20" max="200" value="90" step="1">
                        </div>
                        
                        <div class="checkbox-container">
                            <label class="fancy-checkbox">
                                <input type="checkbox" id="use_file_cadence" name="use_file_cadence" checked>
                                <span class="checkmark"></span>
                                Use cadence from file (if available)
                                <div class="tooltip info-icon" style="margin-left: 5px;">ⓘ
                                    <span class="tooltiptext">If checked and available in the uploaded data, cadence values from the file will be used instead of the fixed value above.</span>
                                </div>
                            </label>
                        </div>
                        
                        <div class="parameter-row">
                            <div class="parameter-label">CE (CEVO<sub>2</sub>) Dependency:</div>
                            <div class="tooltip info-icon">ⓘ
                                <span class="tooltiptext">Formula: CEVO<sub>2</sub>(rpm) = 0.0004 · rpm² - 0.094 · rpm + 16.857</span>
                            </div>
                            <span class="slider-value">✓</span>
                        </div>
                        
                        <div class="parameter-row">
                            <div class="parameter-label">VO<sub>2,Base</sub> Dependency:</div>
                            <div class="tooltip info-icon">ⓘ
                                <span class="tooltiptext">Formula: VO<sub>2,Base</sub>(rpm) = 0.172 · rpm² - 14.460 · rpm + 548.039</span>
                            </div>
                            <span class="slider-value">✓</span>
                        </div>
                        
                        <div class="checkbox-container">
                            <label class="fancy-checkbox">
                                <input type="checkbox" id="vo2max_dependent_step" name="vo2max_dependent_step">
                                <span class="checkmark"></span>
                                Include VO<sub>2,max</sub> Dependency
                            </label>
                        </div>
                        
                        <div class="checkbox-container">
                            <label class="fancy-checkbox">
                                <input type="checkbox" id="vlamax_dependent_step" name="vlamax_dependent_step">
                                <span class="checkmark"></span>
                                Include vLa<sub>max</sub> Dependency
                            </label>
                        </div>
                    </div>
                    
                    <div class="small-text">Based on the research from Dunst et al. (2025) showing how metabolic parameters vary with cycling cadence.</div>
                </div>
                
                <div class="control-group">
                    <div class="header-section">
                        <div class="control-label">Physiological Parameters</div>
                        <div class="tooltip info-icon">ⓘ
                            <span class="tooltiptext">Physiological parameters for the simulation calculation.</span>
                        </div>
                    </div>
                    
                    <div class="slider-container">
                        <div class="slider-label">
                            <label for="vo2_up_time_constant">V̇O<sub>2,on</sub> time constant (s):</label>
                            <span id="vo2_up_time_constant-value" class="slider-value">30</span>
                        </div>
                        <input type="range" id="vo2_up_time_constant" class="range-slider" min="15" max="60" value="30" step="1">
                    </div>
                    
                    <div class="slider-container">
                        <div class="slider-label">
                            <label for="vo2_down_time_constant">V̇O<sub>2,off</sub> time constant (s):</label>
                            <span id="vo2_down_time_constant-value" class="slider-value">30</span>
                        </div>
                        <input type="range" id="vo2_down_time_constant" class="range-slider" min="15" max="60" value="30" step="1">
                    </div>
                    
                    <div class="slider-container">
                        <div class="slider-label">
                            <label for="la_max">BLC exercise termination value (mmol/l):</label>
                            <span id="la_max-value" class="slider-value">20.0</span>
                        </div>
                        <input type="range" id="la_max" class="range-slider" min="4" max="30" value="20" step="0.5">
                    </div>
                    
                    <div class="slider-container">
                        <div class="slider-label">
                            <label for="la_base">Resting BLC-value (mmol/l):</label>
                            <span id="la_base-value" class="slider-value">0.8</span>
                        </div>
                        <input type="range" id="la_base" class="range-slider" min="0.5" max="2" value="0.8" step="0.1">
                    </div>
                </div>
                
                <div class="control-group">
                    <div class="header-section">
                        <div class="control-label">W' Balance Parameters</div>
                        <div class="tooltip info-icon">ⓘ
                            <span class="tooltiptext">Parameters for the W' balance model calculation.</span>
                        </div>
                    </div>
                    
                    <div class="slider-container">
                        <div class="slider-label">
                            <label for="critical_power">Critical Power (CP) (W):</label>
                            <span id="critical_power-value" class="slider-value">365</span>
                        </div>
                        <input type="range" id="critical_power" class="range-slider" min="100" max="500" value="365" step="5">
                    </div>
                    
                    <div class="slider-container">
                        <div class="slider-label">
                            <label for="w_prime">W' (kJ):</label>
                            <span id="w_prime-value" class="slider-value">20.0</span>
                        </div>
                        <input type="range" id="w_prime" class="range-slider" min="5" max="40" value="20" step="0.5">
                    </div>
                    
                    <div class="checkbox-container">
                        <label class="fancy-checkbox">
                            <input type="checkbox" id="use_mlss_as_cp" name="use_mlss_as_cp" checked="checked">
                            <span class="checkmark"></span>
                            Use MLSS from Tab 1 as Critical Power
                            <div class="tooltip info-icon" style="margin-left: 5px;">ⓘ
                                <span class="tooltiptext">When checked, Critical Power will automatically update to match the MLSS value from Tab 1.</span>
                            </div>
                        </label>
                    </div>
                    
                    <div class="model-info">
                        <p>W' Balance model (Skiba):</p>
                        <p>W'<sub>BAL</sub>(t) = W' - ∫<sub>0</sub><sup>t</sup>(W'<sub>EXP</sub> · e<sup>-(t-u)/τ<sub>W'</sub></sup>)du</p>
                        <p>Where τ<sub>W'</sub> = 546·e<sup>(-0.01·DCP)</sup> + 316</p>
                    </div>
                </div>
                
                <div class="control-group">
                  <div class="header-section">
                      <div class="control-label">Model Parameters</div>
                      <div class="tooltip info-icon">ⓘ
                          <span class="tooltiptext">Parameters for the metabolic model of the simulation.</span>
                      </div>
                  </div>
                  
                  <div class="checkbox-container">
                      <label class="fancy-checkbox">
                          <input type="checkbox" id="use_tab1_params" name="use_tab1_params" checked="checked">
                          <span class="checkmark"></span>
                          Use model parameters from Tab 1
                      </label>
                  </div>
                  
                  <!-- Individual parameters if not imported -->
                  <div id="individual-params" style="display:block;">
                      <div class="checkbox-container">
                          <label class="fancy-checkbox">
                              <input type="checkbox" id="curvilinear_step" name="curvilinear_step">
                              <span class="checkmark"></span>
                              Curvilinear CE relationship
                              <div class="tooltip info-icon" style="margin-left: 5px;">ⓘ
                                  <span class="tooltiptext">Based on the curvilinear relationship between power output and energy consumption.</span>
                              </div>
                          </label>
                      </div>
                      
                      <div id="linear-ce-control-step" class="slider-container">
                          <div class="slider-label">
                              <label for="CEVO2_step">CE (ml·min<sup>-1</sup>·W<sup>-1</sup>):</label>
                              <span id="CEVO2_step-value" class="slider-value">11.0</span>
                          </div>
                          <input type="range" id="CEVO2_step" class="range-slider" min="8" max="15" value="11" step="0.1">
                      </div>
                      
                      <div id="curvilinear-ce-control-step" class="slider-container" style="display:none;">
                          <div class="slider-label">
                              <label for="CE_range_start_step">CE Start (ml·min<sup>-1</sup>·W<sup>-1</sup>):</label>
                              <span id="CE_range_start_step-value" class="slider-value">11.0</span>
                          </div>
                          <input type="range" id="CE_range_start_step" class="range-slider" min="8" max="15" value="11" step="0.1">
                          
                          <div class="slider-label">
                              <label for="CE_range_end_step">CE Target (ml·min<sup>-1</sup>·W<sup>-1</sup>):</label>
                              <span id="CE_range_end_step-value" class="slider-value">12.0</span>
                          </div>
                          <input type="range" id="CE_range_end_step" class="range-slider" min="8" max="15" value="12" step="0.1">
                      </div>
                      
                      <div class="slider-container">
                          <div class="slider-label">
                              <label for="VO2max_step">V̇O<sub>2,max</sub> (ml·min<sup>-1</sup>):</label>
                              <span id="VO2max_step-value" class="slider-value">6000</span>
                          </div>
                          <input type="range" id="VO2max_step" class="range-slider" min="2000" max="7500" value="6000" step="10">
                      </div>
                      
                      <div class="slider-container">
                          <div class="slider-label">
                              <label for="VO2Base_step">V̇O<sub>2,Base</sub> (ml·min<sup>-1</sup>):</label>
                              <span id="VO2Base_step-value" class="slider-value">400</span>
                          </div>
                          <input type="range" id="VO2Base_step" class="range-slider" min="200" max="800" value="400" step="10">
                      </div>
                      
                      <div class="slider-container">
                          <div class="slider-label">
                              <label for="vLamax_step">vLa<sub>max</sub> (mmol·l<sup>-1</sup>·s<sup>-1</sup>):</label>
                              <span id="vLamax_step-value" class="slider-value">0.80</span>
                          </div>
                          <input type="range" id="vLamax_step" class="range-slider" min="0.2" max="1.5" value="0.8" step="0.05">
                      </div>
                      
                      <div class="slider-container">
                          <div class="slider-label">
                              <label for="body_mass_step">Body Mass (kg):</label>
                              <span id="body_mass_step-value" class="slider-value">90.0</span>
                          </div>
                          <input type="range" id="body_mass_step" class="range-slider" min="40" max="120" value="90" step="0.1">
                      </div>
                  </div>
                  </div>
            </div>
        </div>
        
        <div class="main-content">
            <div id="leistungsdiagramm-tab" class="tab-content active">
                <div id="plot-container"></div>
                <div id="values-container"></div>
            </div>
            
            <div id="belastungssimulation-tab" class="tab-content">
                <div id="steptest-plot-container"></div>
            </div>
        </div>
    </div>
    
    <div id="notification" class="notification"></div>
</body>
</html>

<script>
    // App state management
    const appState = {
        // Tab 1 Parameters
        CEVO2: 11.0,
        CE_range: [11.0, 12.0],
        VO2max: 6300,           
        VO2max_kg: 70.80,       
        VO2Base: 386,
        vLamax: 0.85,           
        body_mass: 89.0,        
        gender: 'Male',
        age: 29,                
        height: 193,
        curvilinear: false,
        weight_based: false,
        lock_y_axis: true,
        lock_x_axis: true,
        calculated_vo2base: null,
        
        // Cadence Dependency Tab 1
        cadence_dependent: false,
        cadence: 80,
        vo2max_dependent: false,
        vlamax_dependent: false,
        
        // Tab 2 Parameters
        step_watt: 20,
        step_duration: 180,
        max_power_step: 400,
        vo2_up_time_constant: 30,
        vo2_down_time_constant: 30,
        la_max: 20,
        la_base: 0.8,
        smooth_power: false,
        has_header: true,
        separator: ';',
        use_tab1_params: true,
        CEVO2_step: 11.0,
        curvilinear_step: false,
        CE_range_step: [11.0, 12.0],
        VO2max_step: 6300,      
        VO2Base_step: 400,
        vLamax_step: 0.85,      
        body_mass_step: 89.0,   
        critical_power: 365,
        w_prime: 20.0,
        use_mlss_as_cp: true,
        
        // Cadence Dependency Tab 2
        cadence_dependent_step: false,
        cadence_step: 80,
        vo2max_dependent_step: false,
        vlamax_dependent_step: false,
        use_file_cadence: false,
        
        // Interval Data
        interval_data: null,
        power_data: null,
        
        // Cache for MLSS
        mlss_value: null
        };
        
        // DOM elements for Tab 1
        const elements = {
            // Tab Navigation
            tabs: document.querySelectorAll('.tab'),
            tabContents: document.querySelectorAll('.tab-content'),
            tabContentLeistungsdiagramm: document.getElementById('leistungsdiagramm-content'),
            tabContentBelastungssimulation: document.getElementById('belastungssimulation-content'),
            leistungsdiagrammTab: document.getElementById('leistungsdiagramm-tab'),
            belastungssimulationTab: document.getElementById('belastungssimulation-tab'),
            
            // Tab 1 Elements
            CEVO2: document.getElementById('CEVO2'),
            CEVO2Value: document.getElementById('CEVO2-value'),
            CE_range_start: document.getElementById('CE_range_start'),
            CE_range_startValue: document.getElementById('CE_range_start-value'),
            CE_range_end: document.getElementById('CE_range_end'),
            CE_range_endValue: document.getElementById('CE_range_end-value'),
            VO2max: document.getElementById('VO2max'),
            VO2maxValue: document.getElementById('VO2max-value'),
            VO2max_kg: document.getElementById('VO2max_kg'),
            VO2max_kgValue: document.getElementById('VO2max_kg-value'),
            VO2Base: document.getElementById('VO2Base'),
            VO2BaseValue: document.getElementById('VO2Base-value'),
            vLamax: document.getElementById('vLamax'),
            vLamaxValue: document.getElementById('vLamax-value'),
            body_mass: document.getElementById('body_mass'),
            body_massValue: document.getElementById('body_mass-value'),
            age: document.getElementById('age'),
            ageValue: document.getElementById('age-value'),
            height: document.getElementById('height'),
            heightValue: document.getElementById('height-value'),
            male: document.getElementById('male'),
            female: document.getElementById('female'),
            curvilinear: document.getElementById('curvilinear'),
            weight_based: document.getElementById('weight_based'),
            lock_y_axis: document.getElementById('lock_y_axis'),
            lock_x_axis: document.getElementById('lock_x_axis'),
            calculate_vo2base: document.getElementById('calculate_vo2base'),
            linearCeControl: document.getElementById('linear-ce-control'),
            curvilinearCeControl: document.getElementById('curvilinear-ce-control'),
            plotContainer: document.getElementById('plot-container'),
            valuesContainer: document.getElementById('values-container'),
            
            // Cadence Dependency Tab 1
            cadence_dependent: document.getElementById('cadence_dependent'),
            cadence: document.getElementById('cadence'),
            cadenceValue: document.getElementById('cadence-value'),
            cadenceControls: document.getElementById('cadence-controls'),
            vo2max_dependent: document.getElementById('vo2max_dependent'),
            vlamax_dependent: document.getElementById('vlamax_dependent'),
            
            // Tab 2 Elements
            step_watt: document.getElementById('step_watt'),
            step_wattValue: document.getElementById('step_watt-value'),
            step_duration: document.getElementById('step_duration'),
            step_durationValue: document.getElementById('step_duration-value'),
            max_power_step: document.getElementById('max_power_step'),
            max_power_stepValue: document.getElementById('max_power_step-value'),
            vo2_up_time_constant: document.getElementById('vo2_up_time_constant'),
            vo2_up_time_constantValue: document.getElementById('vo2_up_time_constant-value'),
            vo2_down_time_constant: document.getElementById('vo2_down_time_constant'),
            vo2_down_time_constantValue: document.getElementById('vo2_down_time_constant-value'),
            la_max: document.getElementById('la_max'),
            la_maxValue: document.getElementById('la_max-value'),
            la_base: document.getElementById('la_base'),
            la_baseValue: document.getElementById('la_base-value'),
            critical_power: document.getElementById('critical_power'),
            critical_powerValue: document.getElementById('critical_power-value'),
            w_prime: document.getElementById('w_prime'),
            w_primeValue: document.getElementById('w_prime-value'),
            use_mlss_as_cp: document.getElementById('use_mlss_as_cp'),
            load_interval_example: document.getElementById('load_interval_example'),
            power_data: document.getElementById('power_data'),
            fileName: document.getElementById('file-name'),
            has_header: document.getElementById('has_header'),
            separator_semicolon: document.getElementById('separator_semicolon'),
            separator_comma: document.getElementById('separator_comma'),
            separator_tab: document.getElementById('separator_tab'),
            smooth_power: document.getElementById('smooth_power'),
            use_tab1_params: document.getElementById('use_tab1_params'),
            individual_params: document.getElementById('individual-params'),
            CEVO2_step: document.getElementById('CEVO2_step'),
            CEVO2_stepValue: document.getElementById('CEVO2_step-value'),
            curvilinear_step: document.getElementById('curvilinear_step'),
            linearCeControlStep: document.getElementById('linear-ce-control-step'),
            curvilinearCeControlStep: document.getElementById('curvilinear-ce-control-step'),
            CE_range_start_step: document.getElementById('CE_range_start_step'),
            CE_range_start_stepValue: document.getElementById('CE_range_start_step-value'),
            CE_range_end_step: document.getElementById('CE_range_end_step'),
            CE_range_end_stepValue: document.getElementById('CE_range_end_step-value'),
            VO2max_step: document.getElementById('VO2max_step'),
            VO2max_stepValue: document.getElementById('VO2max_step-value'),
            VO2Base_step: document.getElementById('VO2Base_step'),
            VO2Base_stepValue: document.getElementById('VO2Base_step-value'),
            vLamax_step: document.getElementById('vLamax_step'),
            vLamax_stepValue: document.getElementById('vLamax_step-value'),
            body_mass_step: document.getElementById('body_mass_step'),
            body_mass_stepValue: document.getElementById('body_mass_step-value'),
            steptestPlotContainer: document.getElementById('steptest-plot-container'),
            
            // Cadence Dependency Tab 2
            cadence_dependent_step: document.getElementById('cadence_dependent_step'),
            cadence_step: document.getElementById('cadence_step'),
            cadence_stepValue: document.getElementById('cadence_step-value'),
            cadenceControlsStep: document.getElementById('cadence-controls-step'),
            vo2max_dependent_step: document.getElementById('vo2max_dependent_step'),
            vlamax_dependent_step: document.getElementById('vlamax_dependent_step'),
            use_file_cadence: document.getElementById('use_file_cadence'),
            
            // Notification
            notification: document.getElementById('notification')
        };
    
    // Tab switching logic
    elements.tabs.forEach(tab => {
        tab.addEventListener('click', () => {
            const tabName = tab.getAttribute('data-tab');
            
            // Deactivate all tabs and contents
            elements.tabs.forEach(t => t.classList.remove('active'));
            elements.tabContents.forEach(c => c.classList.remove('active'));
            document.getElementById('leistungsdiagramm-tab').classList.remove('active');
            document.getElementById('belastungssimulation-tab').classList.remove('active');
            
            // Activate selected tab and content
            tab.classList.add('active');
            document.getElementById(`${tabName}-content`).classList.add('active');
            document.getElementById(`${tabName}-tab`).classList.add('active');
            
            // If switching to belastungssimulation tab, update step test plot
            if (tabName === 'belastungssimulation') {
                // Check if CP should be set to MLSS
                if (appState.use_mlss_as_cp && appState.mlss_value) {
                    appState.critical_power = appState.mlss_value;
                    elements.critical_power.value = appState.critical_power;
                    elements.critical_powerValue.textContent = appState.critical_power;
                }
                updateStepTestPlot();
            } else {
                updatePlot();
            }
        });
    });
    
    // Function to calculate basal metabolic rate (BMR)
    function calculateBMR(gender, mass, height, age) {
        if (gender === 'Male') {
            return 66.5 + (13.75 * mass) + (5.003 * height) - (6.775 * age);
        } else {
            return 655.1 + (9.563 * mass) + (1.850 * height) - (4.676 * age);
        }
    }
    
    // Function to calculate VO2Base from BMR
    function calculateVO2Base(kcalDay, gender) {
        const ka = 19.946;
        const factor = gender === 'Male' ? 1.287 : 1.278;
        return (kcalDay / (24 * 60 * ka)) * 4.1868 * factor * 1000;
    }
    
    // Function to find optimal 'a' coefficient for curvilinear relationship
    function findOptimalA(startCE, targetCE, VO2max, VO2Base) {
        const objective = function(a) {
            const b = startCE;
            const c = VO2Base - VO2max;
            const discriminant = b*b - 4*a*c;
            if (discriminant < 0) return 1e6;
            const xIntersect = (-b + Math.sqrt(discriminant))/(2*a);
            if (xIntersect <= 0) return 1e6;
            const slopeAtIntersection = 2*a*xIntersect + startCE;
            return Math.pow(slopeAtIntersection - targetCE, 2);
        };
        
        // Simple optimization algorithm
        let aMin = 0.001;
        let aMax = 0.1;
        let iterations = 100;
        let step = (aMax - aMin) / iterations;
        let bestA = aMin;
        let bestError = objective(aMin);
        
        for (let i = 1; i <= iterations; i++) {
            const a = aMin + i * step;
            const error = objective(a);
            if (error < bestError) {
                bestError = error;
                bestA = a;
            }
        }
        
        return bestA;
    }
    
    // Function to smooth data with a rolling window
    function smoothData(data, windowSize) {
        if (!Array.isArray(data) || data.length < windowSize) {
            return data;
        }
        
        const result = [];
        
        for (let i = 0; i < data.length; i++) {
            let sum = 0;
            let count = 0;
            
            for (let j = Math.max(0, i - Math.floor(windowSize/2)); 
                 j <= Math.min(data.length - 1, i + Math.floor(windowSize/2)); 
                 j++) {
                sum += data[j];
                count++;
            }
            
            result.push(sum / count);
        }
        
        return result;
    }
    
    // Cadence-dependent functions from Dunst et al. paper
    function calculateCadenceDependentCEVO2(cadence) {
        // Formula from paper: CEVȮ2(PR) = 0.0004 * PR² - 0.094 * PR + 16.857
        return 0.0004 * Math.pow(cadence, 2) - 0.094 * cadence + 16.857;
    }
    
    function calculateCadenceDependentVO2Base(cadence) {
        // Formula from paper: VȮ2Base(PR) = 0.172 * PR² - 14.460 * PR + 548.039
        return 0.172 * Math.pow(cadence, 2) - 14.460 * cadence + 548.039;
    }
    
    function calculateCadenceDependentVLamax(cadence, baseVLamax) {
        // Formula from paper: vLamax(PR) = -0.0002 * PR² + 0.00931 * PR
        // We need to scale this to match the current vLamax at the default cadence (90 rpm)
        const scaleVLamax = baseVLamax / (-0.0002 * Math.pow(90, 2) + 0.00931 * 90);
        return (-0.0002 * Math.pow(cadence, 2) + 0.00931 * cadence) * scaleVLamax;
    }
    
    function calculateCadenceDependentVO2max(cadence, baseVO2max) {
        // Based on Figure 4 in the paper - simplified approximation
        // Optimal cadence around 85 rpm, with reduction at lower and higher cadences
        const relVO2max = Math.max(0.85, Math.min(1.0, 0.85 + 0.15 * (1 - Math.pow((cadence - 85) / 100, 2))));
        return baseVO2max * relVO2max;
    }
    
    // Main function to calculate metabolic values for Tab 1
    function calculateValues() {
        // Apply cadence dependency if enabled
        let effectiveCEVO2 = appState.CEVO2;
        let effectiveVO2Base = appState.VO2Base;
        let effectiveVLamax = appState.vLamax;
        let effectiveVO2max = appState.VO2max;
        
        // Apply cadence dependency if enabled
        if (appState.cadence_dependent) {
            // CE and VO2Base dependency are always applied when cadence dependency is enabled
            effectiveCEVO2 = calculateCadenceDependentCEVO2(appState.cadence);
            effectiveVO2Base = calculateCadenceDependentVO2Base(appState.cadence);
            
            // Optional vLamax dependency
            if (appState.vlamax_dependent) {
                effectiveVLamax = calculateCadenceDependentVLamax(appState.cadence, appState.vLamax);
            }
            
            // Optional VO2max dependency
            if (appState.vo2max_dependent) {
                effectiveVO2max = calculateCadenceDependentVO2max(appState.cadence, appState.VO2max);
            }
        }
        
        const CELaO2 = 0.02049 / appState.body_mass;
        const VolLa = 0.4;
        const ks1 = 0.0635;
        const ks2 = Math.pow(1.1, 3);
        
        // Calculate max power with linear CE value
        const maxPower = appState.curvilinear ? 
            ((effectiveVO2max - effectiveVO2Base) / appState.CE_range[0]) * 1.7 :
            ((effectiveVO2max - effectiveVO2Base) / effectiveCEVO2) * 1.7;
        
        // Create power array (extended by 70% to ensure dotted lines reach further)
        const P = Array.from({length: Math.ceil(maxPower) + 1}, (_, i) => i);
        
        let VO2ss_unlimited;
        let aOpt = null;
        
        if (appState.curvilinear) {
            // Calculate optimal coefficient for curvilinear relationship
            aOpt = findOptimalA(appState.CE_range[0], appState.CE_range[1], effectiveVO2max, effectiveVO2Base);
            
            // Curvilinear VO2ss calculation
            VO2ss_unlimited = P.map(p => aOpt * p * p + appState.CE_range[0] * p + effectiveVO2Base);
        } else {
            // Linear VO2ss calculation
            VO2ss_unlimited = P.map(p => effectiveCEVO2 * p + effectiveVO2Base);
        }
        
        // Find where VO2ss crosses VO2max
        const crossIndices = VO2ss_unlimited.findIndex(v => v >= effectiveVO2max);
        const crossPoint = crossIndices !== -1 ? crossIndices : VO2ss_unlimited.length;
        
        // Limit VO2ss to VO2max
        const VO2ss = VO2ss_unlimited.map(v => Math.min(v, effectiveVO2max));
        
        // Calculate vLass
        const vLass = VO2ss.map(vo2 => 
            effectiveVLamax / (1 + ks2 * Math.pow((effectiveVO2max - vo2)/(ks1 * vo2), 3/2))
        );
        
        // Calculate vLaox
        const vLaox = VO2ss_unlimited.map(vo2 => (CELaO2 * vo2) / (VolLa * 60));
        
        // Calculate pyruvate deficit
        const PD = vLaox.map((ox, i) => ox - vLass[i]);
        
        // Convert to minutes for display
        const vLass_min = vLass.map(v => v * 60);
        const vLaox_min = vLaox.map(v => v * 60);
        const PD_min = PD.map(p => p * 60);
        
        // Calculate lactate accumulation
        const La_accum = [];
        for (let i = 0; i < P.length; i++) {
            if (i === 0) {
                La_accum.push(Math.max(0, (vLass[i] - vLaox[i])));
            } else {
                La_accum.push(La_accum[i-1] + Math.max(0, (vLass[i] - vLaox[i])));
            }
        }
        
        // Set initial values to NA
        const startIdx = La_accum.findIndex(la => la > 0);
        if (startIdx !== -1) {
            for (let i = 0; i < startIdx; i++) {
                La_accum[i] = NaN;
            }
        }
        
        // Find important points
        const pdMaxPos = P[PD_min.indexOf(Math.max(...PD_min))];
        
        // Find closest to zero (MLSS)
        let minAbsPD = Infinity;
        let pdZeroPos = 0;
        for (let i = 0; i < PD_min.length; i++) {
            const absPD = Math.abs(PD_min[i]);
            if (absPD < minAbsPD) {
                minAbsPD = absPD;
                pdZeroPos = P[i];
            }
        }
        
        // Store previous MLSS value
        const oldMlssValue = appState.mlss_value;
        // Update MLSS value
        appState.mlss_value = pdZeroPos;
        
        // If MLSS value has changed and use_mlss_as_cp is active,
        // update CP value immediately whether in Tab 1 or Tab 2
        if (oldMlssValue !== pdZeroPos) {
            if (appState.use_mlss_as_cp) {
                // Update CP to match new MLSS value
                appState.critical_power = pdZeroPos;
                if (elements.critical_power) {
                    elements.critical_power.value = pdZeroPos;
                    elements.critical_powerValue.textContent = pdZeroPos;
                    elements.critical_power.disabled = true;
                }
            }
        }
        
        return {
            P,
            VO2ss,
            VO2ss_unlimited,
            crossPoint,
            vLass_min,
            vLaox_min,
            PD_min,
            La_accum,
            pd_max_pos: pdMaxPos,
            pd_zero_pos: pdZeroPos,
            max_power: maxPower,
            a_opt: aOpt,
            effective_values: {
                CEVO2: effectiveCEVO2,
                VO2Base: effectiveVO2Base,
                vLamax: effectiveVLamax,
                VO2max: effectiveVO2max
            }
        };
    }
    
    // Function to update the plot in Tab 1
    function updatePlot() {
        const vals = calculateValues();
        
        // Calculate relative values based on body weight
        const relVO2max = vals.effective_values.VO2max / appState.body_mass;
        const relPower = vals.P.map(p => p / appState.body_mass);
        const relVO2ss = vals.VO2ss.map(vo2 => vo2 / appState.body_mass);
        const relVO2ss_unlimited = vals.VO2ss_unlimited.map(vo2 => vo2 / appState.body_mass);
        const relPdMaxPos = vals.pd_max_pos / appState.body_mass;
        const relPdZeroPos = vals.pd_zero_pos / appState.body_mass;
        
        // Choose display values based on weight-based setting
        const displayPower = appState.weight_based ? relPower : vals.P;
        const displayVO2ss = appState.weight_based ? relVO2ss : vals.VO2ss;
        const displayVO2ss_unlimited = appState.weight_based ? relVO2ss_unlimited : vals.VO2ss_unlimited;
        const displayVO2max = appState.weight_based ? relVO2max : vals.effective_values.VO2max;
        const displayPdMaxPos = appState.weight_based ? relPdMaxPos : vals.pd_max_pos;
        const displayPdZeroPos = appState.weight_based ? relPdZeroPos : vals.pd_zero_pos;
        
        const y1Max = displayVO2max * 1.25;
        const xMax = Math.max(...displayPower);
        const xMid = xMax / 2;
        
        // Create traces for the plot
        const traces = [];
        
        // VO2max horizontal line
        traces.push({
            x: displayPower,
            y: Array(displayPower.length).fill(displayVO2max),
            name: "VO2max",
            type: 'scatter',
            mode: 'lines',
            line: {color: '#CCCCCC', dash: 'dot', width: 1},
            showlegend: false
        });
        
        // FATmax vertical line
        if (displayPdMaxPos >= Math.min(...displayPower) && displayPdMaxPos <= Math.max(...displayPower)) {
            traces.push({
                x: [displayPdMaxPos, displayPdMaxPos],
                y: [0, 20],
                name: "FATmax",
                type: 'scatter',
                mode: 'lines',
                line: {color: '#CCCCCC', dash: 'dot', width: 1},
                showlegend: false,
                yaxis: 'y2'
            });
        }
        
        // MLSS vertical line
        if (displayPdZeroPos >= Math.min(...displayPower) && displayPdZeroPos <= Math.max(...displayPower)) {
            traces.push({
                x: [displayPdZeroPos, displayPdZeroPos],
                y: [0, 20],
                name: "MLSS",
                type: 'scatter',
                mode: 'lines',
                line: {color: '#CCCCCC', dash: 'dot', width: 1},
                showlegend: false,
                yaxis: 'y2'
            });
        }
        
        // VO2ss Curve
        if (vals.crossPoint > 1) {
            traces.push({
                x: displayPower.slice(0, vals.crossPoint),
                y: displayVO2ss_unlimited.slice(0, vals.crossPoint),
                name: "VO2ss",
                type: 'scatter',
                mode: 'lines',
                line: {color: '#2683C6', width: 3},
                showlegend: true
            });
            
            if (vals.crossPoint < displayPower.length) {
                traces.push({
                    x: displayPower.slice(vals.crossPoint),
                    y: displayVO2ss_unlimited.slice(vals.crossPoint),
                    name: "VO2ss (extrapolated)",
                    type: 'scatter',
                    mode: 'lines',
                    line: {color: '#2683C6', dash: 'dash', width: 3},
                    showlegend: true
                });
            }
        }
        
        // Lactate rates and accumulation
        traces.push({
            x: displayPower,
            y: vals.vLass_min,
            name: "vLass",
            type: 'scatter',
            mode: 'lines',
            yaxis: 'y2',
            line: {color: '#EF5350', dash: 'dash', width: 2},
            showlegend: true
        });
        
        traces.push({
            x: displayPower,
            y: vals.vLaox_min,
            name: "vLaox",
            type: 'scatter',
            mode: 'lines',
            yaxis: 'y2',
            line: {color: '#1CADE4', dash: 'dash', width: 2},
            showlegend: true
        });
        
        traces.push({
            x: displayPower,
            y: vals.PD_min,
            name: "PD",
            type: 'scatter',
            mode: 'lines',
            yaxis: 'y2',
            line: {color: "#9C85C0", width: 3},
            showlegend: true
        });
        
        traces.push({
            x: displayPower,
            y: vals.La_accum,
            name: "La Accumulation",
            type: 'scatter',
            mode: 'lines',
            yaxis: 'y2',
            line: {color: '#C8133B', width: 3},
            showlegend: true
        });
        
        // Annotations
        const annotations = [];
        
        annotations.push(
            {
                x: xMid,
                y: displayVO2max + (y1Max - displayVO2max) * 0.1,
                text: `VO2max: ${relVO2max.toFixed(1)} ml·min<sup>-1</sup>·kg<sup>-1</sup>`,
                showarrow: false,
                font: {color: '#666666'},
                xanchor: "center"
            },
            {
                x: displayPdMaxPos,
                y: y1Max * 0.90,
                text: `FATmax<br>${appState.weight_based ? displayPdMaxPos.toFixed(1) : Math.round(displayPdMaxPos)} ${appState.weight_based ? "W·kg<sup>-1</sup>" : "W"}`,
                showarrow: false,
                font: {color: '#666666'},
                xanchor: "center"
            },
            {
                x: displayPdZeroPos,
                y: y1Max * 0.90,
                text: `MLSS<br>${appState.weight_based ? displayPdZeroPos.toFixed(1) : Math.round(displayPdZeroPos)} ${appState.weight_based ? "W·kg<sup>-1</sup>" : "W"}`,
                showarrow: false,
                font: {color: '#666666'},
                xanchor: "center"
            }
        );
        
        // Formula text
        let formulaText = '';
        if (appState.curvilinear) {
            if (appState.weight_based) {
                formulaText = `VO<sub>2,SS</sub>(P) = ${vals.a_opt.toFixed(4)} · P² + ${appState.CE_range[0].toFixed(1)} · P + ${(vals.effective_values.VO2Base/appState.body_mass).toFixed(1)}`;
            } else {
                formulaText = `VO<sub>2,SS</sub>(P) = ${vals.a_opt.toFixed(4)} · P² + ${appState.CE_range[0].toFixed(1)} · P + ${Math.round(vals.effective_values.VO2Base)}`;
            }
        } else {
            if (appState.weight_based) {
                formulaText = `VO<sub>2,SS</sub>(P) = ${vals.effective_values.CEVO2.toFixed(1)} · P + ${(vals.effective_values.VO2Base/appState.body_mass).toFixed(1)}`;
            } else {
                formulaText = `VO<sub>2,SS</sub>(P) = ${vals.effective_values.CEVO2.toFixed(1)} · P + ${Math.round(vals.effective_values.VO2Base)}`;
            }
        }
        
        // Add cadence info if cadence dependency is enabled
        if (appState.cadence_dependent) {
            formulaText += `<br>(at cadence: ${appState.cadence} rpm)`;
        }
        
        // Add formula annotation
        annotations.push({
            x: xMax * 0.10,
            y: displayVO2max + (y1Max - displayVO2max) * 0.1,
            text: formulaText,
            showarrow: false,
            font: {
                family: "Arial",
                size: 12,
                color: "#666666"
            },
            xanchor: "center",
            yanchor: "middle"
        });
        
        // Fixed y-axis ranges for locked mode
        const fixedYAxisRange = appState.weight_based ? [0, 100] : [0, 7500];
        
        // Set axis ranges based on lock settings
        const xaxisRange = appState.lock_x_axis ? 
            (appState.weight_based ? [0, 600/appState.body_mass] : [0, 600]) : 
            [0, Math.max(...displayPower) * 1.05];
        const yaxisRange = appState.lock_y_axis ? fixedYAxisRange : [0, Math.max(...displayVO2ss_unlimited) * 1.1];
        
        // Layout for normal axes
        const layout = {
            title: {
                text: "VO2ss, vLass, vLaox, PD and Lactate Accumulation",
                font: {
                    size: 18,
                    color: '#2683C6'
                }
            },
            margin: {l: 60, r: 60, t: 60, b: 80},
            xaxis: {
                title: {
                    text: `Power (${appState.weight_based ? "W·kg<sup>-1</sup>" : "W"})`,
                    font: {
                        size: 14
                    }
                },
                range: xaxisRange,
                showgrid: true,
                gridcolor: 'rgba(200,200,200,0.2)'
            },
            yaxis: {
                title: {
                    text: `VO2ss (${appState.weight_based ? "ml·min<sup>-1</sup>·kg<sup>-1</sup>" : "ml·min<sup>-1</sup>"})`,
                    font: {
                        size: 14
                    }
                },
                side: "left",
                range: yaxisRange,
                showgrid: true,
                gridcolor: 'rgba(200,200,200,0.2)'
            },
            yaxis2: {
                title: {
                    text: "Lactate Rates (mmol·l<sup>-1</sup>·min<sup>-1</sup>) & Accumulation (mmol·l<sup>-1</sup>)",
                    font: {
                        size: 14
                    }
                },
                overlaying: "y",
                side: "right",
                range: [0, 14],
                showgrid: false,
                dtick: 2
            },
            showlegend: true,
            legend: {
                x: 0.5,
                y: 1.05,
                xanchor: 'center',
                yanchor: 'top',
                orientation: 'h',
                bgcolor: 'rgba(255, 255, 255, 0)',
                bordercolor: 'rgba(0,0,0,0)',
                borderwidth: 0
            },
            annotations: annotations,
            paper_bgcolor: 'rgba(255,255,255,0)',
            plot_bgcolor: 'rgba(255,255,255,0.5)',
            hovermode: 'closest'
        };
        
        // Create a new plot with consistent settings each time
        Plotly.newPlot('plot-container', traces, layout, {
            displayModeBar: true,
            responsive: true
        });
        
        // Update the values container with correct formatting
        updateValuesDisplay(vals);
    }

    // Function to update the values display in Tab 1
    function updateValuesDisplay(vals) {
        const pdMaxIdx = vals.PD_min.indexOf(Math.max(...vals.PD_min));
        
        // Find index of MLSS (PD closest to zero)
        let minAbsPD = Infinity;
        let pdZeroIdx = 0;
        for (let i = 0; i < vals.PD_min.length; i++) {
            const absPD = Math.abs(vals.PD_min[i]);
            if (absPD < minAbsPD) {
                minAbsPD = absPD;
                pdZeroIdx = i;
            }
        }
        
        // Find index of BLC ≈ 4.0
        let minDiffLa = Infinity;
        let la4Idx = 0;
        for (let i = 0; i < vals.La_accum.length; i++) {
            if (!isNaN(vals.La_accum[i])) {
                const diffLa = Math.abs(vals.La_accum[i] - 4.0);
                if (diffLa < minDiffLa) {
                    minDiffLa = diffLa;
                    la4Idx = i;
                }
            }
        }
        
        // Format the output text with proper units
        const formatOutput = (positionName, idx) => {
            const powerValue = appState.weight_based ? vals.P[idx]/appState.body_mass : vals.P[idx];
            const vo2ssValue = appState.weight_based ? vals.VO2ss[idx]/appState.body_mass : vals.VO2ss[idx];
            const powerUnit = appState.weight_based ? "W·kg⁻¹" : "W";
            const vo2ssUnit = appState.weight_based ? "ml·min⁻¹·kg⁻¹" : "ml·min⁻¹";
            
            return `${positionName} (${powerValue.toFixed(1)} ${powerUnit}):\n` +
                `  VO2ss: ${vo2ssValue.toFixed(2)} ${vo2ssUnit}\n` +
                `  vLass: ${vals.vLass_min[idx].toFixed(4)} mmol·l⁻¹·min⁻¹\n` +
                `  vLaox: ${vals.vLaox_min[idx].toFixed(4)} mmol·l⁻¹·min⁻¹\n` +
                `  PD: ${vals.PD_min[idx].toFixed(4)} mmol·l⁻¹·min⁻¹\n` +
                `  La Accumulation: ${isNaN(vals.La_accum[idx]) ? '0.0000' : vals.La_accum[idx].toFixed(4)} mmol·l⁻¹\n`;
        };
        
        let outputText = "";
        
        // Add cadence info if enabled
        if (appState.cadence_dependent) {
            outputText += `Cadence: ${appState.cadence} rpm\n`;
            outputText += `CE: ${vals.effective_values.CEVO2.toFixed(2)} ml·min⁻¹·W⁻¹, ` +
                         `V̇O<sub>2,Base</sub>: ${Math.round(vals.effective_values.VO2Base)} ml·min⁻¹\n`;
            
            if (appState.vo2max_dependent) {
                outputText += `V̇O<sub>2,max</sub>: ${Math.round(vals.effective_values.VO2max)} ml·min⁻¹\n`;
            }
            
            if (appState.vlamax_dependent) {
                outputText += `vLa<sub>max</sub>: ${vals.effective_values.vLamax.toFixed(2)} mmol·l⁻¹·s⁻¹\n`;
            }
            
            outputText += `\n`;
        }
        
        outputText += 
            formatOutput("FATmax", pdMaxIdx) +
            formatOutput("MLSS", pdZeroIdx) +
            formatOutput("BLC ≈ 4.0", la4Idx);
        
        elements.valuesContainer.innerHTML = outputText;
    }
    
    // Function to create power data for step test
    function createPowerData() {
        // Check if interval data is available
        if (appState.interval_data) {
            const data = appState.interval_data;
            
            // Sort by time
            data.sort((a, b) => a.time_s - b.time_s);
            
            // If we have at least two datapoints
            if (data.length > 1) {
                const minTime = data[0].time_s;
                const maxTime = data[data.length - 1].time_s;
                const allSeconds = [];
                const allPower = [];
                const allCadence = [];
                
                // Generate data for every second
                for (let t = minTime; t <= maxTime; t++) {
                    allSeconds.push(t);
                    
                    // Find the last power value at or before this time
                    let lastIdx = 0;
                    for (let i = 0; i < data.length; i++) {
                        if (data[i].time_s <= t) {
                            lastIdx = i;
                        } else {
                            break;
                        }
                    }
                    
                    allPower.push(data[lastIdx].power);
                    
                    // Add cadence if it exists
                    if (data[lastIdx].cadence !== undefined) {
                        allCadence.push(data[lastIdx].cadence);
                    } else {
                        allCadence.push(null);
                    }
                }
                
                return {
                    time_s: allSeconds,
                    power: allPower,
                    cadence: allCadence.every(c => c === null) ? null : allCadence
                };
            }
            
            // If there's cadence data in the interval data
            if (data.some(d => d.cadence !== undefined)) {
                return {
                    time_s: data.map(d => d.time_s),
                    power: data.map(d => d.power),
                    cadence: data.map(d => d.cadence || null)
                };
            } else {
                return {
                    time_s: data.map(d => d.time_s),
                    power: data.map(d => d.power),
                    cadence: null
                };
            }
        }
        // Check if a file was uploaded
        else if (appState.power_data) {
            return appState.power_data;
        }
        // Create step test data
        else {
            const stepWatt = appState.step_watt;
            const stepDurationSec = appState.step_duration;
            const maxPower = appState.max_power_step;
            
            // Create time and power arrays
            const numSteps = Math.floor(maxPower / stepWatt) + 1;
            const totalDurationSec = numSteps * stepDurationSec;
            const timeSec = [];
            const power = [];
            
            for (let i = 0; i <= totalDurationSec; i++) {
                timeSec.push(i);
                const currentStep = Math.floor(i / stepDurationSec);
                power.push(currentStep * stepWatt);
            }
            
            return {
                time_s: timeSec,
                power: power,
                cadence: null // No cadence in generated data
            };
        }
    }
    
    // Calculate W' Balance using Skiba's model
    function calcWPrimeBalance(powerValues, timeValues, cp, wprime) {
        const wprimeBalance = [];
        wprimeBalance[0] = wprime * 1000;  // Convert to Joules
        
        for (let i = 1; i < powerValues.length; i++) {
            // Time difference between current and previous measurement
            const deltaT = timeValues[i] - timeValues[i-1];
            
            // Calculate W' consumption/recovery
            if (powerValues[i-1] > cp) {
                // W' is consumed when power > CP
                const wprimeExp = (powerValues[i-1] - cp) * deltaT;
                wprimeBalance[i] = wprimeBalance[i-1] - wprimeExp;
            } else {
                // W' recovers when power < CP
                // Calculate DCP and time constant using Skiba's formula
                const dcp = cp - powerValues[i-1];
                const tauWPrime = 546 * Math.exp(-0.01 * dcp) + 316;
                
                // Exponential recovery
                wprimeBalance[i] = wprime * 1000 - (wprime * 1000 - wprimeBalance[i-1]) * Math.exp(-deltaT / tauWPrime);
            }
            
            // Ensure W' Balance doesn't exceed maximum
            wprimeBalance[i] = Math.min(wprimeBalance[i], wprime * 1000);
        }
        
        // Convert from Joules to kJ for display
        return wprimeBalance.map(w => w / 1000);
    }
    
        // Function to calculate step test simulation
        function calculateStepTest() {
            // Get parameters - either from tab 1 or individual
            let CE = appState.use_tab1_params ? appState.CEVO2 : appState.CEVO2_step;
            let CE_range = appState.use_tab1_params ? appState.CE_range : appState.CE_range_step;
            let isCurvilinear = appState.use_tab1_params ? appState.curvilinear : appState.curvilinear_step;
            let VO2max = appState.use_tab1_params ? appState.VO2max : appState.VO2max_step;
            let VO2Base = appState.use_tab1_params ? appState.VO2Base : appState.VO2Base_step;
            let vLamax = appState.use_tab1_params ? appState.vLamax : appState.vLamax_step;
            let body_mass = appState.use_tab1_params ? appState.body_mass : appState.body_mass_step;
            
            // Get power data
            const powerData = createPowerData();
            const timePoints = powerData.time_s;
            let powerValues = [...powerData.power];
            
            // Extract cadence data if available
            let cadenceValues = null;
            
            if (appState.cadence_dependent_step && powerData.cadence && appState.use_file_cadence) {
                cadenceValues = [...powerData.cadence];
                
                // Fill any null values with the fixed cadence value
                cadenceValues = cadenceValues.map(c => c === null ? appState.cadence_step : c);
            }
            
            // Smooth power values if selected
            if (appState.smooth_power && powerValues.length >= 15) {
                powerValues = smoothData(powerValues, 15);
                
                // Replace NaN values at beginning and end
                const naIndices = powerValues.map((v, i) => isNaN(v) ? i : null).filter(i => i !== null);
                if (naIndices.length > 0) {
                    for (const i of naIndices) {
                        if (i <= powerValues.length / 2) {
                            // For beginning
                            const nextValid = powerValues.findIndex(v => !isNaN(v));
                            powerValues[i] = powerValues[nextValid];
                        } else {
                            // For end
                            const prevValid = powerValues.map((v, i) => !isNaN(v) ? i : null)
                                .filter(i => i !== null)
                                .pop();
                            powerValues[i] = powerValues[prevValid];
                        }
                    }
                }
                
                // Smooth cadence values if available
                if (cadenceValues) {
                    cadenceValues = smoothData(cadenceValues, 10);
                    
                    // Replace NaN values at beginning and end
                    const naCadenceIndices = cadenceValues.map((v, i) => isNaN(v) ? i : null).filter(i => i !== null);
                    if (naCadenceIndices.length > 0) {
                        for (const i of naCadenceIndices) {
                            if (i <= cadenceValues.length / 2) {
                                // For beginning
                                const nextValid = cadenceValues.findIndex(v => !isNaN(v));
                                cadenceValues[i] = cadenceValues[nextValid];
                            } else {
                                // For end
                                const prevValid = cadenceValues.map((v, i) => !isNaN(v) ? i : null)
                                    .filter(i => i !== null)
                                    .pop();
                                cadenceValues[i] = cadenceValues[prevValid];
                            }
                        }
                    }
                }
            }
            
            // Arrays to store cadence-dependent parameters
            const effectiveCEVO2 = new Array(timePoints.length);
            const effectiveVO2Base = new Array(timePoints.length);
            const effectiveVLamax = new Array(timePoints.length);
            const effectiveVO2max = new Array(timePoints.length);
            
            // Calculate cadence-dependent parameters
            if (appState.cadence_dependent_step) {
                // For each time point, calculate the effective parameters
                for (let i = 0; i < timePoints.length; i++) {
                    // Determine cadence to use - either from file or fixed value
                    const currentCadence = (cadenceValues && appState.use_file_cadence) ? 
                        cadenceValues[i] : appState.cadence_step;
                    
                    // CE and VO2Base are always cadence-dependent
                    effectiveCEVO2[i] = calculateCadenceDependentCEVO2(currentCadence);
                    effectiveVO2Base[i] = calculateCadenceDependentVO2Base(currentCadence);
                    
                    // Optional vLamax dependency
                    if (appState.vlamax_dependent_step) {
                        effectiveVLamax[i] = calculateCadenceDependentVLamax(currentCadence, vLamax);
                    } else {
                        effectiveVLamax[i] = vLamax;
                    }
                    
                    // Optional VO2max dependency
                    if (appState.vo2max_dependent_step) {
                        effectiveVO2max[i] = calculateCadenceDependentVO2max(currentCadence, VO2max);
                    } else {
                        effectiveVO2max[i] = VO2max;
                    }
                }
            } else {
                // If cadence dependency not enabled, use fixed values for all time points
                for (let i = 0; i < timePoints.length; i++) {
                    effectiveCEVO2[i] = CE;
                    effectiveVO2Base[i] = VO2Base;
                    effectiveVLamax[i] = vLamax;
                    effectiveVO2max[i] = VO2max;
                }
            }
            
            // Constants
            const CELaO2 = 0.02049 / body_mass;
            const VolLa = 0.4;
            const ks1 = 0.0635;
            const ks2 = Math.pow(1.1, 3);
            
            // Simulation parameters
            const vo2UpTimeConstant = appState.vo2_up_time_constant;
            const vo2DownTimeConstant = appState.vo2_down_time_constant;
            const laMax = appState.la_max;
            const laBase = appState.la_base;
            
            // Calculate VO2 target values with curvilinear option
            const vo2Target = [];
            let aOpt = null;
            
            // Falls curvilinear benutzt wird, a-Koeffizienten berechnen
            if (isCurvilinear) {
                aOpt = findOptimalA(CE_range[0], CE_range[1], VO2max, VO2Base);
            }
            
            for (let i = 0; i < timePoints.length; i++) {
                let vo2ss;
                if (isCurvilinear) {
                    vo2ss = aOpt * Math.pow(powerValues[i], 2) + CE_range[0] * powerValues[i] + effectiveVO2Base[i];
                } else {
                    vo2ss = effectiveCEVO2[i] * powerValues[i] + effectiveVO2Base[i];
                }
                vo2Target[i] = Math.min(vo2ss, effectiveVO2max[i]); // Limited by VO2max
            }
            
            // Mono-exponential VO2 adaptation
            const vo2Actual = [effectiveVO2Base[0]]; // Start with baseline
            
            for (let i = 1; i < timePoints.length; i++) {
                const deltaT = timePoints[i] - timePoints[i-1];
                
                // Current and target VO2
                const currentVo2 = vo2Actual[i-1];
                const targetVo2 = vo2Target[i];
                const vo2DiffToTarget = targetVo2 - currentVo2;
                
                // Choose time constant based on whether VO2 is rising or falling
                const timeConstant = (vo2DiffToTarget >= 0) ? vo2UpTimeConstant : vo2DownTimeConstant;
                
                // Mono-exponential adaptation over the time interval
                const vo2Change = vo2DiffToTarget * (1 - Math.exp(-deltaT / timeConstant));
                vo2Actual.push(currentVo2 + vo2Change);
            }
            
            // Calculate lactate production
            const vLass = [];
            for (let i = 0; i < timePoints.length; i++) {
                vLass[i] = effectiveVLamax[i] / (1 + ks2 * Math.pow((effectiveVO2max[i] - vo2Actual[i])/(ks1 * vo2Actual[i]), 3/2));
            }
            
            // Calculate lactate oxidation
            const vLaox = vo2Actual.map(vo2 => (CELaO2 * vo2) / (VolLa * 60));
            
            // Convert to minutes for display
            const vLassMin = vLass.map(v => v * 60);
            const vLaoxMin = vLaox.map(v => v * 60);
            
            // Calculate pyruvate deficit
            const PD = vLaoxMin.map((ox, i) => ox - vLassMin[i]);
            
            // Calculate lactate accumulation
            const LaConc = [laBase]; // Start with baseline
            
            // Find simulation endpoint (La_max reached)
            let endIdx = timePoints.length;
            let abortIdx = null;
            let abortPower = null;
            let abortTime = null;
            
            for (let i = 1; i < timePoints.length; i++) {
                // Change in lactate per second
                const deltaT = timePoints[i] - timePoints[i-1];
                // Adjusted elimination - depends on current level
                const deltaLa = (vLass[i] - (vLaox[i] * Math.min(LaConc[i-1], 15) / 8)) * deltaT;
                LaConc.push(Math.max(laBase, LaConc[i-1] + deltaLa)); // Prevent dropping below baseline
                
                // Check if LA_max reached
                if (LaConc[i] >= laMax && abortIdx === null) {
                    abortIdx = i;
                    endIdx = i;
                    abortPower = powerValues[i];
                    abortTime = timePoints[i];
                }
            }
            
            // Calculate W' Balance
            const cp = appState.critical_power;
            const wprime = appState.w_prime;
            const wprimeBalance = calcWPrimeBalance(powerValues, timePoints, cp, wprime);
            
            // Truncate data if LA_max reached
            if (endIdx < timePoints.length) {
                const trimmedTimePoints = timePoints.slice(0, endIdx + 1);
                const trimmedPowerValues = powerValues.slice(0, endIdx + 1);
                const trimmedVo2Actual = vo2Actual.slice(0, endIdx + 1);
                const trimmedVLassMin = vLassMin.slice(0, endIdx + 1);
                const trimmedVLaoxMin = vLaoxMin.slice(0, endIdx + 1);
                const trimmedPD = PD.slice(0, endIdx + 1);
                const trimmedLaConc = LaConc.slice(0, endIdx + 1);
                const trimmedWprimeBalance = wprimeBalance.slice(0, endIdx + 1);
                
                // Only include cadence data if it's available and being used
                let trimmedCadence = null;
                if (cadenceValues && appState.cadence_dependent_step && appState.use_file_cadence) {
                    trimmedCadence = cadenceValues.slice(0, endIdx + 1);
                }
                
                return {
                    time_sec: trimmedTimePoints,
                    power: trimmedPowerValues,
                    VO2: trimmedVo2Actual,
                    vLass_min: trimmedVLassMin,
                    vLaox_min: trimmedVLaoxMin,
                    PD: trimmedPD,
                    La_conc: trimmedLaConc,
                    w_prime_bal: trimmedWprimeBalance,
                    abort_power: abortPower,
                    abort_time: abortTime,
                    cadence: trimmedCadence,
                    is_curvilinear: isCurvilinear,
                    a_opt: aOpt,
                    ce_range: CE_range
                };
            }
            
            // If cadence data is available and being used, include it in the return object
            let finalCadence = null;
            if (cadenceValues && appState.cadence_dependent_step && appState.use_file_cadence) {
                finalCadence = cadenceValues;
            } else if (appState.cadence_dependent_step) {
                // Use fixed cadence if cadence dependency is enabled but no file data is used
                finalCadence = new Array(timePoints.length).fill(appState.cadence_step);
            }
            
            return {
                time_sec: timePoints,
                power: powerValues,
                VO2: vo2Actual,
                vLass_min: vLassMin,
                vLaox_min: vLaoxMin,
                PD: PD,
                La_conc: LaConc,
                w_prime_bal: wprimeBalance,
                abort_power: abortPower,
                abort_time: abortTime,
                cadence: finalCadence,
                is_curvilinear: isCurvilinear,
                a_opt: aOpt,
                ce_range: CE_range
            };
        }
        
        // Function to update the step test plot in Tab 2
        function updateStepTestPlot() {
            const stepData = calculateStepTest();
            
            // Use time directly in seconds
            const timeSec = stepData.time_sec;
            
            // Determine max time for x-axis (110% of last valid time)
            const maxTimeValue = Math.max(...timeSec) * 1.10;
            
            // Calculate max power value for y-axis
            const maxPowerValue = Math.max(...stepData.power) * 1.10;
            
            // Set lactate y-axis max value
            const maxLaktatValue = appState.la_max + 5;
            
            // Find the minimum W' balance value
            const minWprimeValue = Math.min(...stepData.w_prime_bal);
            
            // Calculate min and max LD value for y-axis
            const minLDValue = Math.min(...stepData.PD);
            const maxPDValue = Math.max(...stepData.PD);
            
            // Set y-axis limits for W' balance
            // Use the minimum of minWprimeValue and minLDValue, but ensure it's not less than -10
            const wprimeYmin = Math.max(-10, Math.min(minWprimeValue, minLDValue));
            
            // For the max y value, use the maximum of: maximum lactate value, W' (in kJ),
            // or maximum PD value, and multiply by 1.05 for a 5% buffer
            const wprimeYmax = Math.max(maxLaktatValue, appState.w_prime, maxPDValue) * 1.05;
            
            // Create traces for the plot
            const traces = [];
            
            // Power curve
            traces.push({
                x: timeSec,
                y: stepData.power,
                name: "Power",
                type: 'scatter',
                mode: 'lines',
                yaxis: "y",
                line: {color: 'darkgrey', width: 2, opacity: 0.8},
                showlegend: true
            });
            
            // Cadence data if available and dependency enabled
            if (stepData.cadence && appState.cadence_dependent_step) {
                traces.push({
                    x: timeSec,
                    y: stepData.cadence,
                    name: "Cadence",
                    type: 'scatter',
                    mode: 'lines',
                    yaxis: "y",
                    line: {color: 'lightgray', dash: 'dash', width: 2, opacity: 0.8},
                    showlegend: true
                });
            }
            
            // W' Balance curve - now using y2 axis shared with lactate
            traces.push({
                x: timeSec,
                y: stepData.w_prime_bal,
                name: "W' Balance",
                type: 'scatter',
                mode: 'lines',
                yaxis: "y2",
                line: {color: '#42BA97', width: 2, opacity: 0.8},
                showlegend: true
            });
            
            // VO2 curve
            traces.push({
                x: timeSec,
                y: stepData.VO2,
                name: "VO2",
                type: 'scatter',
                mode: 'lines',
                yaxis: "y3",
                line: {color: '#2683C6', width: 2, opacity: 0.8},
                showlegend: true
            });
            
            // Lactate accumulation
            traces.push({
                x: timeSec,
                y: stepData.La_conc,
                name: "Lactate",
                type: 'scatter',
                mode: 'lines',
                yaxis: "y2",
                line: {color: '#C8133B', width: 2, opacity: 0.8},
                showlegend: true
            });
            
            // vLass curve
            traces.push({
                x: timeSec,
                y: stepData.vLass_min,
                name: "vLass",
                type: 'scatter',
                mode: 'lines',
                yaxis: "y2",
                line: {color: '#EF5350', dash: 'dash', width: 2, opacity: 0.8},
                showlegend: true
            });
            
            // vLaox curve
            traces.push({
                x: timeSec,
                y: stepData.vLaox_min,
                name: "vLaox",
                type: 'scatter',
                mode: 'lines',
                yaxis: "y2",
                line: {color: '#1CADE4', dash: 'dash', width: 2, opacity: 0.8},
                showlegend: true
            });
            
            // Pyruvate deficit (PD) curve
            traces.push({
                x: timeSec,
                y: stepData.PD,
                name: "PD",
                type: 'scatter',
                mode: 'lines',
                yaxis: "y2",
                line: {color: '#9C85C0', width: 2, opacity: 0.8},
                showlegend: true
            });
            
            // Horizontal line for max lactate
            traces.push({
                x: [Math.min(...timeSec), Math.max(...timeSec)],
                y: [appState.la_max, appState.la_max],
                name: "Max Lactate",
                type: 'scatter',
                mode: 'lines',
                yaxis: "y2",
                line: {color: 'red', dash: 'dot', width: 1, opacity: 0.8},
                showlegend: true
            });
            
            // Horizontal line for Critical Power
            traces.push({
                x: [Math.min(...timeSec), Math.max(...timeSec)],
                y: [appState.critical_power, appState.critical_power],
                name: "Critical Power",
                type: 'scatter',
                mode: 'lines',
                yaxis: "y",
                line: {color: '#80CDC1', dash: 'dot', width: 1, opacity: 0.8},
                showlegend: true
            });
            
            // Zero line for W' balance reference
            traces.push({
                x: [Math.min(...timeSec), Math.max(...timeSec)],
                y: [0, 0],
                name: "Zero Line",
                type: 'scatter',
                mode: 'lines',
                yaxis: "y2",
                line: {color: '#666666', dash: 'dot', width: 1, opacity: 0.4},
                showlegend: false
            });
            
            // Annotations for abort criteria if reached
            const annotations = [];
            if (stepData.abort_power !== null) {
                annotations.push(
                    {
                        x: stepData.abort_time,
                        y: stepData.abort_power,
                        yref: "y",
                        text: `Abort at ${Math.round(stepData.abort_power)} W, ${Math.floor(stepData.abort_time/60)}:${(stepData.abort_time % 60).toString().padStart(2, '0')} min:s`,
                        showarrow: true,
                        arrowhead: 2,
                        arrowsize: 1,
                        arrowwidth: 2,
                        arrowcolor: '#666666',
                        ax: 0,
                        ay: -40
                    },
                    {
                        x: stepData.abort_time,
                        y: appState.la_max,
                        yref: "y2",
                        text: `Lactate: ${appState.la_max.toFixed(1)} mmol/l`,
                        showarrow: true,
                        arrowhead: 2,
                        arrowsize: 1,
                        arrowwidth: 2,
                        arrowcolor: '#C8133B',
                        ax: 20,
                        ay: 0
                    }
                );
            }
            
            // Formeltext für die CE-Beziehung
            let formulaText = '';
            const effectiveVO2Base = appState.use_tab1_params ? appState.VO2Base : appState.VO2Base_step;
            
            if (stepData.is_curvilinear) {
                formulaText = `VO<sub>2,SS</sub>(P) = ${stepData.a_opt.toFixed(4)} · P² + ${stepData.ce_range[0].toFixed(1)} · P + ${Math.round(effectiveVO2Base)}`;
            } else {
                const effectiveCE = appState.use_tab1_params ? appState.CEVO2 : appState.CEVO2_step;
                formulaText = `VO<sub>2,SS</sub>(P) = ${effectiveCE.toFixed(1)} · P + ${Math.round(effectiveVO2Base)}`;
            }
            
            // Füge Cadence-Info hinzu, wenn Cadence-Abhängigkeit aktiviert ist
            if (appState.cadence_dependent_step) {
                formulaText += `<br>(at cadence: ${appState.cadence_step} rpm)`;
            }
            
            // Füge Formel-Annotation hinzu
            annotations.push({
                x: maxTimeValue * 0.20,
                y: appState.use_tab1_params ? appState.VO2max * 0.90 : appState.VO2max_step * 0.90,
                text: formulaText,
                showarrow: false,
                font: {
                    family: "Arial",
                    size: 12,
                    color: "#666666"
                },
                xanchor: "center",
                yanchor: "middle",
                yref: "y3"
            });
            
            // Create layout for the plot
            let layout = {
                title: {
                    text: "Exercise Simulation",
                    font: {
                        size: 18,
                        color: '#2683C6'
                    }
                },
                margin: {l: 80, r: 80, t: 60, b: 80},
                xaxis: {
                    title: {
                        text: "Time (s)",
                        font: {
                            size: 14
                        }
                    },
                    range: [0, maxTimeValue],
                    showgrid: true,
                    gridcolor: 'rgba(200,200,200,0.2)'
                },
                yaxis: {
                    title: {
                        text: "Power (W) / Cadence (rpm)",
                        font: {
                            size: 14
                        }
                    },
                    range: [0, maxPowerValue],
                    showgrid: true,
                    gridcolor: 'rgba(200,200,200,0.2)',
                    side: 'left'
                },
                yaxis2: {
                    title: {
                        text: "Lactate (mmol·l⁻¹), La-Rates & W' Balance (kJ)",
                        font: {
                            size: 14
                        }
                    },
                    overlaying: "y",
                    side: "right",
                    range: [wprimeYmin, wprimeYmax],
                    showgrid: false
                },
                yaxis3: {
                    title: {
                        text: "VO₂ (ml·min⁻¹)",
                        font: {
                            size: 14
                        }
                    },
                    overlaying: "y",
                    side: "right",
                    anchor: "free",
                    position: 0.93,
                    range: [0, appState.use_tab1_params ? appState.VO2max * 1.05 : appState.VO2max_step * 1.05],
                    showgrid: false
                },
                showlegend: true,
                legend: {
                    x: 0.5,
                    y: 1.05,
                    xanchor: 'center',
                    yanchor: 'top',
                    orientation: 'h',
                    bgcolor: 'rgba(255, 255, 255, 0)',
                    bordercolor: 'rgba(0,0,0,0)',
                    borderwidth: 0
                },
                annotations: annotations,
                paper_bgcolor: 'rgba(255,255,255,0)',
                plot_bgcolor: 'rgba(255,255,255,0.5)',
                hovermode: 'closest'
            };
            
            // Create a new plot with consistent settings
            Plotly.newPlot('steptest-plot-container', traces, layout, {
                displayModeBar: true,
                responsive: true
            });
        }
        
        // Function to show notification
        function showNotification(message, type = 'info') {
            elements.notification.innerHTML = message;
            elements.notification.className = `notification ${type}`;
            elements.notification.style.display = 'block';
            
            // Hide after 3 seconds
            setTimeout(() => {
                elements.notification.style.display = 'none';
            }, 3000);
        }
        
        // Function to update Critical Power from MLSS
        function updateCriticalPowerFromMlss() {
            if (appState.use_mlss_as_cp && appState.mlss_value) {
                appState.critical_power = appState.mlss_value;
                elements.critical_power.value = appState.mlss_value;
                elements.critical_powerValue.textContent = appState.mlss_value;
                
                // Disable the slider if the checkbox is checked
                elements.critical_power.disabled = true;
            }
        }
        
        // Event handlers for Tab 1
        elements.CEVO2.addEventListener('input', function() {
            appState.CEVO2 = parseFloat(this.value);
            elements.CEVO2Value.textContent = appState.CEVO2.toFixed(1);
            
            // Synchronize with Tab 2 if parameters are linked
            if (appState.use_tab1_params) {
                appState.CEVO2_step = appState.CEVO2;
                elements.CEVO2_step.value = appState.CEVO2;
                elements.CEVO2_stepValue.textContent = appState.CEVO2.toFixed(1);
            }
            
            // Update plot and critical power
            updatePlot();
            updateStepTestPlot();
        });
        
        elements.CE_range_start.addEventListener('input', function() {
            appState.CE_range[0] = parseFloat(this.value);
            elements.CE_range_startValue.textContent = appState.CE_range[0].toFixed(1);
            updatePlot();
            
            // Synchronize with Tab 2 if parameters are linked
            if (appState.use_tab1_params) {
                appState.CE_range_step[0] = appState.CE_range[0];
                elements.CE_range_start_step.value = appState.CE_range[0];
                elements.CE_range_start_stepValue.textContent = appState.CE_range[0].toFixed(1);
                updateStepTestPlot();
            }
        });
        
        elements.CE_range_end.addEventListener('input', function() {
            appState.CE_range[1] = parseFloat(this.value);
            elements.CE_range_endValue.textContent = appState.CE_range[1].toFixed(1);
            updatePlot();
            
            // Synchronize with Tab 2 if parameters are linked
            if (appState.use_tab1_params) {
                appState.CE_range_step[1] = appState.CE_range[1];
                elements.CE_range_end_step.value = appState.CE_range[1];
                elements.CE_range_end_stepValue.textContent = appState.CE_range[1].toFixed(1);
                updateStepTestPlot();
            }
        });
        
        elements.VO2max.addEventListener('input', function() {
            appState.VO2max = parseFloat(this.value);
            elements.VO2maxValue.textContent = appState.VO2max.toFixed(0);
            // Update relative VO2max
            appState.VO2max_kg = appState.VO2max / appState.body_mass;
            elements.VO2max_kgValue.textContent = appState.VO2max_kg.toFixed(2);
            
            // Synchronize with Tab 2 if parameters are linked
            if (appState.use_tab1_params) {
                appState.VO2max_step = appState.VO2max;
                elements.VO2max_step.value = appState.VO2max;
                elements.VO2max_stepValue.textContent = appState.VO2max.toFixed(0);
            }
            
            updatePlot();
            updateStepTestPlot();
        });
        
        elements.VO2max_kg.addEventListener('input', function() {
            appState.VO2max_kg = parseFloat(this.value);
            elements.VO2max_kgValue.textContent = appState.VO2max_kg.toFixed(2);
            // Update absolute VO2max
            appState.VO2max = appState.VO2max_kg * appState.body_mass;
            elements.VO2max.value = appState.VO2max;
            elements.VO2maxValue.textContent = appState.VO2max.toFixed(0);
            
            // Synchronize with Tab 2 if parameters are linked
            if (appState.use_tab1_params) {
                appState.VO2max_step = appState.VO2max;
                elements.VO2max_step.value = appState.VO2max;
                elements.VO2max_stepValue.textContent = appState.VO2max.toFixed(0);
            }
            
            updatePlot();
            updateStepTestPlot();
        });
        
        elements.VO2Base.addEventListener('input', function() {
            appState.VO2Base = parseFloat(this.value);
            elements.VO2BaseValue.textContent = appState.VO2Base.toFixed(0);
            
            // Synchronize with Tab 2 if parameters are linked
            if (appState.use_tab1_params) {
                appState.VO2Base_step = appState.VO2Base;
                elements.VO2Base_step.value = appState.VO2Base;
                elements.VO2Base_stepValue.textContent = appState.VO2Base.toFixed(0);
            }
            
            updatePlot();
            updateStepTestPlot();
        });
        
        elements.vLamax.addEventListener('input', function() {
            appState.vLamax = parseFloat(this.value);
            elements.vLamaxValue.textContent = appState.vLamax.toFixed(2);
            
            // Synchronize with Tab 2 if parameters are linked
            if (appState.use_tab1_params) {
                appState.vLamax_step = appState.vLamax;
                elements.vLamax_step.value = appState.vLamax;
                elements.vLamax_stepValue.textContent = appState.vLamax.toFixed(2);
            }
            
            updatePlot();
            updateStepTestPlot();
        });
        
        elements.body_mass.addEventListener('input', function() {
            appState.body_mass = parseFloat(this.value);
            elements.body_massValue.textContent = appState.body_mass.toFixed(1);
            
            // Update relative VO2max if weight changes
            appState.VO2max_kg = appState.VO2max / appState.body_mass;
            elements.VO2max_kg.value = appState.VO2max_kg;
            elements.VO2max_kgValue.textContent = appState.VO2max_kg.toFixed(2);
            
            // Synchronize with Tab 2 if parameters are linked
            if (appState.use_tab1_params) {
                appState.body_mass_step = appState.body_mass;
                elements.body_mass_step.value = appState.body_mass;
                elements.body_mass_stepValue.textContent = appState.body_mass.toFixed(1);
            }
            
            updatePlot();
            updateStepTestPlot();
        });
        
        elements.age.addEventListener('input', function() {
            appState.age = parseInt(this.value);
            elements.ageValue.textContent = appState.age;
        });
        
        elements.height.addEventListener('input', function() {
            appState.height = parseInt(this.value);
            elements.heightValue.textContent = appState.height;
        });
        
        elements.male.addEventListener('change', function() {
            if (this.checked) {
                appState.gender = 'Male';
            }
        });
        
        elements.female.addEventListener('change', function() {
            if (this.checked) {
                appState.gender = 'Female';
            }
        });
        
        elements.curvilinear.addEventListener('change', function() {
            appState.curvilinear = this.checked;
            elements.linearCeControl.style.display = this.checked ? 'none' : 'block';
            elements.curvilinearCeControl.style.display = this.checked ? 'block' : 'none';
            
            // Synchronize with Tab 2 if parameters are linked
            if (appState.use_tab1_params) {
                appState.curvilinear_step = appState.curvilinear;
                elements.curvilinear_step.checked = appState.curvilinear;
                elements.linearCeControlStep.style.display = appState.curvilinear ? 'none' : 'block';
                elements.curvilinearCeControlStep.style.display = appState.curvilinear ? 'block' : 'none';
            }
            
            updatePlot();
            updateStepTestPlot();
        });
        
        // Cadence Dependency Event Handlers for Tab 1
        elements.cadence_dependent.addEventListener('change', function() {
            appState.cadence_dependent = this.checked;
            elements.cadenceControls.style.display = appState.cadence_dependent ? 'block' : 'none';
            updatePlot();
            
            if (this.checked) {
                // Show notification about cadence dependency
                showNotification(`Cadence dependency enabled at ${appState.cadence} rpm. Using model from Dunst et al. (2025) with CE = ${calculateCadenceDependentCEVO2(appState.cadence).toFixed(2)} ml·min⁻¹·W⁻¹ and V̇O<sub>2,Base</sub> = ${Math.round(calculateCadenceDependentVO2Base(appState.cadence))} ml·min⁻¹`, 'info');
            }
        });
        
        elements.cadence.addEventListener('input', function() {
            appState.cadence = parseInt(this.value);
            elements.cadenceValue.textContent = appState.cadence;
            updatePlot();
        });
        
        elements.vo2max_dependent.addEventListener('change', function() {
            appState.vo2max_dependent = this.checked;
            updatePlot();
            
            if (this.checked && appState.cadence_dependent) {
                showNotification(`V̇O<sub>2,max</sub> cadence dependency enabled. This feature is based on Fig.4 from Dunst et al. (2025).`, 'info');
            }
        });
        
        elements.vlamax_dependent.addEventListener('change', function() {
            appState.vlamax_dependent = this.checked;
            updatePlot();
            
            if (this.checked && appState.cadence_dependent) {
                showNotification(`vLa<sub>max</sub> cadence dependency enabled. The paper suggests this may reflect testing methodology rather than true physiological changes.`, 'warning');
            }
        });
        
        elements.weight_based.addEventListener('change', function() {
            appState.weight_based = this.checked;
            updatePlot();
            updateStepTestPlot();
        });
        
        elements.lock_y_axis.addEventListener('change', function() {
            appState.lock_y_axis = this.checked;
            updatePlot();
        });
        
        elements.lock_x_axis.addEventListener('change', function() {
            appState.lock_x_axis = this.checked;
            updatePlot();
        });
        
        elements.calculate_vo2base.addEventListener('click', function() {
            // Calculate BMR in kcal/day
            const bmr = calculateBMR(appState.gender, appState.body_mass, appState.height, appState.age);
            
            // Convert to VO2 in ml/min
            const calculatedVO2Base = calculateVO2Base(bmr, appState.gender);
            appState.calculated_vo2base = calculatedVO2Base;
            
            // Update VO2Base value
            appState.VO2Base = Math.round(calculatedVO2Base);
            elements.VO2Base.value = appState.VO2Base;
            elements.VO2BaseValue.textContent = appState.VO2Base.toFixed(0);
            
            // Synchronize with Tab 2 if parameters are linked
            if (appState.use_tab1_params) {
                appState.VO2Base_step = appState.VO2Base;
                elements.VO2Base_step.value = appState.VO2Base;
                elements.VO2Base_stepValue.textContent = appState.VO2Base.toFixed(0);
            }
            
            // Show notification
            showNotification(`VO₂,Base calculated: ${Math.round(calculatedVO2Base)} ml·min⁻¹`, 'info');
            
            // Update plot and critical power
            updatePlot();
            updateStepTestPlot();
        });
        
        // Event handlers for Tab 2
        elements.step_watt.addEventListener('input', function() {
            appState.step_watt = parseFloat(this.value);
            elements.step_wattValue.textContent = appState.step_watt;
            updateStepTestPlot();
        });
        
        elements.step_duration.addEventListener('input', function() {
            appState.step_duration = parseFloat(this.value);
            elements.step_durationValue.textContent = appState.step_duration;
            updateStepTestPlot();
        });
        
        elements.max_power_step.addEventListener('input', function() {
            appState.max_power_step = parseFloat(this.value);
            elements.max_power_stepValue.textContent = appState.max_power_step;
            updateStepTestPlot();
        });
        
        elements.vo2_up_time_constant.addEventListener('input', function() {
            appState.vo2_up_time_constant = parseFloat(this.value);
            elements.vo2_up_time_constantValue.textContent = appState.vo2_up_time_constant;
            updateStepTestPlot();
        });
        
        elements.vo2_down_time_constant.addEventListener('input', function() {
            appState.vo2_down_time_constant = parseFloat(this.value);
            elements.vo2_down_time_constantValue.textContent = appState.vo2_down_time_constant;
            updateStepTestPlot();
        });
        
        elements.la_max.addEventListener('input', function() {
            appState.la_max = parseFloat(this.value);
            elements.la_maxValue.textContent = appState.la_max.toFixed(1);
            updateStepTestPlot();
        });
        
        elements.la_base.addEventListener('input', function() {
            appState.la_base = parseFloat(this.value);
            elements.la_baseValue.textContent = appState.la_base.toFixed(1);
            updateStepTestPlot();
        });
        
        elements.critical_power.addEventListener('input', function() {
            // Only update if not linked to MLSS
            if (!appState.use_mlss_as_cp) {
                appState.critical_power = parseFloat(this.value);
                elements.critical_powerValue.textContent = appState.critical_power;
                updateStepTestPlot();
            } else {
                // Reset to MLSS value if linked
                this.value = appState.mlss_value;
                showNotification("CP is linked to MLSS. Uncheck option to change manually.", 'info');
            }
        });
        
        elements.w_prime.addEventListener('input', function() {
            appState.w_prime = parseFloat(this.value);
            elements.w_primeValue.textContent = appState.w_prime.toFixed(1);
            updateStepTestPlot();
        });
        
        elements.use_mlss_as_cp.addEventListener('change', function() {
            appState.use_mlss_as_cp = this.checked;
            
            if (this.checked && appState.mlss_value) {
                // Update CP to MLSS value
                appState.critical_power = appState.mlss_value;
                elements.critical_power.value = appState.mlss_value;
                elements.critical_powerValue.textContent = appState.mlss_value;
                
                // Disable the Critical Power slider
                elements.critical_power.disabled = true;
                showNotification("Critical Power linked to MLSS: " + Math.round(appState.mlss_value) + " W", 'info');
            } else {
                // Enable the Critical Power slider
                elements.critical_power.disabled = false;
            }
            
            updateStepTestPlot();
        });
        
        // Cadence Dependency Event Handlers for Tab 2
        elements.cadence_dependent_step.addEventListener('change', function() {
            appState.cadence_dependent_step = this.checked;
            elements.cadenceControlsStep.style.display = appState.cadence_dependent_step ? 'block' : 'none';
            updateStepTestPlot();
            
            if (this.checked) {
                // Show notification about cadence dependency
                showNotification(`Exercise simulation cadence dependency enabled at ${appState.cadence_step} rpm. This will modify the metabolic parameters based on cadence.`, 'info');
            }
        });
        
        elements.cadence_step.addEventListener('input', function() {
            appState.cadence_step = parseInt(this.value);
            elements.cadence_stepValue.textContent = appState.cadence_step;
            updateStepTestPlot();
        });
        
        elements.vo2max_dependent_step.addEventListener('change', function() {
            appState.vo2max_dependent_step = this.checked;
            updateStepTestPlot();
        });
        
        elements.vlamax_dependent_step.addEventListener('change', function() {
            appState.vlamax_dependent_step = this.checked;
            updateStepTestPlot();
        });
        
        elements.use_file_cadence.addEventListener('change', function() {
            appState.use_file_cadence = this.checked;
            
            if (this.checked) {
                // Check if we have cadence data in the current file
                const powerData = createPowerData();
                if (powerData.cadence) {
                    showNotification("Using cadence data from file for simulation.", 'info');
                } else {
                    showNotification("No cadence data available in current file. Fixed cadence will be used.", 'warning');
                    this.checked = false;
                    appState.use_file_cadence = false;
                }
            }
            
            updateStepTestPlot();
        });
        
        // Neue Event-Handler für die curvilinear CE relationship in Tab 2
        elements.curvilinear_step.addEventListener('change', function() {
            appState.curvilinear_step = this.checked;
            elements.linearCeControlStep.style.display = this.checked ? 'none' : 'block';
            elements.curvilinearCeControlStep.style.display = this.checked ? 'block' : 'none';
            updateStepTestPlot();
        });
        
        elements.CE_range_start_step.addEventListener('input', function() {
            appState.CE_range_step[0] = parseFloat(this.value);
            elements.CE_range_start_stepValue.textContent = appState.CE_range_step[0].toFixed(1);
            updateStepTestPlot();
        });
        
        elements.CE_range_end_step.addEventListener('input', function() {
            appState.CE_range_step[1] = parseFloat(this.value);
            elements.CE_range_end_stepValue.textContent = appState.CE_range_step[1].toFixed(1);
            updateStepTestPlot();
        });
        
        elements.use_tab1_params.addEventListener('change', function() {
            appState.use_tab1_params = this.checked;
            elements.individual_params.style.display = 'block'; // Always display, regardless of checkbox status
            
            // If parameters are linked, update the parameters accordingly
            if (this.checked) {
                // Synchronize Tab 2 parameters with Tab 1
                appState.CEVO2_step = appState.CEVO2;
                appState.VO2max_step = appState.VO2max;
                appState.VO2Base_step = appState.VO2Base;
                appState.vLamax_step = appState.vLamax;
                appState.body_mass_step = appState.body_mass;
                
                // Synchronize curvilinear settings
                appState.curvilinear_step = appState.curvilinear;
                appState.CE_range_step = [...appState.CE_range];
                
                // Update displayed values
                elements.CEVO2_step.value = appState.CEVO2;
                elements.CEVO2_stepValue.textContent = appState.CEVO2.toFixed(1);
                elements.VO2max_step.value = appState.VO2max;
                elements.VO2max_stepValue.textContent = appState.VO2max.toFixed(0);
                elements.VO2Base_step.value = appState.VO2Base;
                elements.VO2Base_stepValue.textContent = appState.VO2Base.toFixed(0);
                elements.vLamax_step.value = appState.vLamax;
                elements.vLamax_stepValue.textContent = appState.vLamax.toFixed(2);
                elements.body_mass_step.value = appState.body_mass;
                elements.body_mass_stepValue.textContent = appState.body_mass.toFixed(1);
                
                // Update curvilinear controls
                elements.curvilinear_step.checked = appState.curvilinear;
                elements.CE_range_start_step.value = appState.CE_range[0];
                elements.CE_range_start_stepValue.textContent = appState.CE_range[0].toFixed(1);
                elements.CE_range_end_step.value = appState.CE_range[1];
                elements.CE_range_end_stepValue.textContent = appState.CE_range[1].toFixed(1);
                
                // Display correct CE controls based on curvilinear setting
                elements.linearCeControlStep.style.display = appState.curvilinear ? 'none' : 'block';
                elements.curvilinearCeControlStep.style.display = appState.curvilinear ? 'block' : 'none';
                
                // Synchronize MLSS value if checkbox is active
                updateCriticalPowerFromMlss();
                
                showNotification("Parameters synchronized with Tab 1", 'info');
            }
            
            updateStepTestPlot();
        });
        
        elements.smooth_power.addEventListener('change', function() {
            appState.smooth_power = this.checked;
            updateStepTestPlot();
        });
        
        elements.has_header.addEventListener('change', function() {
            appState.has_header = this.checked;
        });
        
        elements.CEVO2_step.addEventListener('input', function() {
            appState.CEVO2_step = parseFloat(this.value);
            elements.CEVO2_stepValue.textContent = appState.CEVO2_step.toFixed(1);
            
            // Synchronize with Tab 1 if parameters are linked
            if (appState.use_tab1_params) {
                appState.CEVO2 = appState.CEVO2_step;
                elements.CEVO2.value = appState.CEVO2;
                elements.CEVO2Value.textContent = appState.CEVO2.toFixed(1);
                updatePlot();
                updateCriticalPowerFromMlss();
            }
            
            updateStepTestPlot();
        });
        
        elements.VO2max_step.addEventListener('input', function() {
            appState.VO2max_step = parseFloat(this.value);
            elements.VO2max_stepValue.textContent = appState.VO2max_step.toFixed(0);
            
            // Synchronize with Tab 1 if parameters are linked
            if (appState.use_tab1_params) {
                appState.VO2max = appState.VO2max_step;
                elements.VO2max.value = appState.VO2max;
                elements.VO2maxValue.textContent = appState.VO2max.toFixed(0);
                // Update relative VO2max
                appState.VO2max_kg = appState.VO2max / appState.body_mass;
                elements.VO2max_kg.value = appState.VO2max_kg;
                elements.VO2max_kgValue.textContent = appState.VO2max_kg.toFixed(2);
                updatePlot();
                updateCriticalPowerFromMlss();
            }
            
            updateStepTestPlot();
        });
        
        elements.VO2Base_step.addEventListener('input', function() {
            appState.VO2Base_step = parseFloat(this.value);
            elements.VO2Base_stepValue.textContent = appState.VO2Base_step.toFixed(0);
            
            // Synchronize with Tab 1 if parameters are linked
            if (appState.use_tab1_params) {
                appState.VO2Base = appState.VO2Base_step;
                elements.VO2Base.value = appState.VO2Base;
                elements.VO2BaseValue.textContent = appState.VO2Base.toFixed(0);
                updatePlot();
                updateCriticalPowerFromMlss();
            }
            
            updateStepTestPlot();
        });
        
        elements.vLamax_step.addEventListener('input', function() {
            appState.vLamax_step = parseFloat(this.value);
            elements.vLamax_stepValue.textContent = appState.vLamax_step.toFixed(2);
            
            // Synchronize with Tab 1 if parameters are linked
            if (appState.use_tab1_params) {
                appState.vLamax = appState.vLamax_step;
                elements.vLamax.value = appState.vLamax;
                elements.vLamaxValue.textContent = appState.vLamax.toFixed(2);
                updatePlot();
                updateCriticalPowerFromMlss();
            }
            
            updateStepTestPlot();
        });
        
        elements.body_mass_step.addEventListener('input', function() {
            appState.body_mass_step = parseFloat(this.value);
            elements.body_mass_stepValue.textContent = appState.body_mass_step.toFixed(1);
            
            // Synchronize with Tab 1 if parameters are linked
            if (appState.use_tab1_params) {
                appState.body_mass = appState.body_mass_step;
                elements.body_mass.value = appState.body_mass;
                elements.body_massValue.textContent = appState.body_mass.toFixed(1);
                
                // Update relative VO2max if weight changes
                appState.VO2max_kg = appState.VO2max / appState.body_mass;
                elements.VO2max_kg.value = appState.VO2max_kg;
                elements.VO2max_kgValue.textContent = appState.VO2max_kg.toFixed(2);
                
                updatePlot();
                updateCriticalPowerFromMlss();
            }
            
            updateStepTestPlot();
        });
        
        // Load sample interval data
        elements.load_interval_example.addEventListener('click', function() {
            // Sample interval data
            appState.interval_data = [
            { time_s: 0, power: 0, cadence: 80 },      // Start: 0 Watt für 2 Minuten
            { time_s: 120, power: 200, cadence: 80 },  // 2 Minuten bei 200 Watt
            { time_s: 240, power: 250, cadence: 80 },  // Beginn der Intervalle - 2 Minuten bei 250 Watt
            { time_s: 360, power: 200, cadence: 80 },  // 2 Minuten Pause bei 200 Watt
            { time_s: 480, power: 300, cadence: 90 },  // 2 Minuten bei 300 Watt
            { time_s: 600, power: 200, cadence: 80 },  // 2 Minuten Pause bei 200 Watt
            { time_s: 720, power: 350, cadence: 90 },  // 2 Minuten bei 350 Watt
            { time_s: 840, power: 200, cadence: 80 },  // 2 Minuten Pause bei 200 Watt
            { time_s: 960, power: 400, cadence: 90 },  // 2 Minuten bei 400 Watt
            { time_s: 1080, power: 200, cadence: 80 }, // 2 Minuten Pause bei 200 Watt
            { time_s: 1200, power: 450, cadence: 90 }, // 2 Minuten bei 450 Watt
            { time_s: 1320, power: 200, cadence: 80 }, // 2 Minuten Pause bei 200 Watt
            { time_s: 1440, power: 500, cadence: 90 }, // 2 Minuten bei 500 Watt
            { time_s: 1560, power: 200, cadence: 80 }, // 5 Minuten bei 200 Watt zum Abkühlen
            { time_s: 1860, power: 100, cadence: 80 }, // 5 Minuten bei 100 Watt als Ausklang
            { time_s: 2160, power: 0, cadence: 80 }    // Ende des Programms
            ];
            
            // Clear any file upload data
            appState.power_data = null;
            elements.fileName.textContent = "";
            elements.power_data.value = "";
            
            // Show notification
            showNotification("Example interval data loaded with cadence values", 'info');
            
            // Update plot
            updateStepTestPlot();
        });
        
        // File upload handling
        elements.power_data.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            // Display the file name
            elements.fileName.textContent = file.name;
            
            // Clear any interval data
            appState.interval_data = null;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const contents = e.target.result;
                
                try {
                    // Parse CSV
                    const rows = contents.split('\n');
                    const startRow = appState.has_header ? 1 : 0;
                    
                    const time_s = [];
                    const power = [];
                    const cadence = [];
                    let hasCadenceData = false;
                    
                    for (let i = startRow; i < rows.length; i++) {
                        const row = rows[i].trim();
                        if (row === '') continue;
                        
                        const cells = row.split(';');
                        if (cells.length < 2) continue;
                        
                        // Parse values, assuming first column is time, second is power
                        const t = parseFloat(cells[0].replace(',', '.'));
                        const p = parseFloat(cells[1].replace(',', '.'));
                        
                        if (!isNaN(t) && !isNaN(p)) {
                            time_s.push(t);
                            power.push(p);
                            
                            // Check if we have cadence data (third column)
                            if (cells.length >= 3) {
                                const c = parseFloat(cells[2].replace(',', '.'));
                                if (!isNaN(c)) {
                                    cadence.push(c);
                                    hasCadenceData = true;
                                } else {
                                    cadence.push(null);
                                }
                            } else {
                                cadence.push(null);
                            }
                        }
                    }
                    
                    if (time_s.length > 0) {
                        appState.power_data = {
                            time_s: time_s,
                            power: power,
                            cadence: hasCadenceData ? cadence : null
                        };
                        
                        // Show notification
                        let message = `${time_s.length} data points successfully loaded`;
                        if (hasCadenceData) {
                            message += " with cadence data";
                            // Enable the use file cadence option if cadence data is available
                            if (appState.cadence_dependent_step) {
                                elements.use_file_cadence.disabled = false;
                            }
                        } else {
                            // Disable the use file cadence option if no cadence data is available
                            elements.use_file_cadence.disabled = true;
                            appState.use_file_cadence = false;
                            elements.use_file_cadence.checked = false;
                        }
                        
                        showNotification(message, 'info');
                        
                        // Update plot
                        updateStepTestPlot();
                    } else {
                        showNotification("No valid data found in the file", 'warning');
                    }
                } catch (error) {
                    console.error("Error parsing file:", error);
                    showNotification("Error parsing the file", 'warning');
                }
            };
            
            reader.readAsText(file);
        });
        
        // Initialize with default values
        // Update controls with initial values
        elements.CEVO2Value.textContent = appState.CEVO2.toFixed(1);
        elements.CE_range_startValue.textContent = appState.CE_range[0].toFixed(1);
        elements.CE_range_endValue.textContent = appState.CE_range[1].toFixed(1);
        elements.VO2maxValue.textContent = appState.VO2max.toFixed(0);
        elements.VO2max_kgValue.textContent = appState.VO2max_kg.toFixed(2);
        elements.VO2BaseValue.textContent = appState.VO2Base.toFixed(0);
        elements.vLamaxValue.textContent = appState.vLamax.toFixed(2);
        elements.body_massValue.textContent = appState.body_mass.toFixed(1);
        elements.ageValue.textContent = appState.age;
        elements.heightValue.textContent = appState.height;
        elements.cadenceValue.textContent = appState.cadence;
        
        elements.cadence_stepValue.textContent = appState.cadence_step;
        elements.CEVO2_stepValue.textContent = appState.CEVO2_step.toFixed(1);
        elements.VO2max_stepValue.textContent = appState.VO2max_step.toFixed(0);
        elements.VO2Base_stepValue.textContent = appState.VO2Base_step.toFixed(0);
        elements.vLamax_stepValue.textContent = appState.vLamax_step.toFixed(2);
        elements.body_mass_stepValue.textContent = appState.body_mass_step.toFixed(1);
        elements.critical_powerValue.textContent = appState.critical_power;
        elements.w_primeValue.textContent = appState.w_prime.toFixed(1);
        elements.CE_range_start_stepValue.textContent = appState.CE_range_step[0].toFixed(1);
        elements.CE_range_end_stepValue.textContent = appState.CE_range_step[1].toFixed(1);
        
        // Set initial visibility of cadence controls
        elements.cadenceControls.style.display = 'none';
        elements.cadenceControlsStep.style.display = 'none';
        
        // Individual params area displayed by default
        elements.individual_params.style.display = 'block';
        
        // Initialize plots
        updatePlot();
        
        // Handle page resize events
        window.addEventListener('resize', function() {
            // Redraw all plots on resize
            updatePlot();
            if (document.getElementById('belastungssimulation-tab').classList.contains('active')) {
                updateStepTestPlot();
            }
        });
        
        // Calculate MLSS and set CP when loading the page
        updatePlot();
        
        // Set the use_mlss_as_cp checkbox to checked
        elements.use_mlss_as_cp.checked = appState.use_mlss_as_cp;
        
        // Immediately synchronize CP slider with current MLSS value
        if (appState.use_mlss_as_cp && appState.mlss_value) {
            appState.critical_power = appState.mlss_value;
            elements.critical_power.value = appState.mlss_value;
            elements.critical_powerValue.textContent = appState.mlss_value;
            elements.critical_power.disabled = true;
        }
        
        // Disable CP slider if use_mlss_as_cp is activated
        if (appState.use_mlss_as_cp) {
            elements.critical_power.disabled = true;
        }
        
        // Update plot once more to ensure everything is correct
        updateStepTestPlot();
</script>